; Listing generated by Microsoft (R) Optimizing Compiler Version 19.24.28315.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@PKEIPOBC@FILTER?5MOD?3?5A1200@	; `string'
PUBLIC	??_C@_0BB@ONPMACIL@FILTER?5MOD?3?5A500@		; `string'
PUBLIC	??_C@_0CA@DJMKAAEN@Unable?5to?5open?5audio?5device?3?5?$CFs@ ; `string'
PUBLIC	??_C@_0DO@LPEDDBAN@Unable?5to?5open?5audio?3?5The?5audio@ ; `string'
PUBLIC	??_C@_0EK@FLPNBHOI@Unable?5to?5open?5audio?3?5The?5sampl@ ; `string'
PUBLIC	??_C@_0P@MCKMEEL@Out?5of?5memory?$CB@		; `string'
PUBLIC	??_C@_0BC@BCFDABOJ@AMIGA?5PANNING?5OFF@		; `string'
PUBLIC	??_C@_0BB@LDIONHPE@AMIGA?5PANNING?5ON@		; `string'
PUBLIC	??_C@_0BA@ELDAEBLE@OVERWRITE?5FILE?$DP@		; `string'
PUBLIC	??_C@_02GMLFBBN@wb@				; `string'
PUBLIC	??_C@_0P@KJEHIBPC@FILE?5I?1O?5ERROR@		; `string'
PUBLIC	??_C@_0BB@JCAIEAIK@RENDERING?5MOD?4?4?4@	; `string'
PUBLIC	??_C@_0N@HDBMFKCM@THREAD?5ERROR@		; `string'
PUBLIC	forceMixerOff
EXTRN	malloc:PROC
EXTRN	free:PROC
EXTRN	__imp_SDL_CreateThread:PROC
EXTRN	__imp_SDL_UnlockAudioDevice:PROC
EXTRN	__imp_SDL_OpenAudioDevice:PROC
EXTRN	__imp_SDL_CloseAudioDevice:PROC
EXTRN	fwrite:PROC
EXTRN	_stat64i32:PROC
EXTRN	__imp_SDL_LockAudioDevice:PROC
EXTRN	fseek:PROC
EXTRN	__imp_SDL_GetError:PROC
EXTRN	_beginthreadex:PROC
EXTRN	fclose:PROC
EXTRN	fopen:PROC
EXTRN	_endthreadex:PROC
EXTRN	__imp_SDL_PauseAudioDevice:PROC
EXTRN	fputc:PROC
EXTRN	__imp_SDL_DetachThread:PROC
EXTRN	ftell:PROC
COMM	audio:BYTE:0558H
COMM	cpu:WORD
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
COMM	editor:BYTE:038f8H
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
forceMixerOff DB 01H DUP (?)
COMM	input:BYTE:048H
COMM	ptConfig:BYTE:030H
COMM	samplesPerTick:DWORD
_DATA	ENDS
;	COMDAT ??_C@_0N@HDBMFKCM@THREAD?5ERROR@
CONST	SEGMENT
??_C@_0N@HDBMFKCM@THREAD?5ERROR@ DB 'THREAD ERROR', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JCAIEAIK@RENDERING?5MOD?4?4?4@
CONST	SEGMENT
??_C@_0BB@JCAIEAIK@RENDERING?5MOD?4?4?4@ DB 'RENDERING MOD...', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KJEHIBPC@FILE?5I?1O?5ERROR@
CONST	SEGMENT
??_C@_0P@KJEHIBPC@FILE?5I?1O?5ERROR@ DB 'FILE I/O ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb@
CONST	SEGMENT
??_C@_02GMLFBBN@wb@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ELDAEBLE@OVERWRITE?5FILE?$DP@
CONST	SEGMENT
??_C@_0BA@ELDAEBLE@OVERWRITE?5FILE?$DP@ DB 'OVERWRITE FILE?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LDIONHPE@AMIGA?5PANNING?5ON@
CONST	SEGMENT
??_C@_0BB@LDIONHPE@AMIGA?5PANNING?5ON@ DB 'AMIGA PANNING ON', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BCFDABOJ@AMIGA?5PANNING?5OFF@
CONST	SEGMENT
??_C@_0BC@BCFDABOJ@AMIGA?5PANNING?5OFF@ DB 'AMIGA PANNING OFF', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MCKMEEL@Out?5of?5memory?$CB@
CONST	SEGMENT
??_C@_0P@MCKMEEL@Out?5of?5memory?$CB@ DB 'Out of memory!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@FLPNBHOI@Unable?5to?5open?5audio?3?5The?5sampl@
CONST	SEGMENT
??_C@_0EK@FLPNBHOI@Unable?5to?5open?5audio?3?5The?5sampl@ DB 'Unable to o'
	DB	'pen audio: The sample format (signed 16-bit) couldn''t be use'
	DB	'd!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@LPEDDBAN@Unable?5to?5open?5audio?3?5The?5audio@
CONST	SEGMENT
??_C@_0DO@LPEDDBAN@Unable?5to?5open?5audio?3?5The?5audio@ DB 'Unable to o'
	DB	'pen audio: The audio output rate couldn''t be used!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DJMKAAEN@Unable?5to?5open?5audio?5device?3?5?$CFs@
CONST	SEGMENT
??_C@_0CA@DJMKAAEN@Unable?5to?5open?5audio?5device?3?5?$CFs@ DB 'Unable t'
	DB	'o open audio device: %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ONPMACIL@FILTER?5MOD?3?5A500@
CONST	SEGMENT
??_C@_0BB@ONPMACIL@FILTER?5MOD?3?5A500@ DB 'FILTER MOD: A500', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PKEIPOBC@FILTER?5MOD?3?5A1200@
CONST	SEGMENT
??_C@_0BC@PKEIPOBC@FILTER?5MOD?3?5A1200@ DB 'FILTER MOD: A1200', 00H ; `string'
CONST	ENDS
PUBLIC	normalize8bitDoubleSigned
PUBLIC	normalize8bitFloatSigned
PUBLIC	normalize16bitSigned
PUBLIC	normalize32bitSigned
PUBLIC	calcMod2WavTotalRows
PUBLIC	renderToWav
PUBLIC	getAudioFrame
PUBLIC	toggleAmigaPanMode
PUBLIC	mixerClearSampleCounter
PUBLIC	mixerSetSamplesPerTick
PUBLIC	audioClose
PUBLIC	setupAudio
PUBLIC	mixerCalcVoicePans
PUBLIC	outputAudio
PUBLIC	resetDitherSeed
PUBLIC	mixChannels
PUBLIC	toggleA500Filters
PUBLIC	paulaSetData
PUBLIC	paulaSetLength
PUBLIC	paulaSetVolume
PUBLIC	paulaSetPeriod
PUBLIC	resetCachedMixerPeriod
PUBLIC	paulaStartDMA
PUBLIC	paulaStopDMA
PUBLIC	turnOffVoices
PUBLIC	mixerKillVoice
PUBLIC	mixerUpdateLoops
PUBLIC	clearPaulaAndScopes
PUBLIC	unlockAudio
PUBLIC	lockAudio
PUBLIC	lossyIntegratorHighPass
PUBLIC	lossyIntegrator
PUBLIC	calcCoeffLossyIntegrator
PUBLIC	toggleLEDFilter
PUBLIC	setLEDFilter
PUBLIC	fabsf
	ALIGN	4

oldPeriod DW	01H DUP (?)
	ALIGN	4

wavRenderingDone DB 01H DUP (?)
	ALIGN	4

filterLED DB	020H DUP (?)
	ALIGN	8

dMixBufferR DQ	01H DUP (?)
oldScopeDelta DD 01H DUP (?)
audioLocked DB	01H DUP (?)
	ALIGN	8

dMixBufferRUnaligned DQ 01H DUP (?)
maxSamplesToMix DD 01H DUP (?)
	ALIGN	8

dMixBufferL DQ	01H DUP (?)
filterHi DB	020H DUP (?)
defStereoSep DB	01H DUP (?)
	ALIGN	4

sampleCounter DD 01H DUP (?)
ch4Pan	DW	01H DUP (?)
	ALIGN	8

dOldVoiceDeltaMul DQ 01H DUP (?)
blepVol	DB	0140H DUP (?)
ch3Pan	DW	01H DUP (?)
	ALIGN	4

ch2Pan	DW	01H DUP (?)
	ALIGN	4

blep	DB	0140H DUP (?)
paula	DB	01c0H DUP (?)
dMixBufferLUnaligned DQ 01H DUP (?)
filterLEDC DB	010H DUP (?)
amigaPanFlag DB	01H DUP (?)
	ALIGN	4

filterLo DB	020H DUP (?)
	ALIGN	8

dOldVoiceDelta DQ 01H DUP (?)
dev	DD	01H DUP (?)
filterFlags DB	01H DUP (?)
	ALIGN	4

ch1Pan	DW	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$normalize8bitDoubleSigned DD imagerel $LN53
	DD	imagerel $LN53+113
	DD	imagerel $unwind$normalize8bitDoubleSigned
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$normalize8bitDoubleSigned DD imagerel $LN53+113
	DD	imagerel $LN53+262
	DD	imagerel $chain$0$normalize8bitDoubleSigned
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$normalize8bitDoubleSigned DD imagerel $LN53+262
	DD	imagerel $LN53+568
	DD	imagerel $chain$1$normalize8bitDoubleSigned
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$normalize8bitFloatSigned DD imagerel $LN55
	DD	imagerel $LN55+130
	DD	imagerel $unwind$normalize8bitFloatSigned
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$normalize8bitFloatSigned DD imagerel $LN55+130
	DD	imagerel $LN55+281
	DD	imagerel $chain$0$normalize8bitFloatSigned
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$normalize8bitFloatSigned DD imagerel $LN55+281
	DD	imagerel $LN55+584
	DD	imagerel $chain$1$normalize8bitFloatSigned
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$normalize16bitSigned DD imagerel $LN37
	DD	imagerel $LN37+403
	DD	imagerel $unwind$normalize16bitSigned
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$normalize32bitSigned DD imagerel $LN47
	DD	imagerel $LN47+603
	DD	imagerel $unwind$normalize32bitSigned
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$calcMod2WavTotalRows DD imagerel $LN55
	DD	imagerel $LN55+625
	DD	imagerel $unwind$calcMod2WavTotalRows
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$renderToWav DD imagerel $LN106
	DD	imagerel $LN106+135
	DD	imagerel $unwind$renderToWav
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$renderToWav DD imagerel $LN106+135
	DD	imagerel $LN106+263
	DD	imagerel $chain$0$renderToWav
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$renderToWav DD imagerel $LN106+263
	DD	imagerel $LN106+499
	DD	imagerel $chain$2$renderToWav
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$renderToWav DD imagerel $LN106+499
	DD	imagerel $LN106+609
	DD	imagerel $chain$4$renderToWav
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mod2WavThreadFunc DD imagerel mod2WavThreadFunc
	DD	imagerel mod2WavThreadFunc+92
	DD	imagerel $unwind$mod2WavThreadFunc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$mod2WavThreadFunc DD imagerel mod2WavThreadFunc+92
	DD	imagerel mod2WavThreadFunc+313
	DD	imagerel $chain$5$mod2WavThreadFunc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$mod2WavThreadFunc DD imagerel mod2WavThreadFunc+313
	DD	imagerel mod2WavThreadFunc+521
	DD	imagerel $chain$6$mod2WavThreadFunc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getAudioFrame DD imagerel $LN13
	DD	imagerel $LN13+51
	DD	imagerel $unwind$getAudioFrame
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$getAudioFrame DD imagerel $LN13+51
	DD	imagerel $LN13+126
	DD	imagerel $chain$0$getAudioFrame
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$getAudioFrame DD imagerel $LN13+126
	DD	imagerel $LN13+140
	DD	imagerel $chain$1$getAudioFrame
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$toggleAmigaPanMode DD imagerel $LN36
	DD	imagerel $LN36+179
	DD	imagerel $unwind$toggleAmigaPanMode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioClose DD imagerel $LN8
	DD	imagerel $LN8+123
	DD	imagerel $unwind$audioClose
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setupAudio DD imagerel $LN52
	DD	imagerel $LN52+437
	DD	imagerel $unwind$setupAudio
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$setupAudio DD imagerel $LN52+437
	DD	imagerel $LN52+816
	DD	imagerel $chain$0$setupAudio
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$setupAudio DD imagerel $LN52+816
	DD	imagerel $LN52+1071
	DD	imagerel $chain$1$setupAudio
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mixerCalcVoicePans DD imagerel $LN4
	DD	imagerel $LN4+123
	DD	imagerel $unwind$mixerCalcVoicePans
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioCallback DD imagerel audioCallback
	DD	imagerel audioCallback+61
	DD	imagerel $unwind$audioCallback
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$audioCallback DD imagerel audioCallback+61
	DD	imagerel audioCallback+143
	DD	imagerel $chain$0$audioCallback
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$audioCallback DD imagerel audioCallback+143
	DD	imagerel audioCallback+154
	DD	imagerel $chain$1$audioCallback
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$outputAudio DD imagerel $LN126
	DD	imagerel $LN126+32
	DD	imagerel $unwind$outputAudio
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$outputAudio DD imagerel $LN126+32
	DD	imagerel $LN126+72
	DD	imagerel $chain$0$outputAudio
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$outputAudio DD imagerel $LN126+72
	DD	imagerel $LN126+1794
	DD	imagerel $chain$1$outputAudio
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$processMixedSamplesA500 DD imagerel processMixedSamplesA500
	DD	imagerel processMixedSamplesA500+596
	DD	imagerel $unwind$processMixedSamplesA500
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$processMixedSamplesA1200 DD imagerel processMixedSamplesA1200
	DD	imagerel processMixedSamplesA1200+516
	DD	imagerel $unwind$processMixedSamplesA1200
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mixChannels DD imagerel $LN67
	DD	imagerel $LN67+842
	DD	imagerel $unwind$mixChannels
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$paulaSetData DD imagerel $LN5
	DD	imagerel $LN5+168
	DD	imagerel $unwind$paulaSetData
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$paulaSetPeriod DD imagerel $LN21
	DD	imagerel $LN21+74
	DD	imagerel $unwind$paulaSetPeriod
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$paulaSetPeriod DD imagerel $LN21+74
	DD	imagerel $LN21+345
	DD	imagerel $chain$0$paulaSetPeriod
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$paulaSetPeriod DD imagerel $LN21+345
	DD	imagerel $LN21+361
	DD	imagerel $chain$1$paulaSetPeriod
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$paulaStartDMA DD imagerel $LN7
	DD	imagerel $LN7+217
	DD	imagerel $unwind$paulaStartDMA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mixerUpdateLoops DD imagerel $LN19
	DD	imagerel $LN19+271
	DD	imagerel $unwind$mixerUpdateLoops
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$clearPaulaAndScopes DD imagerel $LN58
	DD	imagerel $LN58+370
	DD	imagerel $unwind$clearPaulaAndScopes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unlockAudio DD imagerel $LN6
	DD	imagerel $LN6+32
	DD	imagerel $unwind$unlockAudio
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lockAudio DD imagerel $LN6
	DD	imagerel $LN6+32
	DD	imagerel $unwind$lockAudio
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lossyIntegratorLED DD imagerel lossyIntegratorLED
	DD	imagerel lossyIntegratorLED+211
	DD	imagerel $unwind$lossyIntegratorLED
	ORG $+2576
?dFb@?1??calcCoeffLED@@9@9 DQ 03fc0000000000000r ; 0.125 ; `calcCoeffLED'::`2'::dFb
randSeed DD	012345000H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lossyIntegratorLED DD 033001H
	DD	06830H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lockAudio DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unlockAudio DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$clearPaulaAndScopes DD 081401H
	DD	0106414H
	DD	0f5414H
	DD	0e3414H
	DD	07010b214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mixerUpdateLoops DD 062f01H
	DD	06642fH
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$paulaStartDMA DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$paulaSetPeriod DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+74
	DD	imagerel $unwind$paulaSetPeriod
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$paulaSetPeriod DD 020421H
	DD	03404H
	DD	imagerel $LN21
	DD	imagerel $LN21+74
	DD	imagerel $unwind$paulaSetPeriod
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$paulaSetPeriod DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$paulaSetData DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mixChannels DD 0124001H
	DD	028840H
	DD	037832H
	DD	04682dH
	DD	012641cH
	DD	011541cH
	DD	010341cH
	DD	0f018921cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$processMixedSamplesA1200 DD 051801H
	DD	017818H
	DD	026813H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$processMixedSamplesA500 DD 053001H
	DD	017830H
	DD	02682bH
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$outputAudio DD 021H
	DD	imagerel $LN126
	DD	imagerel $LN126+32
	DD	imagerel $unwind$outputAudio
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$outputAudio DD 020421H
	DD	01e3404H
	DD	imagerel $LN126
	DD	imagerel $LN126+32
	DD	imagerel $unwind$outputAudio
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$outputAudio DD 0b2001H
	DD	0a9820H
	DD	0b881bH
	DD	0c7816H
	DD	0d680fH
	DD	01c010bH
	DD	07004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$audioCallback DD 021H
	DD	imagerel audioCallback
	DD	imagerel audioCallback+61
	DD	imagerel $unwind$audioCallback
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$audioCallback DD 020521H
	DD	067405H
	DD	imagerel audioCallback
	DD	imagerel audioCallback+61
	DD	imagerel $unwind$audioCallback
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioCallback DD 040a01H
	DD	07340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mixerCalcVoicePans DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$setupAudio DD 021H
	DD	imagerel $LN52
	DD	imagerel $LN52+437
	DD	imagerel $unwind$setupAudio
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$setupAudio DD 020521H
	DD	076805H
	DD	imagerel $LN52
	DD	imagerel $LN52+437
	DD	imagerel $unwind$setupAudio
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setupAudio DD 020901H
	DD	03002f209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioClose DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$toggleAmigaPanMode DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$getAudioFrame DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+51
	DD	imagerel $unwind$getAudioFrame
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$getAudioFrame DD 020521H
	DD	067405H
	DD	imagerel $LN13
	DD	imagerel $LN13+51
	DD	imagerel $unwind$getAudioFrame
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getAudioFrame DD 040a01H
	DD	07340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$mod2WavThreadFunc DD 021H
	DD	imagerel mod2WavThreadFunc
	DD	imagerel mod2WavThreadFunc+92
	DD	imagerel $unwind$mod2WavThreadFunc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$mod2WavThreadFunc DD 061821H
	DD	0127418H
	DD	0116410H
	DD	0103408H
	DD	imagerel mod2WavThreadFunc
	DD	imagerel mod2WavThreadFunc+92
	DD	imagerel $unwind$mod2WavThreadFunc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mod2WavThreadFunc DD 092d01H
	DD	0ae42dH
	DD	0bd428H
	DD	0cc423H
	DD	0f004c208H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$renderToWav DD 020021H
	DD	0e6400H
	DD	imagerel $LN106
	DD	imagerel $LN106+135
	DD	imagerel $unwind$renderToWav
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$renderToWav DD 020021H
	DD	0e6400H
	DD	imagerel $LN106
	DD	imagerel $LN106+135
	DD	imagerel $unwind$renderToWav
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$renderToWav DD 020521H
	DD	0e6405H
	DD	imagerel $LN106
	DD	imagerel $LN106+135
	DD	imagerel $unwind$renderToWav
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$renderToWav DD 040a01H
	DD	0f340aH
	DD	07006b20aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$calcMod2WavTotalRows DD 0a1401H
	DD	0e3414H
	DD	0f0103214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$normalize32bitSigned DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$normalize16bitSigned DD 041201H
	DD	027412H
	DD	01340dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$normalize8bitFloatSigned DD 021H
	DD	imagerel $LN55
	DD	imagerel $LN55+130
	DD	imagerel $unwind$normalize8bitFloatSigned
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$normalize8bitFloatSigned DD 020421H
	DD	03404H
	DD	imagerel $LN55
	DD	imagerel $LN55+130
	DD	imagerel $unwind$normalize8bitFloatSigned
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$normalize8bitFloatSigned DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$normalize8bitDoubleSigned DD 021H
	DD	imagerel $LN53
	DD	imagerel $LN53+113
	DD	imagerel $unwind$normalize8bitDoubleSigned
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$normalize8bitDoubleSigned DD 020421H
	DD	03404H
	DD	imagerel $LN53
	DD	imagerel $LN53+113
	DD	imagerel $unwind$normalize8bitDoubleSigned
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$normalize8bitDoubleSigned DD 010401H
	DD	0204H
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT fabsf
_TEXT	SEGMENT
_X$ = 8
fabsf	PROC						; COMDAT

; 672  :             return (float)fabs(_X);

  00000	0f 54 05 00 00
	00 00		 andps	 xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff

; 673  :         }

  00007	c3		 ret	 0
fabsf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\sys\stat.h
;	COMDAT stat
_TEXT	SEGMENT
_FileName$ = 8
_Stat$ = 16
stat	PROC						; COMDAT

; 241  :             _STATIC_ASSERT(sizeof(struct stat) == sizeof(struct _stat64i32));
; 242  :             return _stat64i32(_FileName, (struct _stat64i32*)_Stat);

  00000	e9 00 00 00 00	 jmp	 _stat64i32
stat	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT bpm2SmpsPerTick
_TEXT	SEGMENT
bpm$ = 8
audioFreq$ = 16
bpm2SmpsPerTick PROC					; COMDAT

; 82   : {

  00000	44 8b c2	 mov	 r8d, edx

; 83   : 	uint32_t ciaVal;
; 84   : 	double dFreqMul;
; 85   : 
; 86   : 	if (bpm == 0)

  00003	85 c9		 test	 ecx, ecx
  00005	75 03		 jne	 SHORT $LN2@bpm2SmpsPe

; 87   : 		return 0;

  00007	33 c0		 xor	 eax, eax

; 93   : }

  00009	c3		 ret	 0
$LN2@bpm2SmpsPe:
  0000a	0f 57 c9	 xorps	 xmm1, xmm1

; 88   : 
; 89   : 	ciaVal = (uint32_t)(1773447 / bpm); // yes, PT truncates here

  0000d	33 d2		 xor	 edx, edx
  0000f	b8 87 0f 1b 00	 mov	 eax, 1773447		; 001b0f87H
  00014	0f 57 c0	 xorps	 xmm0, xmm0
  00017	f7 f1		 div	 ecx

; 90   : 	dFreqMul = ciaVal * (1.0 / CIA_PAL_CLK);
; 91   : 
; 92   : 	return (uint16_t)((audioFreq * dFreqMul) + 0.5);

  00019	f2 49 0f 2a c0	 cvtsi2sd xmm0, r8
  0001e	8b c8		 mov	 ecx, eax
  00020	f2 48 0f 2a c9	 cvtsi2sd xmm1, rcx
  00025	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3eb7a68b994d1178
  0002d	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00031	f2 0f 58 0d 00
	00 00 00	 addsd	 xmm1, QWORD PTR __real@3fe0000000000000
  00039	f2 0f 2c c1	 cvttsd2si eax, xmm1

; 93   : }

  0003d	c3		 ret	 0
bpm2SmpsPerTick ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT generateBpmTables
_TEXT	SEGMENT
generateBpmTables PROC					; COMDAT

; 97   : 	for (uint32_t i = 32; i <= 255; i++)

  00000	f2 0f 10 2d 00
	00 00 00	 movsd	 xmm5, QWORD PTR __real@3eb7a68b994d1178
  00008	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:audio
  0000f	f2 0f 10 15 00
	00 00 00	 movsd	 xmm2, QWORD PTR __real@3fe0000000000000
  00017	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  0001d	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@3fa4d00788ffda07
  00025	45 33 d2	 xor	 r10d, r10d
  00028	f2 0f 10 25 00
	00 00 00	 movsd	 xmm4, QWORD PTR __real@3f9ffff7218ba683
$LL17@generateBp:

; 86   : 	if (bpm == 0)

  00030	45 85 c0	 test	 r8d, r8d
  00033	75 06		 jne	 SHORT $LN18@generateBp

; 87   : 		return 0;

  00035	41 0f b7 ca	 movzx	 ecx, r10w
  00039	eb 32		 jmp	 SHORT $LN19@generateBp
$LN18@generateBp:
  0003b	0f 57 c9	 xorps	 xmm1, xmm1

; 88   : 
; 89   : 	ciaVal = (uint32_t)(1773447 / bpm); // yes, PT truncates here

  0003e	b8 87 0f 1b 00	 mov	 eax, 1773447		; 001b0f87H
  00043	33 d2		 xor	 edx, edx
  00045	0f 57 c0	 xorps	 xmm0, xmm0
  00048	41 f7 f0	 div	 r8d
  0004b	8b c8		 mov	 ecx, eax

; 91   : 
; 92   : 	return (uint16_t)((audioFreq * dFreqMul) + 0.5);

  0004d	8b 05 40 05 00
	00		 mov	 eax, DWORD PTR audio+1344
  00053	f2 48 0f 2a c9	 cvtsi2sd xmm1, rcx
  00058	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  0005d	f2 0f 59 cd	 mulsd	 xmm1, xmm5
  00061	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00065	f2 0f 58 ca	 addsd	 xmm1, xmm2
  00069	f2 0f 2c c9	 cvttsd2si ecx, xmm1
$LN19@generateBp:

; 98   : 	{
; 99   : 		audio.bpmTab[i-32] = bpm2SmpsPerTick(i, audio.audioFreq);

  0006d	41 8d 40 e0	 lea	 eax, DWORD PTR [r8-32]
  00071	44 8b c8	 mov	 r9d, eax
  00074	66 41 89 0c 43	 mov	 WORD PTR [r11+rax*2], cx

; 86   : 	if (bpm == 0)

  00079	45 85 c0	 test	 r8d, r8d
  0007c	75 06		 jne	 SHORT $LN20@generateBp

; 87   : 		return 0;

  0007e	41 0f b7 c2	 movzx	 eax, r10w
  00082	eb 20		 jmp	 SHORT $LN21@generateBp
$LN20@generateBp:
  00084	0f 57 c0	 xorps	 xmm0, xmm0

; 88   : 
; 89   : 	ciaVal = (uint32_t)(1773447 / bpm); // yes, PT truncates here

  00087	33 d2		 xor	 edx, edx
  00089	b8 87 0f 1b 00	 mov	 eax, 1773447		; 001b0f87H
  0008e	41 f7 f0	 div	 r8d
  00091	8b c8		 mov	 ecx, eax

; 90   : 	dFreqMul = ciaVal * (1.0 / CIA_PAL_CLK);

  00093	f2 48 0f 2a c1	 cvtsi2sd xmm0, rcx

; 91   : 
; 92   : 	return (uint16_t)((audioFreq * dFreqMul) + 0.5);

  00098	f2 0f 59 c3	 mulsd	 xmm0, xmm3
  0009c	f2 0f 58 c2	 addsd	 xmm0, xmm2
  000a0	f2 0f 2c c0	 cvttsd2si eax, xmm0
$LN21@generateBp:

; 100  : 		audio.bpmTab28kHz[i-32] = bpm2SmpsPerTick(i, 28836);

  000a4	66 43 89 84 4b
	c0 01 00 00	 mov	 WORD PTR [r11+r9*2+448], ax

; 86   : 	if (bpm == 0)

  000ad	45 85 c0	 test	 r8d, r8d
  000b0	75 06		 jne	 SHORT $LN22@generateBp

; 87   : 		return 0;

  000b2	41 0f b7 c2	 movzx	 eax, r10w
  000b6	eb 20		 jmp	 SHORT $LN23@generateBp
$LN22@generateBp:
  000b8	0f 57 c0	 xorps	 xmm0, xmm0

; 88   : 
; 89   : 	ciaVal = (uint32_t)(1773447 / bpm); // yes, PT truncates here

  000bb	33 d2		 xor	 edx, edx
  000bd	b8 87 0f 1b 00	 mov	 eax, 1773447		; 001b0f87H
  000c2	41 f7 f0	 div	 r8d
  000c5	8b c8		 mov	 ecx, eax

; 90   : 	dFreqMul = ciaVal * (1.0 / CIA_PAL_CLK);

  000c7	f2 48 0f 2a c1	 cvtsi2sd xmm0, rcx

; 91   : 
; 92   : 	return (uint16_t)((audioFreq * dFreqMul) + 0.5);

  000cc	f2 0f 59 c4	 mulsd	 xmm0, xmm4
  000d0	f2 0f 58 c2	 addsd	 xmm0, xmm2
  000d4	f2 0f 2c c0	 cvttsd2si eax, xmm0
$LN23@generateBp:

; 97   : 	for (uint32_t i = 32; i <= 255; i++)

  000d8	41 ff c0	 inc	 r8d

; 101  : 		audio.bpmTab22kHz[i-32] = bpm2SmpsPerTick(i, 22168);

  000db	66 43 89 84 4b
	80 03 00 00	 mov	 WORD PTR [r11+r9*2+896], ax
  000e4	41 81 f8 ff 00
	00 00		 cmp	 r8d, 255		; 000000ffH
  000eb	0f 86 3f ff ff
	ff		 jbe	 $LL17@generateBp

; 102  : 	}
; 103  : }

  000f1	c3		 ret	 0
generateBpmTables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT setLEDFilter
_TEXT	SEGMENT
state$ = 8
setLEDFilter PROC					; COMDAT

; 107  : 	editor.useLEDFilter = state;
; 108  : 
; 109  : 	if (editor.useLEDFilter)

  00000	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR filterFlags
  00007	88 0d 13 01 00
	00		 mov	 BYTE PTR editor+275, cl
  0000d	84 c9		 test	 cl, cl
  0000f	74 09		 je	 SHORT $LN2@setLEDFilt

; 110  : 		filterFlags |=  FILTER_LED_ENABLED;

  00011	0c 02		 or	 al, 2

; 113  : }

  00013	88 05 00 00 00
	00		 mov	 BYTE PTR filterFlags, al
  00019	c3		 ret	 0
$LN2@setLEDFilt:

; 111  : 	else
; 112  : 		filterFlags &= ~FILTER_LED_ENABLED;

  0001a	24 fd		 and	 al, -3

; 113  : }

  0001c	88 05 00 00 00
	00		 mov	 BYTE PTR filterFlags, al
  00022	c3		 ret	 0
setLEDFilter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT toggleLEDFilter
_TEXT	SEGMENT
toggleLEDFilter PROC					; COMDAT

; 117  : 	editor.useLEDFilter ^= 1;

  00000	0f b6 05 13 01
	00 00		 movzx	 eax, BYTE PTR editor+275
  00007	34 01		 xor	 al, 1
  00009	0f 95 05 13 01
	00 00		 setne	 BYTE PTR editor+275
  00010	84 c0		 test	 al, al

; 118  : 
; 119  : 	if (editor.useLEDFilter)

  00012	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR filterFlags
  00019	74 09		 je	 SHORT $LN2@toggleLEDF

; 120  : 		filterFlags |=  FILTER_LED_ENABLED;

  0001b	0c 02		 or	 al, 2

; 123  : }

  0001d	88 05 00 00 00
	00		 mov	 BYTE PTR filterFlags, al
  00023	c3		 ret	 0
$LN2@toggleLEDF:

; 121  : 	else
; 122  : 		filterFlags &= ~FILTER_LED_ENABLED;

  00024	24 fd		 and	 al, -3

; 123  : }

  00026	88 05 00 00 00
	00		 mov	 BYTE PTR filterFlags, al
  0002c	c3		 ret	 0
toggleLEDFilter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT calcCoeffLED
_TEXT	SEGMENT
dSr$ = 8
dHz$ = 16
filter$dead$ = 24
calcCoeffLED PROC					; COMDAT

; 127  : 	static double dFb = 0.125;
; 128  : 
; 129  : #ifndef NO_FILTER_FINETUNING
; 130  : 	/* 8bitbubsy: makes the filter curve sound (and look) much closer to the real deal.
; 131  : 	** This has been tested against both an A500 and A1200 (real units). */
; 132  : 	dFb *= 0.62;

  00000	f2 0f 10 25 00
	00 00 00	 movsd	 xmm4, QWORD PTR ?dFb@?1??calcCoeffLED@@9@9

; 133  : #endif
; 134  : 
; 135  : 	if (dHz < dSr/2.0)

  00008	0f 28 d0	 movaps	 xmm2, xmm0
  0000b	f2 0f 59 15 00
	00 00 00	 mulsd	 xmm2, QWORD PTR __real@3fe0000000000000
  00013	f2 0f 59 25 00
	00 00 00	 mulsd	 xmm4, QWORD PTR __real@3fe3d70a3d70a3d7
  0001b	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@3ff0000000000000
  00023	66 0f 2f ca	 comisd	 xmm1, xmm2
  00027	f2 0f 11 25 00
	00 00 00	 movsd	 QWORD PTR ?dFb@?1??calcCoeffLED@@9@9, xmm4
  0002f	73 16		 jae	 SHORT $LN2@calcCoeffL

; 136  : 		filter->dLed = ((2.0 * M_PI) * dHz) / dSr;

  00031	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@401921fb54442d18
  00039	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0003d	f2 0f 11 0d 00
	00 00 00	 movsd	 QWORD PTR filterLEDC, xmm1
  00045	eb 0b		 jmp	 SHORT $LN3@calcCoeffL
$LN2@calcCoeffL:

; 137  : 	else
; 138  : 		filter->dLed = 1.0;

  00047	f2 0f 11 1d 00
	00 00 00	 movsd	 QWORD PTR filterLEDC, xmm3
  0004f	0f 28 cb	 movaps	 xmm1, xmm3
$LN3@calcCoeffL:

; 139  : 
; 140  : 	filter->dLedFb = dFb + (dFb / (1.0 - filter->dLed)); // Q ~= 1/sqrt(2) (Butterworth)

  00052	f2 0f 5c d9	 subsd	 xmm3, xmm1
  00056	0f 28 c4	 movaps	 xmm0, xmm4
  00059	f2 0f 5e c3	 divsd	 xmm0, xmm3
  0005d	f2 0f 58 c4	 addsd	 xmm0, xmm4
  00061	f2 0f 11 05 08
	00 00 00	 movsd	 QWORD PTR filterLEDC+8, xmm0

; 141  : }

  00069	c3		 ret	 0
calcCoeffLED ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT calcCoeffLossyIntegrator
_TEXT	SEGMENT
dSr$ = 8
dHz$ = 16
filter$ = 24
calcCoeffLossyIntegrator PROC				; COMDAT

; 145  : 	double dOmega = ((2.0 * M_PI) * dHz) / dSr;
; 146  : 	filter->b0 = 1.0 / (1.0 + (1.0 / dOmega));

  00000	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@3ff0000000000000
  00008	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@401921fb54442d18
  00010	0f 28 d3	 movaps	 xmm2, xmm3
  00013	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00017	0f 28 c3	 movaps	 xmm0, xmm3
  0001a	f2 0f 5e d1	 divsd	 xmm2, xmm1
  0001e	f2 0f 58 d3	 addsd	 xmm2, xmm3
  00022	f2 0f 5e c2	 divsd	 xmm0, xmm2

; 147  : 	filter->b1 = 1.0 - filter->b0;

  00026	f2 0f 5c d8	 subsd	 xmm3, xmm0
  0002a	f2 41 0f 11 40
	10		 movsd	 QWORD PTR [r8+16], xmm0
  00030	f2 41 0f 11 58
	18		 movsd	 QWORD PTR [r8+24], xmm3

; 148  : }

  00036	c3		 ret	 0
calcCoeffLossyIntegrator ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT clearLossyIntegrator
_TEXT	SEGMENT
filter$ = 8
clearLossyIntegrator PROC				; COMDAT

; 152  : 	filter->dBuffer[0] = 0.0; // L

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 153  : 	filter->dBuffer[1] = 0.0; // R
; 154  : }

  00009	c3		 ret	 0
clearLossyIntegrator ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT clearLEDFilter
_TEXT	SEGMENT
filter$dead$ = 8
clearLEDFilter PROC					; COMDAT

; 157  : {

  00000	0f 57 c0	 xorps	 xmm0, xmm0
  00003	0f 57 c9	 xorps	 xmm1, xmm1

; 158  : 	filter->dLed[0] = 0.0; // L

  00006	0f 11 05 00 00
	00 00		 movups	 XMMWORD PTR filterLED, xmm0
  0000d	0f 11 0d 10 00
	00 00		 movups	 XMMWORD PTR filterLED+16, xmm1

; 159  : 	filter->dLed[1] = 0.0;
; 160  : 	filter->dLed[2] = 0.0; // R
; 161  : 	filter->dLed[3] = 0.0;
; 162  : }

  00014	c3		 ret	 0
clearLEDFilter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT lossyIntegratorLED
_TEXT	SEGMENT
filterC$ = 32
filter$dead$ = 40
dIn$ = 48
dOut$ = 56
lossyIntegratorLED PROC					; COMDAT

; 165  : {

  00000	48 83 ec 18	 sub	 rsp, 24

; 166  : 	// left channel "LED" filter
; 167  : 	filter->dLed[0] += filterC.dLed * (dIn[0] - filter->dLed[0])

  00004	f2 41 0f 10 08	 movsd	 xmm1, QWORD PTR [r8]
  00009	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR filterLED
  00011	f2 0f 10 15 08
	00 00 00	 movsd	 xmm2, QWORD PTR filterLED+8
  00019	f2 0f 5c cb	 subsd	 xmm1, xmm3
  0001d	f2 0f 10 25 00
	00 00 00	 movsd	 xmm4, QWORD PTR __real@3ddb7cdfd9d7bdbb
  00025	0f 28 c3	 movaps	 xmm0, xmm3
  00028	f2 0f 5c c2	 subsd	 xmm0, xmm2
  0002c	0f 29 34 24	 movaps	 XMMWORD PTR [rsp], xmm6
  00030	f2 0f 10 31	 movsd	 xmm6, QWORD PTR [rcx]
  00034	f2 0f 59 ce	 mulsd	 xmm1, xmm6
  00038	f2 0f 59 41 08	 mulsd	 xmm0, QWORD PTR [rcx+8]
  0003d	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00041	f2 0f 58 cc	 addsd	 xmm1, xmm4
  00045	f2 0f 58 d9	 addsd	 xmm3, xmm1
  00049	f2 0f 11 1d 00
	00 00 00	 movsd	 QWORD PTR filterLED, xmm3

; 168  : 		+ filterC.dLedFb * (filter->dLed[0] - filter->dLed[1]) + DENORMAL_OFFSET;
; 169  : 	filter->dLed[1] += filterC.dLed * (filter->dLed[0] - filter->dLed[1]) + DENORMAL_OFFSET;

  00051	f2 0f 5c da	 subsd	 xmm3, xmm2
  00055	f2 0f 59 de	 mulsd	 xmm3, xmm6
  00059	f2 0f 58 dc	 addsd	 xmm3, xmm4
  0005d	f2 0f 58 d3	 addsd	 xmm2, xmm3
  00061	f2 0f 11 15 08
	00 00 00	 movsd	 QWORD PTR filterLED+8, xmm2

; 170  : 	dOut[0] = filter->dLed[1];

  00069	f2 41 0f 11 11	 movsd	 QWORD PTR [r9], xmm2

; 171  : 
; 172  : 	// right channel "LED" filter
; 173  : 	filter->dLed[2] += filterC.dLed * (dIn[1] - filter->dLed[2])

  0006e	f2 0f 10 1d 10
	00 00 00	 movsd	 xmm3, QWORD PTR filterLED+16
  00076	f2 0f 10 15 18
	00 00 00	 movsd	 xmm2, QWORD PTR filterLED+24
  0007e	0f 28 c3	 movaps	 xmm0, xmm3
  00081	f2 41 0f 10 48
	08		 movsd	 xmm1, QWORD PTR [r8+8]
  00087	f2 0f 5c c2	 subsd	 xmm0, xmm2
  0008b	f2 0f 5c cb	 subsd	 xmm1, xmm3
  0008f	f2 0f 59 41 08	 mulsd	 xmm0, QWORD PTR [rcx+8]
  00094	f2 0f 59 ce	 mulsd	 xmm1, xmm6
  00098	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0009c	f2 0f 58 cc	 addsd	 xmm1, xmm4
  000a0	f2 0f 58 d9	 addsd	 xmm3, xmm1
  000a4	f2 0f 11 1d 10
	00 00 00	 movsd	 QWORD PTR filterLED+16, xmm3

; 174  : 		+ filterC.dLedFb * (filter->dLed[2] - filter->dLed[3]) + DENORMAL_OFFSET;
; 175  : 	filter->dLed[3] += filterC.dLed * (filter->dLed[2] - filter->dLed[3]) + DENORMAL_OFFSET;

  000ac	f2 0f 5c da	 subsd	 xmm3, xmm2
  000b0	f2 0f 59 de	 mulsd	 xmm3, xmm6

; 176  : 	dOut[1] = filter->dLed[3];
; 177  : }

  000b4	0f 28 34 24	 movaps	 xmm6, XMMWORD PTR [rsp]
  000b8	f2 0f 58 dc	 addsd	 xmm3, xmm4
  000bc	f2 0f 58 d3	 addsd	 xmm2, xmm3
  000c0	f2 0f 11 15 18
	00 00 00	 movsd	 QWORD PTR filterLED+24, xmm2
  000c8	f2 41 0f 11 51
	08		 movsd	 QWORD PTR [r9+8], xmm2
  000ce	48 83 c4 18	 add	 rsp, 24
  000d2	c3		 ret	 0
lossyIntegratorLED ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT lossyIntegrator
_TEXT	SEGMENT
filter$ = 8
dIn$ = 16
dOut$ = 24
lossyIntegrator PROC					; COMDAT

; 181  : 	/* Low-pass filter implementation taken from:
; 182  : 	** https://bel.fi/alankila/modguide/interpolate.txt
; 183  : 	**
; 184  : 	** This implementation has a less smooth cutoff curve compared to the old one, so it's
; 185  : 	** maybe not the best. However, I stick to this one because it has a higher gain
; 186  : 	** at the end of the curve (closer to real tested Amiga 500). It also sounds much closer when
; 187  : 	** comparing whitenoise on an A500. */
; 188  : 
; 189  : 	// left channel low-pass
; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  00000	f2 0f 10 09	 movsd	 xmm1, QWORD PTR [rcx]
  00004	f2 0f 59 49 18	 mulsd	 xmm1, QWORD PTR [rcx+24]
  00009	f2 0f 10 41 10	 movsd	 xmm0, QWORD PTR [rcx+16]
  0000e	f2 0f 59 02	 mulsd	 xmm0, QWORD PTR [rdx]
  00012	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00016	f2 0f 58 0d 00
	00 00 00	 addsd	 xmm1, QWORD PTR __real@3ddb7cdfd9d7bdbb
  0001e	f2 0f 11 09	 movsd	 QWORD PTR [rcx], xmm1

; 191  : 	dOut[0] = filter->dBuffer[0];

  00022	f2 41 0f 11 08	 movsd	 QWORD PTR [r8], xmm1

; 192  : 
; 193  : 	// right channel low-pass
; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  00027	f2 0f 10 4a 08	 movsd	 xmm1, QWORD PTR [rdx+8]
  0002c	f2 0f 10 41 08	 movsd	 xmm0, QWORD PTR [rcx+8]
  00031	f2 0f 59 49 10	 mulsd	 xmm1, QWORD PTR [rcx+16]
  00036	f2 0f 59 41 18	 mulsd	 xmm0, QWORD PTR [rcx+24]
  0003b	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0003f	f2 0f 58 0d 00
	00 00 00	 addsd	 xmm1, QWORD PTR __real@3ddb7cdfd9d7bdbb
  00047	f2 0f 11 49 08	 movsd	 QWORD PTR [rcx+8], xmm1

; 195  : 	dOut[1] = filter->dBuffer[1];

  0004c	f2 41 0f 11 48
	08		 movsd	 QWORD PTR [r8+8], xmm1

; 196  : }

  00052	c3		 ret	 0
lossyIntegrator ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT lossyIntegratorHighPass
_TEXT	SEGMENT
filter$ = 8
dIn$ = 16
dOut$ = 24
lossyIntegratorHighPass PROC				; COMDAT

; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  00000	f2 0f 10 51 18	 movsd	 xmm2, QWORD PTR [rcx+24]
  00005	f2 0f 10 61 10	 movsd	 xmm4, QWORD PTR [rcx+16]
  0000a	0f 28 da	 movaps	 xmm3, xmm2
  0000d	f2 0f 59 19	 mulsd	 xmm3, QWORD PTR [rcx]
  00011	0f 28 c4	 movaps	 xmm0, xmm4
  00014	f2 0f 59 02	 mulsd	 xmm0, QWORD PTR [rdx]

; 191  : 	dOut[0] = filter->dBuffer[0];
; 192  : 
; 193  : 	// right channel low-pass
; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  00018	f2 0f 59 51 08	 mulsd	 xmm2, QWORD PTR [rcx+8]
  0001d	f2 0f 58 d8	 addsd	 xmm3, xmm0
  00021	f2 0f 58 1d 00
	00 00 00	 addsd	 xmm3, QWORD PTR __real@3ddb7cdfd9d7bdbb
  00029	f2 0f 11 19	 movsd	 QWORD PTR [rcx], xmm3
  0002d	f2 0f 59 62 08	 mulsd	 xmm4, QWORD PTR [rdx+8]
  00032	f2 0f 58 e2	 addsd	 xmm4, xmm2
  00036	f2 0f 58 25 00
	00 00 00	 addsd	 xmm4, QWORD PTR __real@3ddb7cdfd9d7bdbb
  0003e	f2 0f 11 61 08	 movsd	 QWORD PTR [rcx+8], xmm4

; 200  : 	double dLow[2];
; 201  : 
; 202  : 	lossyIntegrator(filter, dIn, dLow);
; 203  : 
; 204  : 	dOut[0] = dIn[0] - dLow[0]; // left channel high-pass

  00043	f2 0f 10 02	 movsd	 xmm0, QWORD PTR [rdx]
  00047	f2 0f 5c c3	 subsd	 xmm0, xmm3
  0004b	f2 41 0f 11 00	 movsd	 QWORD PTR [r8], xmm0
  00050	f2 0f 10 4a 08	 movsd	 xmm1, QWORD PTR [rdx+8]
  00055	f2 0f 5c cc	 subsd	 xmm1, xmm4
  00059	f2 41 0f 11 48
	08		 movsd	 QWORD PTR [r8+8], xmm1

; 205  : 	dOut[1] = dIn[1] - dLow[1]; // right channel high-pass
; 206  : }

  0005f	c3		 ret	 0
lossyIntegratorHighPass ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT sinApx
_TEXT	SEGMENT
fX$ = 8
sinApx	PROC						; COMDAT

; 215  : 	fX = fX * (2.0 - fX);

  00000	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4000000000000000
  00008	0f 28 d0	 movaps	 xmm2, xmm0
  0000b	f2 0f 5c c8	 subsd	 xmm1, xmm0
  0000f	f2 0f 59 d1	 mulsd	 xmm2, xmm1

; 216  : 	return fX * 1.09742972 + fX * fX * 0.31678383;

  00013	0f 28 c2	 movaps	 xmm0, xmm2
  00016	f2 0f 59 c2	 mulsd	 xmm0, xmm2
  0001a	f2 0f 59 15 00
	00 00 00	 mulsd	 xmm2, QWORD PTR __real@3ff18f127750ef5c
  00022	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fd4462faf701a9a
  0002a	f2 0f 58 c2	 addsd	 xmm0, xmm2

; 217  : }

  0002e	c3		 ret	 0
sinApx	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT cosApx
_TEXT	SEGMENT
fX$ = 8
cosApx	PROC						; COMDAT

; 221  : 	fX = (1.0 - fX) * (1.0 + fX);

  00000	f2 0f 10 15 00
	00 00 00	 movsd	 xmm2, QWORD PTR __real@3ff0000000000000
  00008	f2 0f 5c d0	 subsd	 xmm2, xmm0
  0000c	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00014	f2 0f 59 d0	 mulsd	 xmm2, xmm0

; 222  : 	return fX * 1.09742972 + fX * fX * 0.31678383;

  00018	0f 28 c2	 movaps	 xmm0, xmm2
  0001b	f2 0f 59 c2	 mulsd	 xmm0, xmm2
  0001f	f2 0f 59 15 00
	00 00 00	 mulsd	 xmm2, QWORD PTR __real@3ff18f127750ef5c
  00027	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fd4462faf701a9a
  0002f	f2 0f 58 c2	 addsd	 xmm0, xmm2

; 223  : }

  00033	c3		 ret	 0
cosApx	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT lockAudio
_TEXT	SEGMENT
lockAudio PROC						; COMDAT

; 226  : {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 227  : 	if (dev != 0)

  00004	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR dev
  0000a	85 c9		 test	 ecx, ecx
  0000c	74 06		 je	 SHORT $LN4@lockAudio

; 228  : 		SDL_LockAudioDevice(dev);

  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SDL_LockAudioDevice
$LN4@lockAudio:

; 229  : 
; 230  : 	audioLocked = true;
; 231  : }

  00014	c6 05 00 00 00
	00 01		 mov	 BYTE PTR audioLocked, 1
  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
lockAudio ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT unlockAudio
_TEXT	SEGMENT
unlockAudio PROC					; COMDAT

; 234  : {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 235  : 	if (dev != 0)

  00004	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR dev
  0000a	85 c9		 test	 ecx, ecx
  0000c	74 06		 je	 SHORT $LN4@unlockAudi

; 236  : 		SDL_UnlockAudioDevice(dev);

  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SDL_UnlockAudioDevice
$LN4@unlockAudi:

; 237  : 
; 238  : 	audioLocked = false;
; 239  : }

  00014	c6 05 00 00 00
	00 00		 mov	 BYTE PTR audioLocked, 0
  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
unlockAudio ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_scopes.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT clearPaulaAndScopes
_TEXT	SEGMENT
dOldPanL$ = 32
dOldPanR$ = 64
clearPaulaAndScopes PROC				; COMDAT

; 242  : {

$LN58:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 243  : 	uint8_t i;
; 244  : 	double dOldPanL[4], dOldPanR[4];
; 245  : 
; 246  : 	// copy old pans
; 247  : 	for (i = 0; i < AMIGA_VOICES; i++)

  00014	48 8d 1d 68 00
	00 00		 lea	 rbx, OFFSET FLAT:paula+104
  0001b	33 ff		 xor	 edi, edi
  0001d	be 04 00 00 00	 mov	 esi, 4
  00022	48 8b cb	 mov	 rcx, rbx
  00025	8b d7		 mov	 edx, edi
  00027	44 8b c6	 mov	 r8d, esi
  0002a	66 0f 1f 44 00
	00		 npad	 6
$LL4@clearPaula:

; 248  : 	{
; 249  : 		dOldPanL[i] = paula[i].dPanL;

  00030	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]
  00034	48 8d 49 70	 lea	 rcx, QWORD PTR [rcx+112]
  00038	48 89 44 14 20	 mov	 QWORD PTR dOldPanL$[rsp+rdx], rax
  0003d	48 8d 52 08	 lea	 rdx, QWORD PTR [rdx+8]

; 250  : 		dOldPanR[i] = paula[i].dPanR;

  00041	48 8b 41 90	 mov	 rax, QWORD PTR [rcx-112]
  00045	48 89 44 14 38	 mov	 QWORD PTR dOldPanR$[rsp+rdx-8], rax
  0004a	49 83 e8 01	 sub	 r8, 1
  0004e	75 e0		 jne	 SHORT $LL4@clearPaula

; 227  : 	if (dev != 0)

  00050	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR dev
  00056	85 ed		 test	 ebp, ebp
  00058	74 0e		 je	 SHORT $LN10@clearPaula

; 228  : 		SDL_LockAudioDevice(dev);

  0005a	8b cd		 mov	 ecx, ebp
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SDL_LockAudioDevice
  00062	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR dev
$LN10@clearPaula:

; 251  : 	}
; 252  : 
; 253  : 	lockAudio();
; 254  : 	memset(paula, 0, sizeof (paula));

  00068	33 d2		 xor	 edx, edx

; 230  : 	audioLocked = true;

  0006a	c6 05 00 00 00
	00 01		 mov	 BYTE PTR audioLocked, 1

; 251  : 	}
; 252  : 
; 253  : 	lockAudio();
; 254  : 	memset(paula, 0, sizeof (paula));

  00071	41 b8 c0 01 00
	00		 mov	 r8d, 448		; 000001c0H
  00077	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:paula
  0007e	e8 00 00 00 00	 call	 memset

; 235  : 	if (dev != 0)

  00083	85 ed		 test	 ebp, ebp
  00085	74 08		 je	 SHORT $LN13@clearPaula

; 236  : 		SDL_UnlockAudioDevice(dev);

  00087	8b cd		 mov	 ecx, ebp
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SDL_UnlockAudioDevice
$LN13@clearPaula:

; 237  : 
; 238  : 	audioLocked = false;

  0008f	40 88 3d 00 00
	00 00		 mov	 BYTE PTR audioLocked, dil
  00096	48 8b ce	 mov	 rcx, rsi
  00099	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@clearPaula:

; 255  : 	unlockAudio();
; 256  : 
; 257  : 	// store old pans
; 258  : 	for (i = 0; i < AMIGA_VOICES; i++)
; 259  : 	{
; 260  : 		paula[i].dPanL = dOldPanL[i];

  000a0	48 8b 44 3c 20	 mov	 rax, QWORD PTR dOldPanL$[rsp+rdi]
  000a5	48 8d 7f 08	 lea	 rdi, QWORD PTR [rdi+8]
  000a9	48 89 43 f8	 mov	 QWORD PTR [rbx-8], rax
  000ad	48 8d 5b 70	 lea	 rbx, QWORD PTR [rbx+112]

; 261  : 		paula[i].dPanR = dOldPanR[i];

  000b1	48 8b 44 3c 38	 mov	 rax, QWORD PTR dOldPanR$[rsp+rdi-8]
  000b6	48 89 43 90	 mov	 QWORD PTR [rbx-112], rax
  000ba	48 83 e9 01	 sub	 rcx, 1
  000be	75 e0		 jne	 SHORT $LL7@clearPaula
$LL21@clearPaula:
; File C:\Programming\pt2-clone\src\pt2_scopes.c

; 407  : 	while (scopesReading);

  000c0	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR scopesReading
  000c7	84 c0		 test	 al, al
  000c9	75 f5		 jne	 SHORT $LL21@clearPaula
  000cb	0f 57 c0	 xorps	 xmm0, xmm0

; 414  : 	memset(scope, 0, sizeof (scope));

  000ce	48 8d 05 0c 00
	00 00		 lea	 rax, OFFSET FLAT:scope+12
  000d5	0f 11 05 00 00
	00 00		 movups	 XMMWORD PTR scope, xmm0
  000dc	48 8d 0d 0c 00
	00 00		 lea	 rcx, OFFSET FLAT:scopeExt+12
  000e3	0f 11 05 10 00
	00 00		 movups	 XMMWORD PTR scope+16, xmm0
  000ea	0f 11 05 20 00
	00 00		 movups	 XMMWORD PTR scope+32, xmm0
  000f1	0f 11 05 30 00
	00 00		 movups	 XMMWORD PTR scope+48, xmm0
  000f8	0f 11 05 40 00
	00 00		 movups	 XMMWORD PTR scope+64, xmm0
  000ff	0f 11 05 50 00
	00 00		 movups	 XMMWORD PTR scope+80, xmm0
  00106	0f 11 05 60 00
	00 00		 movups	 XMMWORD PTR scope+96, xmm0
  0010d	0f 11 05 70 00
	00 00		 movups	 XMMWORD PTR scope+112, xmm0

; 415  : 	memset(scopeExt, 0, sizeof (scopeExt));

  00114	0f 11 05 00 00
	00 00		 movups	 XMMWORD PTR scopeExt, xmm0
  0011b	0f 11 05 10 00
	00 00		 movups	 XMMWORD PTR scopeExt+16, xmm0
  00122	0f 11 05 20 00
	00 00		 movups	 XMMWORD PTR scopeExt+32, xmm0
  00129	0f 11 05 30 00
	00 00		 movups	 XMMWORD PTR scopeExt+48, xmm0
  00130	0f 11 05 40 00
	00 00		 movups	 XMMWORD PTR scopeExt+64, xmm0
  00137	0f 11 05 50 00
	00 00		 movups	 XMMWORD PTR scopeExt+80, xmm0
  0013e	66 90		 npad	 2
$LL18@clearPaula:

; 416  : 
; 417  : 	for (uint8_t i = 0; i < AMIGA_VOICES; i++)
; 418  : 		scope[i].length = scopeExt[i].newLength = 2;

  00140	c7 01 02 00 00
	00		 mov	 DWORD PTR [rcx], 2
  00146	48 8d 49 18	 lea	 rcx, QWORD PTR [rcx+24]
  0014a	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2
  00150	48 8d 40 20	 lea	 rax, QWORD PTR [rax+32]
  00154	48 83 ee 01	 sub	 rsi, 1
  00158	75 e6		 jne	 SHORT $LL18@clearPaula
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 265  : }

  0015a	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0015f	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  00164	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR [rsp+128]
  0016c	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00170	5f		 pop	 rdi
  00171	c3		 ret	 0
clearPaulaAndScopes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT mixerUpdateLoops
_TEXT	SEGMENT
tmp$1 = 0
mixerUpdateLoops PROC					; COMDAT

; 268  : {

$LN19:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 269  : 	moduleChannel_t *ch;
; 270  : 	moduleSample_t *s;
; 271  : 
; 272  : 	for (uint8_t i = 0; i < AMIGA_VOICES; i++)

  0000a	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR modEntry
  00011	4c 8d 15 1c 00
	00 00		 lea	 r10, OFFSET FLAT:paula+28
  00018	48 0f be 3d 70
	22 00 00	 movsx	 rdi, BYTE PTR editor+8816
  00020	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:scopeExt
  00027	45 33 c9	 xor	 r9d, r9d
  0002a	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0002f	41 8d 59 04	 lea	 ebx, QWORD PTR [r9+4]
$LL4@mixerUpdat:

; 273  : 	{
; 274  : 		ch = &modEntry->channels[i];
; 275  : 		if (ch->n_samplenum == editor.currSample)

  00033	43 0f b6 8c 19
	27 0b 00 00	 movzx	 ecx, BYTE PTR [r9+r11+2855]
  0003c	3b cf		 cmp	 ecx, edi
  0003e	0f 85 a5 00 00
	00		 jne	 $LN2@mixerUpdat

; 483  : 	s = &modEntry->samples[smp];

  00044	43 0f b6 8c 19
	27 0b 00 00	 movzx	 ecx, BYTE PTR [r9+r11+2855]

; 276  : 		{
; 277  : 			s = &modEntry->samples[editor.currSample];

  0004d	48 8d 34 bf	 lea	 rsi, QWORD PTR [rdi+rdi*4]
  00051	48 03 f6	 add	 rsi, rsi

; 483  : 	s = &modEntry->samples[smp];

  00054	48 8d 14 89	 lea	 rdx, QWORD PTR [rcx+rcx*4]

; 278  : 			paulaSetData(i, ch->n_start + s->loopStart);

  00058	41 0f b7 84 f3
	8c 01 00 00	 movzx	 eax, WORD PTR [r11+rsi*8+396]

; 483  : 	s = &modEntry->samples[smp];

  00061	48 03 d2	 add	 rdx, rdx

; 278  : 			paulaSetData(i, ch->n_start + s->loopStart);

  00064	4b 03 84 19 00
	0b 00 00	 add	 rax, QWORD PTR [r9+r11+2816]

; 486  : 	if (src == NULL)

  0006c	48 85 c0	 test	 rax, rax
  0006f	75 09		 jne	 SHORT $LN8@mixerUpdat

; 487  : 		src = &modEntry->sampleData[RESERVED_SAMPLE_OFFSET]; // dummy sample

  00071	49 8b 03	 mov	 rax, QWORD PTR [r11]
  00074	48 05 c2 ff 1e
	00		 add	 rax, 2031554		; 001effc2H
$LN8@mixerUpdat:

; 488  : 
; 489  : 	paula[ch].newData = src;
; 490  : 
; 491  : 	// set external scope data
; 492  : 	se = &scopeExt[ch];
; 493  : 	tmp = *se; // cache it

  0007a	41 0f 10 00	 movups	 xmm0, XMMWORD PTR [r8]
  0007e	49 89 42 f4	 mov	 QWORD PTR [r10-12], rax

; 494  : 
; 495  : 	tmp.newData = src;
; 496  : 	tmp.newLoopFlag = (s->loopStart + s->loopLength) > 2;

  00082	41 0f b7 8c d3
	8c 01 00 00	 movzx	 ecx, WORD PTR [r11+rdx*8+396]
  0008b	f2 41 0f 10 48
	10		 movsd	 xmm1, QWORD PTR [r8+16]
  00091	0f 11 04 24	 movups	 XMMWORD PTR tmp$1[rsp], xmm0
  00095	48 89 04 24	 mov	 QWORD PTR tmp$1[rsp], rax
  00099	41 0f b7 84 d3
	8e 01 00 00	 movzx	 eax, WORD PTR [r11+rdx*8+398]
  000a2	03 c1		 add	 eax, ecx
  000a4	f2 0f 11 4c 24
	10		 movsd	 QWORD PTR tmp$1[rsp+16], xmm1
  000aa	83 f8 02	 cmp	 eax, 2

; 497  : 	tmp.newLoopStart = s->loopStart;

  000ad	89 4c 24 10	 mov	 DWORD PTR tmp$1[rsp+16], ecx

; 498  : 
; 499  : 	*se = tmp; // update it

  000b1	f2 0f 10 4c 24
	10		 movsd	 xmm1, QWORD PTR tmp$1[rsp+16]
  000b7	0f 97 44 24 0b	 seta	 BYTE PTR tmp$1[rsp+11]
  000bc	0f 10 04 24	 movups	 xmm0, XMMWORD PTR tmp$1[rsp]
  000c0	41 0f 11 00	 movups	 XMMWORD PTR [r8], xmm0
  000c4	f2 41 0f 11 48
	10		 movsd	 QWORD PTR [r8+16], xmm1

; 279  : 			paulaSetLength(i, s->loopLength / 2);

  000ca	41 0f b7 84 f3
	8e 01 00 00	 movzx	 eax, WORD PTR [r11+rsi*8+398]
  000d3	66 d1 e8	 shr	 ax, 1

; 463  : 	if (len == 0)

  000d6	75 05		 jne	 SHORT $LN11@mixerUpdat

; 464  : 	{
; 465  : 		len = 65535;

  000d8	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN11@mixerUpdat:

; 466  : 		/* confirmed behavior on real Amiga (also needed for safety)
; 467  : 		** And yes, we have room for this, it will never overflow!
; 468  : 		*/
; 469  : 	}
; 470  : 
; 471  : 	// our mixer works with bytes, not words. Multiply by two
; 472  : 	scopeExt[ch].newLength = paula[ch].newLength = len * 2;

  000dd	0f b7 c0	 movzx	 eax, ax
  000e0	03 c0		 add	 eax, eax
  000e2	41 89 02	 mov	 DWORD PTR [r10], eax
  000e5	41 89 40 0c	 mov	 DWORD PTR [r8+12], eax
$LN2@mixerUpdat:

; 269  : 	moduleChannel_t *ch;
; 270  : 	moduleSample_t *s;
; 271  : 
; 272  : 	for (uint8_t i = 0; i < AMIGA_VOICES; i++)

  000e9	49 83 c1 40	 add	 r9, 64			; 00000040H
  000ed	49 83 c2 70	 add	 r10, 112		; 00000070H
  000f1	49 83 c0 18	 add	 r8, 24
  000f5	48 83 eb 01	 sub	 rbx, 1
  000f9	0f 85 34 ff ff
	ff		 jne	 $LL4@mixerUpdat

; 280  : 		}
; 281  : 	}
; 282  : }

  000ff	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00104	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00109	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010d	5f		 pop	 rdi
  0010e	c3		 ret	 0
mixerUpdateLoops ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT mixerSetVoicePan
_TEXT	SEGMENT
ch$ = 8
pan$ = 16
mixerSetVoicePan PROC					; COMDAT

; 221  : 	fX = (1.0 - fX) * (1.0 + fX);

  00000	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  00008	0f 57 ed	 xorps	 xmm5, xmm5

; 215  : 	fX = fX * (2.0 - fX);

  0000b	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@4000000000000000

; 286  : 	double dPan;
; 287  : 
; 288  : 	/* proper 'normalized' equal-power panning is (assuming pan left to right):
; 289  : 	** L = cos(p * pi * 1/2) * sqrt(2);
; 290  : 	** R = sin(p * pi * 1/2) * sqrt(2); */
; 291  : 	dPan = pan * (1.0 / 256.0); // 0.0..1.0

  00013	0f b7 c2	 movzx	 eax, dx
  00016	f2 0f 2a e8	 cvtsi2sd xmm5, eax

; 292  : 
; 293  : 	paula[ch].dPanL = cosApx(dPan);

  0001a	0f b6 c1	 movzx	 eax, cl
  0001d	48 6b c8 70	 imul	 rcx, rax, 112		; 00000070H

; 221  : 	fX = (1.0 - fX) * (1.0 + fX);

  00021	0f 28 c5	 movaps	 xmm0, xmm5

; 286  : 	double dPan;
; 287  : 
; 288  : 	/* proper 'normalized' equal-power panning is (assuming pan left to right):
; 289  : 	** L = cos(p * pi * 1/2) * sqrt(2);
; 290  : 	** R = sin(p * pi * 1/2) * sqrt(2); */
; 291  : 	dPan = pan * (1.0 / 256.0); // 0.0..1.0

  00024	0f 28 d5	 movaps	 xmm2, xmm5
  00027	f2 0f 59 15 00
	00 00 00	 mulsd	 xmm2, QWORD PTR __real@3f70000000000000

; 221  : 	fX = (1.0 - fX) * (1.0 + fX);

  0002f	f2 0f 59 c5	 mulsd	 xmm0, xmm5

; 292  : 
; 293  : 	paula[ch].dPanL = cosApx(dPan);

  00033	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:paula

; 215  : 	fX = fX * (2.0 - fX);

  0003a	f2 0f 5c da	 subsd	 xmm3, xmm2

; 221  : 	fX = (1.0 - fX) * (1.0 + fX);

  0003e	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3ef0000000000000

; 216  : 	return fX * 1.09742972 + fX * fX * 0.31678383;

  00046	0f 28 e3	 movaps	 xmm4, xmm3
  00049	f2 0f 59 e5	 mulsd	 xmm4, xmm5

; 221  : 	fX = (1.0 - fX) * (1.0 + fX);

  0004d	f2 0f 5c c8	 subsd	 xmm1, xmm0

; 222  : 	return fX * 1.09742972 + fX * fX * 0.31678383;

  00051	0f 28 c1	 movaps	 xmm0, xmm1
  00054	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00058	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3ff18f127750ef5c
  00060	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fd4462faf701a9a
  00068	f2 0f 58 c1	 addsd	 xmm0, xmm1

; 216  : 	return fX * 1.09742972 + fX * fX * 0.31678383;

  0006c	0f 28 cd	 movaps	 xmm1, xmm5
  0006f	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3e54462faf701a9a

; 292  : 
; 293  : 	paula[ch].dPanL = cosApx(dPan);

  00077	f2 0f 11 44 01
	60		 movsd	 QWORD PTR [rcx+rax+96], xmm0

; 216  : 	return fX * 1.09742972 + fX * fX * 0.31678383;

  0007d	0f 28 c5	 movaps	 xmm0, xmm5
  00080	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3ed4462faf701a9a
  00088	f2 0f 59 cb	 mulsd	 xmm1, xmm3
  0008c	f2 0f 59 e0	 mulsd	 xmm4, xmm0
  00090	0f 28 c5	 movaps	 xmm0, xmm5
  00093	f2 0f 59 c5	 mulsd	 xmm0, xmm5
  00097	f2 0f 59 2d 00
	00 00 00	 mulsd	 xmm5, QWORD PTR __real@3f718f127750ef5c
  0009f	f2 0f 58 e4	 addsd	 xmm4, xmm4
  000a3	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  000a7	f2 0f 59 eb	 mulsd	 xmm5, xmm3
  000ab	f2 0f 5c e1	 subsd	 xmm4, xmm1
  000af	f2 0f 58 e5	 addsd	 xmm4, xmm5

; 294  : 	paula[ch].dPanR = sinApx(dPan);

  000b3	f2 0f 11 64 01
	68		 movsd	 QWORD PTR [rcx+rax+104], xmm4

; 295  : }

  000b9	c3		 ret	 0
mixerSetVoicePan ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT mixerKillVoice
_TEXT	SEGMENT
ch$ = 8
mixerKillVoice PROC					; COMDAT

; 299  : 	paulaVoice_t *v;
; 300  : 	scopeChannelExt_t *s;
; 301  : 
; 302  : 	v = &paula[ch];

  00000	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  00007	0f b6 d1	 movzx	 edx, cl
  0000a	0f 57 c0	 xorps	 xmm0, xmm0
  0000d	48 6b c2 70	 imul	 rax, rdx, 112		; 00000070H

; 303  : 	s = &scopeExt[ch];

  00011	48 8d 0c 52	 lea	 rcx, QWORD PTR [rdx+rdx*2]

; 304  : 
; 305  : 	v->active = false;

  00015	42 c6 84 00 00
	00 00 00 00	 mov	 BYTE PTR paula[rax+r8], 0

; 306  : 	v->dVolume = 0.0;

  0001e	4a c7 84 00 28
	00 00 00 00 00
	00 00		 mov	 QWORD PTR paula[rax+r8+40], 0

; 307  : 
; 308  : 	s->active = false;
; 309  : 	s->didSwapData = false;
; 310  : 
; 311  : 	memset(&blep[ch], 0, sizeof (blep_t));

  0002a	48 8d 04 92	 lea	 rax, QWORD PTR [rdx+rdx*4]
  0002e	48 03 c0	 add	 rax, rax
  00031	41 c6 84 c8 08
	00 00 00 00	 mov	 BYTE PTR scopeExt[r8+rcx*8+8], 0
  0003a	41 c6 84 c8 09
	00 00 00 00	 mov	 BYTE PTR scopeExt[r8+rcx*8+9], 0
  00043	41 0f 11 84 c0
	00 00 00 00	 movups	 XMMWORD PTR blep[r8+rax*8], xmm0

; 312  : 	memset(&blepVol[ch], 0, sizeof (blep_t));

  0004c	41 0f 11 84 c0
	00 00 00 00	 movups	 XMMWORD PTR blepVol[r8+rax*8], xmm0
  00055	41 0f 11 84 c0
	10 00 00 00	 movups	 XMMWORD PTR blep[r8+rax*8+16], xmm0
  0005e	41 0f 11 84 c0
	10 00 00 00	 movups	 XMMWORD PTR blepVol[r8+rax*8+16], xmm0
  00067	41 0f 11 84 c0
	20 00 00 00	 movups	 XMMWORD PTR blep[r8+rax*8+32], xmm0
  00070	41 0f 11 84 c0
	20 00 00 00	 movups	 XMMWORD PTR blepVol[r8+rax*8+32], xmm0
  00079	41 0f 11 84 c0
	30 00 00 00	 movups	 XMMWORD PTR blep[r8+rax*8+48], xmm0
  00082	41 0f 11 84 c0
	30 00 00 00	 movups	 XMMWORD PTR blepVol[r8+rax*8+48], xmm0
  0008b	41 0f 11 84 c0
	40 00 00 00	 movups	 XMMWORD PTR blep[r8+rax*8+64], xmm0
  00094	41 0f 11 84 c0
	40 00 00 00	 movups	 XMMWORD PTR blepVol[r8+rax*8+64], xmm0

; 313  : }

  0009d	c3		 ret	 0
mixerKillVoice ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT turnOffVoices
_TEXT	SEGMENT
turnOffVoices PROC					; COMDAT

; 317  : 	for (uint8_t i = 0; i < AMIGA_VOICES; i++)

  00000	45 33 d2	 xor	 r10d, r10d
  00003	48 8d 0d 09 00
	00 00		 lea	 rcx, OFFSET FLAT:scopeExt+9
  0000a	48 8d 15 28 00
	00 00		 lea	 rdx, OFFSET FLAT:paula+40
  00011	41 8b c2	 mov	 eax, r10d
  00014	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:__ImageBase
  0001b	45 8d 42 04	 lea	 r8d, QWORD PTR [r10+4]
  0001f	90		 npad	 1
$LL4@turnOffVoi:

; 305  : 	v->active = false;

  00020	44 88 52 d8	 mov	 BYTE PTR [rdx-40], r10b
  00024	0f 57 c0	 xorps	 xmm0, xmm0

; 306  : 	v->dVolume = 0.0;

  00027	4c 89 12	 mov	 QWORD PTR [rdx], r10

; 317  : 	for (uint8_t i = 0; i < AMIGA_VOICES; i++)

  0002a	48 8d 52 70	 lea	 rdx, QWORD PTR [rdx+112]

; 308  : 	s->active = false;

  0002e	44 88 51 ff	 mov	 BYTE PTR [rcx-1], r10b

; 309  : 	s->didSwapData = false;

  00032	44 88 11	 mov	 BYTE PTR [rcx], r10b

; 317  : 	for (uint8_t i = 0; i < AMIGA_VOICES; i++)

  00035	48 8d 49 18	 lea	 rcx, QWORD PTR [rcx+24]

; 311  : 	memset(&blep[ch], 0, sizeof (blep_t));

  00039	42 0f 11 84 08
	00 00 00 00	 movups	 XMMWORD PTR blep[rax+r9], xmm0

; 312  : 	memset(&blepVol[ch], 0, sizeof (blep_t));

  00042	42 0f 11 84 08
	00 00 00 00	 movups	 XMMWORD PTR blepVol[rax+r9], xmm0
  0004b	42 0f 11 84 08
	10 00 00 00	 movups	 XMMWORD PTR blep[rax+r9+16], xmm0
  00054	42 0f 11 84 08
	10 00 00 00	 movups	 XMMWORD PTR blepVol[rax+r9+16], xmm0
  0005d	42 0f 11 84 08
	20 00 00 00	 movups	 XMMWORD PTR blep[rax+r9+32], xmm0
  00066	42 0f 11 84 08
	20 00 00 00	 movups	 XMMWORD PTR blepVol[rax+r9+32], xmm0
  0006f	42 0f 11 84 08
	30 00 00 00	 movups	 XMMWORD PTR blep[rax+r9+48], xmm0
  00078	42 0f 11 84 08
	30 00 00 00	 movups	 XMMWORD PTR blepVol[rax+r9+48], xmm0
  00081	42 0f 11 84 08
	40 00 00 00	 movups	 XMMWORD PTR blep[rax+r9+64], xmm0
  0008a	42 0f 11 84 08
	40 00 00 00	 movups	 XMMWORD PTR blepVol[rax+r9+64], xmm0

; 317  : 	for (uint8_t i = 0; i < AMIGA_VOICES; i++)

  00093	48 8d 40 50	 lea	 rax, QWORD PTR [rax+80]
  00097	49 83 e8 01	 sub	 r8, 1
  0009b	75 83		 jne	 SHORT $LL4@turnOffVoi

; 318  : 		mixerKillVoice(i);
; 319  : 
; 320  : 	clearLossyIntegrator(&filterLo);
; 321  : 	clearLossyIntegrator(&filterHi);
; 322  : 	clearLEDFilter(&filterLED);
; 323  : 
; 324  : 	resetDitherSeed();

  0009d	0f 57 c9	 xorps	 xmm1, xmm1
  000a0	c7 05 00 00 00
	00 00 50 34 12	 mov	 DWORD PTR randSeed, 305418240 ; 12345000H

; 152  : 	filter->dBuffer[0] = 0.0; // L

  000aa	0f 11 0d 00 00
	00 00		 movups	 XMMWORD PTR filterHi, xmm1

; 325  : 
; 326  : 	editor.tuningFlag = false;

  000b1	44 88 15 19 01
	00 00		 mov	 BYTE PTR editor+281, r10b

; 158  : 	filter->dLed[0] = 0.0; // L

  000b8	0f 11 0d 10 00
	00 00		 movups	 XMMWORD PTR filterLED+16, xmm1

; 152  : 	filter->dBuffer[0] = 0.0; // L

  000bf	0f 11 05 00 00
	00 00		 movups	 XMMWORD PTR filterLo, xmm0

; 158  : 	filter->dLed[0] = 0.0; // L

  000c6	0f 11 05 00 00
	00 00		 movups	 XMMWORD PTR filterLED, xmm0

; 327  : }

  000cd	c3		 ret	 0
turnOffVoices ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT paulaStopDMA
_TEXT	SEGMENT
ch$ = 8
paulaStopDMA PROC					; COMDAT

; 331  : 	scopeExt[ch].active = paula[ch].active = false;

  00000	0f b6 d1	 movzx	 edx, cl
  00003	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0000a	48 6b c2 70	 imul	 rax, rdx, 112		; 00000070H
  0000e	c6 84 08 00 00
	00 00 00	 mov	 BYTE PTR paula[rax+rcx], 0
  00016	48 8d 04 52	 lea	 rax, QWORD PTR [rdx+rdx*2]
  0001a	c6 84 c1 08 00
	00 00 00	 mov	 BYTE PTR scopeExt[rcx+rax*8+8], 0

; 332  : }

  00022	c3		 ret	 0
paulaStopDMA ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT paulaStartDMA
_TEXT	SEGMENT
s$ = 0
ch$ = 48
paulaStartDMA PROC					; COMDAT

; 335  : {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 336  : 	const int8_t *dat;
; 337  : 	int32_t length;
; 338  : 	paulaVoice_t *v;
; 339  : 	scopeChannel_t s, *sc;
; 340  : 	scopeChannelExt_t *se;
; 341  : 
; 342  : 	// trigger voice
; 343  : 
; 344  : 	v  = &paula[ch];
; 345  : 
; 346  : 	dat = v->newData;
; 347  : 	if (dat == NULL)

  00004	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR modEntry
  0000b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:paula
  00012	44 0f b6 c9	 movzx	 r9d, cl
  00016	49 6b c9 70	 imul	 rcx, r9, 112		; 00000070H
  0001a	48 03 c8	 add	 rcx, rax
  0001d	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00021	48 85 c0	 test	 rax, rax
  00024	75 09		 jne	 SHORT $LN2@paulaStart

; 348  : 		dat = &modEntry->sampleData[RESERVED_SAMPLE_OFFSET]; // dummy sample

  00026	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00029	48 05 c2 ff 1e
	00		 add	 rax, 2031554		; 001effc2H
$LN2@paulaStart:

; 349  : 
; 350  : 	length = v->newLength;

  0002f	44 8b 51 1c	 mov	 r10d, DWORD PTR [rcx+28]

; 351  : 	if (length < 2)

  00033	ba 02 00 00 00	 mov	 edx, 2
  00038	44 3b d2	 cmp	 r10d, edx

; 352  : 		length = 2; // for safety
; 353  : 
; 354  : 	v->dPhase = 0.0;
; 355  : 	v->pos = 0;
; 356  : 	v->data = dat;

  0003b	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 357  : 	v->length = length;
; 358  : 	v->active = true;
; 359  : 
; 360  : 	// trigger scope
; 361  : 
; 362  : 	sc = &scope[ch];

  0003f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:scope
  00046	44 0f 4c d2	 cmovl	 r10d, edx
  0004a	45 33 db	 xor	 r11d, r11d
  0004d	49 8b d1	 mov	 rdx, r9
  00050	4c 89 59 40	 mov	 QWORD PTR [rcx+64], r11
  00054	48 c1 e2 05	 shl	 rdx, 5
  00058	48 03 d0	 add	 rdx, rax
  0005b	44 89 59 20	 mov	 DWORD PTR [rcx+32], r11d
  0005f	44 89 51 18	 mov	 DWORD PTR [rcx+24], r10d
  00063	c6 01 01	 mov	 BYTE PTR [rcx], 1

; 363  : 	se = &scopeExt[ch];

  00066	4b 8d 0c 49	 lea	 rcx, QWORD PTR [r9+r9*2]
  0006a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:scopeExt

; 364  : 	s = *sc; // cache it

  00071	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]

; 365  : 
; 366  : 	dat = se->newData;

  00074	49 8b 04 c9	 mov	 rax, QWORD PTR [r9+rcx*8]
  00078	0f 10 4a 10	 movups	 xmm1, XMMWORD PTR [rdx+16]
  0007c	0f 11 04 24	 movups	 XMMWORD PTR s$[rsp], xmm0
  00080	0f 11 4c 24 10	 movups	 XMMWORD PTR s$[rsp+16], xmm1

; 367  : 	if (dat == NULL)

  00085	48 85 c0	 test	 rax, rax
  00088	75 09		 jne	 SHORT $LN4@paulaStart

; 368  : 		dat = &modEntry->sampleData[RESERVED_SAMPLE_OFFSET]; // dummy sample

  0008a	49 8b 00	 mov	 rax, QWORD PTR [r8]
  0008d	48 05 c2 ff 1e
	00		 add	 rax, 2031554		; 001effc2H
$LN4@paulaStart:

; 369  : 
; 370  : 	s.length = length;
; 371  : 	s.data = dat;

  00093	48 89 04 24	 mov	 QWORD PTR s$[rsp], rax

; 372  : 
; 373  : 	s.pos = 0;
; 374  : 	s.posFrac = 0;
; 375  : 
; 376  : 	// data/length is already set from replayer thread (important)
; 377  : 	s.loopFlag = se->newLoopFlag;

  00097	41 0f b6 44 c9
	0b		 movzx	 eax, BYTE PTR [r9+rcx*8+11]
  0009d	88 44 24 08	 mov	 BYTE PTR s$[rsp+8], al

; 378  : 	s.loopStart = se->newLoopStart;

  000a1	41 8b 44 c9 10	 mov	 eax, DWORD PTR [r9+rcx*8+16]
  000a6	44 89 54 24 0c	 mov	 DWORD PTR s$[rsp+12], r10d

; 379  : 
; 380  : 	se->didSwapData = false;
; 381  : 	se->active = true;
; 382  : 
; 383  : 	*sc = s; // update it

  000ab	0f 10 04 24	 movups	 xmm0, XMMWORD PTR s$[rsp]
  000af	89 44 24 14	 mov	 DWORD PTR s$[rsp+20], eax
  000b3	44 89 5c 24 10	 mov	 DWORD PTR s$[rsp+16], r11d
  000b8	44 89 5c 24 1c	 mov	 DWORD PTR s$[rsp+28], r11d
  000bd	0f 10 4c 24 10	 movups	 xmm1, XMMWORD PTR s$[rsp+16]
  000c2	45 88 5c c9 09	 mov	 BYTE PTR [r9+rcx*8+9], r11b
  000c7	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
  000ca	41 c6 44 c9 08
	01		 mov	 BYTE PTR [r9+rcx*8+8], 1
  000d0	0f 11 4a 10	 movups	 XMMWORD PTR [rdx+16], xmm1

; 384  : }

  000d4	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000d8	c3		 ret	 0
paulaStartDMA ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT resetCachedMixerPeriod
_TEXT	SEGMENT
resetCachedMixerPeriod PROC				; COMDAT

; 388  : 	oldPeriod = 0;

  00000	33 c0		 xor	 eax, eax
  00002	66 89 05 00 00
	00 00		 mov	 WORD PTR oldPeriod, ax

; 389  : }

  00009	c3		 ret	 0
resetCachedMixerPeriod ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_scopes.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_scopes.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_scopes.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT paulaSetPeriod
_TEXT	SEGMENT
ch$ = 16
period$ = 24
paulaSetPeriod PROC					; COMDAT

; 392  : {

$LN21:
  00000	48 83 ec 08	 sub	 rsp, 8

; 393  : 	double dPeriodToDeltaDiv;
; 394  : 	paulaVoice_t *v;
; 395  : 
; 396  : 	v = &paula[ch];

  00004	44 0f b6 d1	 movzx	 r10d, cl
  00008	4d 6b ca 70	 imul	 r9, r10, 112		; 00000070H

; 397  : 
; 398  : 	if (period == 0)

  0000c	66 85 d2	 test	 dx, dx
  0000f	75 34		 jne	 SHORT $LN2@paulaSetPe

; 399  : 	{
; 400  : 		v->dDelta = 0.0; // confirmed behavior on real Amiga

  00011	33 c9		 xor	 ecx, ecx
  00013	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
; File C:\Programming\pt2-clone\src\pt2_scopes.c

; 65   : 	scope[ch].delta = delta;

  0001a	49 c1 e2 05	 shl	 r10, 5
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 401  : 		v->dDeltaMul = 1.0; // for BLEP synthesis

  0001e	48 b8 00 00 00
	00 00 00 f0 3f	 mov	 rax, 4607182418800017408 ; 3ff0000000000000H
  00028	4b 89 8c 01 30
	00 00 00	 mov	 QWORD PTR paula[r9+r8+48], rcx
  00030	4b 89 84 01 38
	00 00 00	 mov	 QWORD PTR paula[r9+r8+56], rax
; File C:\Programming\pt2-clone\src\pt2_scopes.c

; 65   : 	scope[ch].delta = delta;

  00038	43 89 8c 02 18
	00 00 00	 mov	 DWORD PTR scope[r10+r8+24], ecx
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 449  : }

  00040	48 83 c4 08	 add	 rsp, 8
  00044	c3		 ret	 0
$LN2@paulaSetPe:

; 402  : 		setScopeDelta(ch, 0);
; 403  : 		return;
; 404  : 	}
; 405  : 
; 406  : 	if (period < 113)
; 407  : 		period = 113; // confirmed behavior on real Amiga
; 408  : 
; 409  : 	// if the new period was the same as the previous period, use cached deltas
; 410  : 	if (period == oldPeriod)

  00045	b9 71 00 00 00	 mov	 ecx, 113		; 00000071H
  0004a	48 89 1c 24	 mov	 QWORD PTR [rsp], rbx
  0004e	66 3b d1	 cmp	 dx, cx
  00051	66 0f 43 ca	 cmovae	 cx, dx
  00055	66 3b 0d 00 00
	00 00		 cmp	 cx, WORD PTR oldPeriod
  0005c	75 30		 jne	 SHORT $LN4@paulaSetPe

; 412  : 		v->dDelta = dOldVoiceDelta;

  0005e	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR dOldVoiceDelta
  00066	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
; File C:\Programming\pt2-clone\src\pt2_scopes.c

; 65   : 	scope[ch].delta = delta;

  0006d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR oldScopeDelta
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 412  : 		v->dDelta = dOldVoiceDelta;

  00073	49 8d 98 30 00
	00 00		 lea	 rbx, QWORD PTR paula[r8+48]
  0007a	49 03 d9	 add	 rbx, r9
  0007d	f2 0f 11 03	 movsd	 QWORD PTR [rbx], xmm0

; 413  : 		v->dDeltaMul = dOldVoiceDeltaMul; // for BLEP synthesis

  00081	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR dOldVoiceDeltaMul

; 414  : 		setScopeDelta(ch, oldScopeDelta);
; 415  : 	}

  00089	e9 86 00 00 00	 jmp	 $LN19@paulaSetPe
$LN4@paulaSetPe:

; 416  : 	else 
; 417  : 	{
; 418  : 		// this period is not cached, calculate mixer/scope deltas
; 419  : 
; 420  : #if SCOPE_HZ != 64
; 421  : #error Scope Hz is not 64 (2^n), change rate calc. to use doubles+round in pt2_scope.c
; 422  : #endif
; 423  : 		oldPeriod = period;
; 424  : 
; 425  : 		// if we are rendering pattern to sample (PAT2SMP), use different frequencies
; 426  : 		if (editor.isSMPRendering)

  0008e	0f b6 05 3f 00
	00 00		 movzx	 eax, BYTE PTR editor+63
  00095	66 89 0d 00 00
	00 00		 mov	 WORD PTR oldPeriod, cx
  0009c	84 c0		 test	 al, al
  0009e	74 1d		 je	 SHORT $LN6@paulaSetPe

; 427  : 			dPeriodToDeltaDiv = editor.pat2SmpHQ ? (PAULA_PAL_CLK / 28836.0) : (PAULA_PAL_CLK / 22168.0);

  000a0	80 3d 11 01 00
	00 00		 cmp	 BYTE PTR editor+273, 0
  000a7	74 0a		 je	 SHORT $LN11@paulaSetPe
  000a9	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@405ec0261166854f
  000b1	eb 12		 jmp	 SHORT $LN7@paulaSetPe
$LN11@paulaSetPe:
  000b3	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@406400058b0a4139
  000bb	eb 08		 jmp	 SHORT $LN7@paulaSetPe
$LN6@paulaSetPe:

; 428  : 		else
; 429  : 			dPeriodToDeltaDiv = audio.dPeriodToDeltaDiv;

  000bd	f2 0f 10 0d 50
	05 00 00	 movsd	 xmm1, QWORD PTR audio+1360
$LN7@paulaSetPe:

; 430  : 
; 431  : 		v->dDelta = dPeriodToDeltaDiv / period;

  000c5	0f b7 c9	 movzx	 ecx, cx
  000c8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  000cf	49 8d 98 30 00
	00 00		 lea	 rbx, QWORD PTR paula[r8+48]

; 432  : 		v->dDeltaMul = 1.0 / v->dDelta; // for BLEP synthesis
; 433  : 
; 434  : 		// cache these
; 435  : 		dOldVoiceDelta = v->dDelta;
; 436  : 		dOldVoiceDeltaMul = v->dDeltaMul; // for BLEP synthesis
; 437  : 		oldScopeDelta = (PAULA_PAL_CLK * (65536UL / SCOPE_HZ)) / period;

  000d6	33 d2		 xor	 edx, edx
  000d8	49 03 d9	 add	 rbx, r9
  000db	b8 00 3c 7c d8	 mov	 eax, -662946816		; d87c3c00H
  000e0	f7 f1		 div	 ecx
  000e2	66 0f 6e c1	 movd	 xmm0, ecx
  000e6	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000ea	89 05 00 00 00
	00		 mov	 DWORD PTR oldScopeDelta, eax
  000f0	f2 0f 5e c8	 divsd	 xmm1, xmm0
  000f4	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3ff0000000000000
  000fc	f2 0f 5e c1	 divsd	 xmm0, xmm1
  00100	f2 0f 11 0b	 movsd	 QWORD PTR [rbx], xmm1
  00104	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR dOldVoiceDeltaMul, xmm0
  0010c	f2 0f 11 0d 00
	00 00 00	 movsd	 QWORD PTR dOldVoiceDelta, xmm1
$LN19@paulaSetPe:

; 438  : 
; 439  : 		setScopeDelta(ch, oldScopeDelta);
; 440  : 	}
; 441  : 
; 442  : 	// for BLEP synthesis
; 443  : 
; 444  : 	if (v->dLastDelta == 0.0)

  00114	49 c1 e2 05	 shl	 r10, 5
  00118	4d 8d 98 38 00
	00 00		 lea	 r11, QWORD PTR paula[r8+56]
  0011f	4d 03 d9	 add	 r11, r9
  00122	43 89 84 02 18
	00 00 00	 mov	 DWORD PTR scope[r10+r8+24], eax
  0012a	f2 41 0f 11 03	 movsd	 QWORD PTR [r11], xmm0
  0012f	0f 57 c0	 xorps	 xmm0, xmm0
  00132	66 43 0f 2e 84
	01 48 00 00 00	 ucomisd xmm0, QWORD PTR paula[r9+r8+72]
  0013c	75 0b		 jne	 SHORT $LN8@paulaSetPe

; 445  : 		v->dLastDelta = v->dDelta;

  0013e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00141	4b 89 84 01 48
	00 00 00	 mov	 QWORD PTR paula[r9+r8+72], rax
$LN8@paulaSetPe:

; 446  : 
; 447  : 	if (v->dLastDeltaMul == 0.0)

  00149	66 43 0f 2e 84
	01 50 00 00 00	 ucomisd xmm0, QWORD PTR paula[r9+r8+80]
  00153	48 8b 1c 24	 mov	 rbx, QWORD PTR [rsp]
  00157	75 0b		 jne	 SHORT $LN9@paulaSetPe

; 448  : 		v->dLastDeltaMul = v->dDeltaMul;

  00159	49 8b 03	 mov	 rax, QWORD PTR [r11]
  0015c	4b 89 84 01 50
	00 00 00	 mov	 QWORD PTR paula[r9+r8+80], rax
$LN9@paulaSetPe:

; 449  : }

  00164	48 83 c4 08	 add	 rsp, 8
  00168	c3		 ret	 0
paulaSetPeriod ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT paulaSetVolume
_TEXT	SEGMENT
ch$ = 8
vol$ = 16
paulaSetVolume PROC					; COMDAT

; 452  : {

  00000	0f b7 c2	 movzx	 eax, dx

; 453  : 	vol &= 127; // confirmed behavior on real Amiga

  00003	66 83 e0 7f	 and	 ax, 127			; 0000007fH

; 454  : 
; 455  : 	if (vol > 64)

  00007	66 83 f8 40	 cmp	 ax, 64			; 00000040H
  0000b	76 05		 jbe	 SHORT $LN2@paulaSetVo

; 456  : 		vol = 64; // confirmed behavior on real Amiga

  0000d	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
$LN2@paulaSetVo:

; 457  : 
; 458  : 	paula[ch].dVolume = vol * (1.0 / 64.0);

  00012	0f b7 c0	 movzx	 eax, ax
  00015	66 0f 6e c0	 movd	 xmm0, eax
  00019	0f b6 c1	 movzx	 eax, cl
  0001c	48 6b c8 70	 imul	 rcx, rax, 112		; 00000070H
  00020	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00024	48 8d 05 28 00
	00 00		 lea	 rax, OFFSET FLAT:paula+40
  0002b	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3f90000000000000
  00033	f2 0f 11 04 01	 movsd	 QWORD PTR [rcx+rax], xmm0

; 459  : }

  00038	c3		 ret	 0
paulaSetVolume ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT paulaSetLength
_TEXT	SEGMENT
ch$ = 8
len$ = 16
paulaSetLength PROC					; COMDAT

; 463  : 	if (len == 0)
; 464  : 	{
; 465  : 		len = 65535;
; 466  : 		/* confirmed behavior on real Amiga (also needed for safety)
; 467  : 		** And yes, we have room for this, it will never overflow!
; 468  : 		*/
; 469  : 	}
; 470  : 
; 471  : 	// our mixer works with bytes, not words. Multiply by two
; 472  : 	scopeExt[ch].newLength = paula[ch].newLength = len * 2;

  00000	66 85 d2	 test	 dx, dx
  00003	0f b6 c9	 movzx	 ecx, cl
  00006	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0000b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  00012	66 0f 45 c2	 cmovne	 ax, dx
  00016	0f b7 d0	 movzx	 edx, ax
  00019	48 6b c1 70	 imul	 rax, rcx, 112		; 00000070H
  0001d	03 d2		 add	 edx, edx
  0001f	42 89 94 00 1c
	00 00 00	 mov	 DWORD PTR paula[rax+r8+28], edx
  00027	48 8d 04 49	 lea	 rax, QWORD PTR [rcx+rcx*2]
  0002b	41 89 94 c0 0c
	00 00 00	 mov	 DWORD PTR scopeExt[r8+rax*8+12], edx

; 473  : }

  00033	c3		 ret	 0
paulaSetLength ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT paulaSetData
_TEXT	SEGMENT
tmp$ = 0
ch$ = 48
src$ = 56
paulaSetData PROC					; COMDAT

; 476  : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	4c 8b c2	 mov	 r8, rdx

; 477  : 	uint8_t smp;
; 478  : 	moduleSample_t *s;
; 479  : 	scopeChannelExt_t *se, tmp;
; 480  : 
; 481  : 	smp = modEntry->channels[ch].n_samplenum;

  00007	44 0f b6 c9	 movzx	 r9d, cl

; 482  : 	assert(smp <= 30);
; 483  : 	s = &modEntry->samples[smp];

  0000b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR modEntry
  00012	41 8b c1	 mov	 eax, r9d
  00015	48 c1 e0 06	 shl	 rax, 6
  00019	0f b6 84 10 27
	0b 00 00	 movzx	 eax, BYTE PTR [rax+rdx+2855]
  00021	4c 8d 14 80	 lea	 r10, QWORD PTR [rax+rax*4]
  00025	49 c1 e2 04	 shl	 r10, 4
  00029	4c 03 d2	 add	 r10, rdx

; 484  : 
; 485  : 	// set voice data
; 486  : 	if (src == NULL)

  0002c	4d 85 c0	 test	 r8, r8
  0002f	75 0a		 jne	 SHORT $LN2@paulaSetDa

; 487  : 		src = &modEntry->sampleData[RESERVED_SAMPLE_OFFSET]; // dummy sample

  00031	4c 8b 02	 mov	 r8, QWORD PTR [rdx]
  00034	49 81 c0 c2 ff
	1e 00		 add	 r8, 2031554		; 001effc2H
$LN2@paulaSetDa:

; 488  : 
; 489  : 	paula[ch].newData = src;

  0003b	49 6b c1 70	 imul	 rax, r9, 112		; 00000070H
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase

; 490  : 
; 491  : 	// set external scope data
; 492  : 	se = &scopeExt[ch];

  00046	48 8d 91 00 00
	00 00		 lea	 rdx, QWORD PTR scopeExt[rcx]
  0004d	4c 89 84 08 10
	00 00 00	 mov	 QWORD PTR paula[rax+rcx+16], r8
  00055	4b 8d 04 49	 lea	 rax, QWORD PTR [r9+r9*2]

; 493  : 	tmp = *se; // cache it
; 494  : 
; 495  : 	tmp.newData = src;
; 496  : 	tmp.newLoopFlag = (s->loopStart + s->loopLength) > 2;

  00059	41 0f b7 8a 8c
	01 00 00	 movzx	 ecx, WORD PTR [r10+396]
  00061	48 8d 14 c2	 lea	 rdx, QWORD PTR [rdx+rax*8]
  00065	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]
  00068	41 0f b7 82 8e
	01 00 00	 movzx	 eax, WORD PTR [r10+398]
  00070	f2 0f 10 4a 10	 movsd	 xmm1, QWORD PTR [rdx+16]
  00075	03 c1		 add	 eax, ecx
  00077	0f 11 04 24	 movups	 XMMWORD PTR tmp$[rsp], xmm0
  0007b	83 f8 02	 cmp	 eax, 2
  0007e	4c 89 04 24	 mov	 QWORD PTR tmp$[rsp], r8
  00082	f2 0f 11 4c 24
	10		 movsd	 QWORD PTR tmp$[rsp+16], xmm1
  00088	0f 97 44 24 0b	 seta	 BYTE PTR tmp$[rsp+11]

; 497  : 	tmp.newLoopStart = s->loopStart;

  0008d	89 4c 24 10	 mov	 DWORD PTR tmp$[rsp+16], ecx

; 498  : 
; 499  : 	*se = tmp; // update it

  00091	0f 10 04 24	 movups	 xmm0, XMMWORD PTR tmp$[rsp]
  00095	f2 0f 10 4c 24
	10		 movsd	 xmm1, QWORD PTR tmp$[rsp+16]
  0009b	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
  0009e	f2 0f 11 4a 10	 movsd	 QWORD PTR [rdx+16], xmm1

; 500  : }

  000a3	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a7	c3		 ret	 0
paulaSetData ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_textout.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_textout.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT toggleA500Filters
_TEXT	SEGMENT
toggleA500Filters PROC					; COMDAT

; 504  : 	if (filterFlags & FILTER_A500)

  00000	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR filterFlags
  00007	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  0000e	a8 01		 test	 al, 1
  00010	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR filterFlags
  00017	66 c7 05 08 01
	00 00 01 00	 mov	 WORD PTR editor+264, 1
  00020	c6 05 82 22 00
	00 00		 mov	 BYTE PTR editor+8834, 0
  00027	74 36		 je	 SHORT $LN2@toggleA500

; 505  : 	{
; 506  : 		filterFlags &= ~FILTER_A500;

  00029	24 fe		 and	 al, -2
  0002b	88 05 00 00 00
	00		 mov	 BYTE PTR filterFlags, al
  00031	33 c9		 xor	 ecx, ecx
  00033	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL12@toggleA500:
; File C:\Programming\pt2-clone\src\pt2_textout.c

; 615  : 	strcpy(editor.ui.statusMessage, msg);

  00040	0f b6 84 11 00
	00 00 00	 movzx	 eax, BYTE PTR ??_C@_0BC@PKEIPOBC@FILTER?5MOD?3?5A1200@[rcx+rdx]
  00048	88 84 11 90 37
	00 00		 mov	 BYTE PTR editor[rcx+rdx+14224], al
  0004f	48 8d 49 01	 lea	 rcx, QWORD PTR [rcx+1]
  00053	84 c0		 test	 al, al
  00055	75 e9		 jne	 SHORT $LL12@toggleA500
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 515  : }

  00057	c6 05 03 38 00
	00 01		 mov	 BYTE PTR editor+14339, 1
  0005e	c3		 ret	 0
$LN2@toggleA500:

; 507  : 		displayMsg("FILTER MOD: A1200");
; 508  : 	}
; 509  : 	else
; 510  : 	{
; 511  : 		filterFlags |= FILTER_A500;

  0005f	0c 01		 or	 al, 1
  00061	0f 57 c0	 xorps	 xmm0, xmm0
  00064	88 05 00 00 00
	00		 mov	 BYTE PTR filterFlags, al
  0006a	33 c9		 xor	 ecx, ecx

; 152  : 	filter->dBuffer[0] = 0.0; // L

  0006c	0f 11 05 00 00
	00 00		 movups	 XMMWORD PTR filterLo, xmm0
  00073	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL22@toggleA500:
; File C:\Programming\pt2-clone\src\pt2_textout.c

; 615  : 	strcpy(editor.ui.statusMessage, msg);

  00080	0f b6 84 11 00
	00 00 00	 movzx	 eax, BYTE PTR ??_C@_0BB@ONPMACIL@FILTER?5MOD?3?5A500@[rcx+rdx]
  00088	88 84 11 90 37
	00 00		 mov	 BYTE PTR editor[rcx+rdx+14224], al
  0008f	48 8d 49 01	 lea	 rcx, QWORD PTR [rcx+1]
  00093	84 c0		 test	 al, al
  00095	75 e9		 jne	 SHORT $LL22@toggleA500
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 515  : }

  00097	c6 05 03 38 00
	00 01		 mov	 BYTE PTR editor+14339, 1
  0009e	c3		 ret	 0
toggleA500Filters ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_blep.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_blep.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_blep.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_blep.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_blep.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_blep.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_blep.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_blep.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_blep.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT mixChannels
_TEXT	SEGMENT
numSamples$ = 128
mixChannels PROC					; COMDAT

; 518  : {

$LN67:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 519  : 	const int8_t *dataPtr;
; 520  : 	double dTempSample, dTempVolume;
; 521  : 	blep_t *bSmp, *bVol;
; 522  : 	paulaVoice_t *v;
; 523  : 
; 524  : 	memset(dMixBufferL, 0, numSamples * sizeof (double));

  0001c	48 63 e9	 movsxd	 rbp, ecx
  0001f	33 d2		 xor	 edx, edx
  00021	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dMixBufferL
  00028	0f 29 74 24 40	 movaps	 XMMWORD PTR [rsp+64], xmm6
  0002d	0f 29 7c 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm7
  00032	48 8d 1c ed 00
	00 00 00	 lea	 rbx, QWORD PTR [rbp*8]
  0003a	44 0f 29 44 24
	20		 movaps	 XMMWORD PTR [rsp+32], xmm8
  00040	4c 8b c3	 mov	 r8, rbx
  00043	e8 00 00 00 00	 call	 memset

; 525  : 	memset(dMixBufferR, 0, numSamples * sizeof (double));

  00048	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dMixBufferR
  0004f	4c 8b c3	 mov	 r8, rbx
  00052	33 d2		 xor	 edx, edx
  00054	e8 00 00 00 00	 call	 memset
  00059	f2 0f 10 3d 00
	00 00 00	 movsd	 xmm7, QWORD PTR __real@3f80000000000000
  00061	48 8d 15 58 00
	00 00		 lea	 rdx, OFFSET FLAT:paula+88
  00068	f2 44 0f 10 05
	00 00 00 00	 movsd	 xmm8, QWORD PTR __real@4014000000000000
  00071	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:__ImageBase
  00078	f2 0f 10 35 00
	00 00 00	 movsd	 xmm6, QWORD PTR __real@3ff0000000000000
  00080	4c 8d 25 28 00
	00 00		 lea	 r12, OFFSET FLAT:dBlepData+40
  00087	45 33 ff	 xor	 r15d, r15d
  0008a	4c 8d 2d 18 02
	00 00		 lea	 r13, OFFSET FLAT:paula+536
  00091	45 8b c7	 mov	 r8d, r15d
$LL4@mixChannel:

; 528  : 	{
; 529  : 		v = &paula[i];
; 530  : 		if (!v->active)

  00094	0f b6 42 a8	 movzx	 eax, BYTE PTR [rdx-88]
  00098	84 c0		 test	 al, al
  0009a	0f 84 6c 02 00
	00		 je	 $LN2@mixChannel

; 531  : 			continue;
; 532  : 
; 533  : 		bSmp = &blep[i];
; 534  : 		bVol = &blepVol[i];
; 535  : 
; 536  : 		for (int32_t j = 0; j < numSamples; j++)

  000a0	48 85 ed	 test	 rbp, rbp
  000a3	0f 8e 63 02 00
	00		 jle	 $LN2@mixChannel

; 587  : 				{
; 588  : 					v->pos = 0;
; 589  : 
; 590  : 					// re-fetch new Paula register values now
; 591  : 					v->length = v->newLength;

  000a9	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR dMixBufferR
  000b0	48 8b fd	 mov	 rdi, rbp
  000b3	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR dMixBufferL
  000ba	48 2b f3	 sub	 rsi, rbx
  000bd	0f 1f 00	 npad	 3
$LL7@mixChannel:

; 537  : 		{
; 538  : 			dataPtr = v->data;
; 539  : 			if (dataPtr == NULL)

  000c0	48 8b 4a b0	 mov	 rcx, QWORD PTR [rdx-80]
  000c4	48 85 c9	 test	 rcx, rcx
  000c7	75 08		 jne	 SHORT $LN11@mixChannel

; 540  : 			{
; 541  : 				dTempSample = 0.0;
; 542  : 				dTempVolume = 0.0;
; 543  : 			}

  000c9	0f 57 d2	 xorps	 xmm2, xmm2
  000cc	0f 57 ed	 xorps	 xmm5, xmm5
  000cf	eb 19		 jmp	 SHORT $LN12@mixChannel
$LN11@mixChannel:

; 544  : 			else
; 545  : 			{
; 546  : 				dTempSample = dataPtr[v->pos] * (1.0 / 128.0);

  000d1	48 63 42 c8	 movsxd	 rax, DWORD PTR [rdx-56]

; 547  : 				dTempVolume = v->dVolume;

  000d5	f2 0f 10 6a d0	 movsd	 xmm5, QWORD PTR [rdx-48]
  000da	0f be 0c 08	 movsx	 ecx, BYTE PTR [rax+rcx]
  000de	66 0f 6e d1	 movd	 xmm2, ecx
  000e2	f3 0f e6 d2	 cvtdq2pd xmm2, xmm2
  000e6	f2 0f 59 d7	 mulsd	 xmm2, xmm7
$LN12@mixChannel:

; 548  : 			}
; 549  : 
; 550  : 			if (dTempSample != bSmp->dLastValue)

  000ea	f2 43 0f 10 a4
	30 48 00 00 00	 movsd	 xmm4, QWORD PTR blep[r8+r14+72]
  000f4	66 0f 2e d4	 ucomisd xmm2, xmm4
  000f8	0f 84 90 00 00
	00		 je	 $LN61@mixChannel

; 551  : 			{
; 552  : 				if (v->dLastDelta > v->dLastPhase)

  000fe	f2 0f 10 1a	 movsd	 xmm3, QWORD PTR [rdx]
  00102	66 0f 2f 5a f0	 comisd	 xmm3, QWORD PTR [rdx-16]
  00107	73 7b		 jae	 SHORT $LN64@mixChannel

; 555  : 					blepAdd(bSmp, v->dLastPhase * v->dLastDeltaMul, bSmp->dLastValue - dTempSample);

  00109	f2 0f 59 5a f8	 mulsd	 xmm3, QWORD PTR [rdx-8]
; File C:\Programming\pt2-clone\src\pt2_blep.c

; 44   : 	i = b->index;

  0010e	4d 8d 9e 00 00
	00 00		 lea	 r11, QWORD PTR blep[r14]
  00115	4d 03 d8	 add	 r11, r8

; 45   : 
; 46   : 	n = BLEP_NS;

  00118	41 b2 08	 mov	 r10b, 8
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 555  : 					blepAdd(bSmp, v->dLastPhase * v->dLastDeltaMul, bSmp->dLastValue - dTempSample);

  0011b	f2 0f 5c e2	 subsd	 xmm4, xmm2
; File C:\Programming\pt2-clone\src\pt2_blep.c

; 38   : 	f = dOffset * BLEP_SP;

  0011f	f2 41 0f 59 d8	 mulsd	 xmm3, xmm8

; 39   : 
; 40   : 	i = (int32_t)f; // get integer part of f

  00124	f2 0f 2c cb	 cvttsd2si ecx, xmm3

; 41   : 	dBlepSrc = (const double *)dBlepData + i + BLEP_OS;

  00128	48 63 c1	 movsxd	 rax, ecx
  0012b	66 0f 6e c1	 movd	 xmm0, ecx

; 44   : 	i = b->index;

  0012f	41 8b 0b	 mov	 ecx, DWORD PTR [r11]
  00132	4d 8d 0c c4	 lea	 r9, QWORD PTR [r12+rax*8]
  00136	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0013a	f2 0f 5c d8	 subsd	 xmm3, xmm0
  0013e	66 90		 npad	 2
$LL21@mixChannel:

; 47   : 	while (n--)
; 48   : 	{
; 49   : 		b->dBuffer[i] += dAmplitude * LERP(dBlepSrc[0], dBlepSrc[1], f);

  00140	f2 41 0f 10 49
	08		 movsd	 xmm1, QWORD PTR [r9+8]
  00146	f2 41 0f 5c 09	 subsd	 xmm1, QWORD PTR [r9]
  0014b	48 63 c1	 movsxd	 rax, ecx

; 50   : 		i = (i + 1) & BLEP_RNS;

  0014e	ff c1		 inc	 ecx
  00150	83 e1 07	 and	 ecx, 7
  00153	f2 0f 59 cb	 mulsd	 xmm1, xmm3
  00157	f2 41 0f 58 09	 addsd	 xmm1, QWORD PTR [r9]

; 51   : 		dBlepSrc += BLEP_SP;

  0015c	49 83 c1 28	 add	 r9, 40			; 00000028H
  00160	f2 0f 59 cc	 mulsd	 xmm1, xmm4
  00164	f2 41 0f 58 4c
	c3 08		 addsd	 xmm1, QWORD PTR [r11+rax*8+8]
  0016b	f2 41 0f 11 4c
	c3 08		 movsd	 QWORD PTR [r11+rax*8+8], xmm1
  00172	41 80 ea 01	 sub	 r10b, 1
  00176	75 c8		 jne	 SHORT $LL21@mixChannel

; 52   : 	}
; 53   : 
; 54   : 	b->samplesLeft = BLEP_NS;

  00178	43 c7 84 30 04
	00 00 00 08 00
	00 00		 mov	 DWORD PTR blep[r8+r14+4], 8
$LN64@mixChannel:
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 558  : 				bSmp->dLastValue = dTempSample;

  00184	f2 43 0f 11 94
	30 48 00 00 00	 movsd	 QWORD PTR blep[r8+r14+72], xmm2
$LN61@mixChannel:

; 559  : 			}
; 560  : 
; 561  : 			if (dTempVolume != bVol->dLastValue)

  0018e	f2 43 0f 10 8c
	30 48 00 00 00	 movsd	 xmm1, QWORD PTR blepVol[r8+r14+72]
  00198	66 0f 2e e9	 ucomisd xmm5, xmm1
  0019c	74 5c		 je	 SHORT $LN65@mixChannel
; File C:\Programming\pt2-clone\src\pt2_blep.c

; 68   : 	i = b->index;

  0019e	47 8b 8c 30 00
	00 00 00	 mov	 r9d, DWORD PTR blepVol[r8+r14]
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 563  : 				blepVolAdd(bVol, bVol->dLastValue - dTempVolume);

  001a6	f2 0f 5c cd	 subsd	 xmm1, xmm5
; File C:\Programming\pt2-clone\src\pt2_blep.c

; 66   : 	dBlepSrc = (const double *)dBlepData + BLEP_OS;

  001aa	4d 8b d4	 mov	 r10, r12

; 69   : 
; 70   : 	n = BLEP_NS;

  001ad	41 b3 08	 mov	 r11b, 8
$LL25@mixChannel:

; 71   : 	while (n--)
; 72   : 	{
; 73   : 		b->dBuffer[i] += dAmplitude * (*dBlepSrc);

  001b0	49 63 c1	 movsxd	 rax, r9d
  001b3	0f 28 c1	 movaps	 xmm0, xmm1
  001b6	f2 41 0f 59 02	 mulsd	 xmm0, QWORD PTR [r10]

; 74   : 		i = (i + 1) & BLEP_RNS;

  001bb	41 ff c1	 inc	 r9d
  001be	41 83 e1 07	 and	 r9d, 7

; 75   : 		dBlepSrc += BLEP_SP;

  001c2	49 83 c2 28	 add	 r10, 40			; 00000028H
  001c6	49 8d 0c c0	 lea	 rcx, QWORD PTR [r8+rax*8]
  001ca	f2 42 0f 58 84
	31 08 00 00 00	 addsd	 xmm0, QWORD PTR blepVol[rcx+r14+8]
  001d4	f2 42 0f 11 84
	31 08 00 00 00	 movsd	 QWORD PTR blepVol[rcx+r14+8], xmm0
  001de	41 80 eb 01	 sub	 r11b, 1
  001e2	75 cc		 jne	 SHORT $LL25@mixChannel
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 564  : 				bVol->dLastValue = dTempVolume;

  001e4	f2 43 0f 11 ac
	30 48 00 00 00	 movsd	 QWORD PTR blepVol[r8+r14+72], xmm5
; File C:\Programming\pt2-clone\src\pt2_blep.c

; 78   : 	b->samplesLeft = BLEP_NS;

  001ee	43 c7 84 30 04
	00 00 00 08 00
	00 00		 mov	 DWORD PTR blepVol[r8+r14+4], 8
$LN65@mixChannel:
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 567  : 			if (bSmp->samplesLeft > 0) dTempSample += blepRun(bSmp);

  001fa	47 39 bc 30 04
	00 00 00	 cmp	 DWORD PTR blep[r8+r14+4], r15d
  00202	7e 2d		 jle	 SHORT $LN62@mixChannel
; File C:\Programming\pt2-clone\src\pt2_blep.c

; 85   : 	fBlepOutput = b->dBuffer[b->index];

  00204	49 8d 8e 00 00
	00 00		 lea	 rcx, QWORD PTR blep[r14]
  0020b	49 03 c8	 add	 rcx, r8
  0020e	48 63 01	 movsxd	 rax, DWORD PTR [rcx]
  00211	f2 0f 10 44 c1
	08		 movsd	 xmm0, QWORD PTR [rcx+rax*8+8]

; 86   : 	b->dBuffer[b->index] = 0.0;

  00217	4c 89 7c c1 08	 mov	 QWORD PTR [rcx+rax*8+8], r15
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 567  : 			if (bSmp->samplesLeft > 0) dTempSample += blepRun(bSmp);

  0021c	f2 0f 58 d0	 addsd	 xmm2, xmm0
; File C:\Programming\pt2-clone\src\pt2_blep.c

; 88   : 	b->index = (b->index + 1) & BLEP_RNS;

  00220	8b 01		 mov	 eax, DWORD PTR [rcx]
  00222	ff c0		 inc	 eax
  00224	83 e0 07	 and	 eax, 7

; 89   : 
; 90   : 	b->samplesLeft--;

  00227	43 ff 8c 30 04
	00 00 00	 dec	 DWORD PTR blep[r8+r14+4]
  0022f	89 01		 mov	 DWORD PTR [rcx], eax
$LN62@mixChannel:
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 568  : 			if (bVol->samplesLeft > 0) dTempVolume += blepRun(bVol);

  00231	47 39 bc 30 04
	00 00 00	 cmp	 DWORD PTR blepVol[r8+r14+4], r15d
  00239	7e 3f		 jle	 SHORT $LN63@mixChannel
; File C:\Programming\pt2-clone\src\pt2_blep.c

; 85   : 	fBlepOutput = b->dBuffer[b->index];

  0023b	4b 63 84 30 00
	00 00 00	 movsxd	 rax, DWORD PTR blepVol[r8+r14]
  00243	49 8d 0c c0	 lea	 rcx, QWORD PTR [r8+rax*8]
  00247	f2 42 0f 10 84
	31 08 00 00 00	 movsd	 xmm0, QWORD PTR blepVol[rcx+r14+8]

; 86   : 	b->dBuffer[b->index] = 0.0;

  00251	4e 89 bc 31 08
	00 00 00	 mov	 QWORD PTR blepVol[rcx+r14+8], r15
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 568  : 			if (bVol->samplesLeft > 0) dTempVolume += blepRun(bVol);

  00259	f2 0f 58 e8	 addsd	 xmm5, xmm0
; File C:\Programming\pt2-clone\src\pt2_blep.c

; 88   : 	b->index = (b->index + 1) & BLEP_RNS;

  0025d	43 8b 84 30 00
	00 00 00	 mov	 eax, DWORD PTR blepVol[r8+r14]
  00265	ff c0		 inc	 eax
  00267	83 e0 07	 and	 eax, 7

; 89   : 
; 90   : 	b->samplesLeft--;

  0026a	43 ff 8c 30 04
	00 00 00	 dec	 DWORD PTR blepVol[r8+r14+4]
  00272	43 89 84 30 00
	00 00 00	 mov	 DWORD PTR blepVol[r8+r14], eax
$LN63@mixChannel:
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 570  : 			dTempSample *= dTempVolume;

  0027a	f2 0f 59 d5	 mulsd	 xmm2, xmm5

; 571  : 
; 572  : 			dMixBufferL[j] += dTempSample * v->dPanL;

  0027e	0f 28 c2	 movaps	 xmm0, xmm2
  00281	f2 0f 59 42 08	 mulsd	 xmm0, QWORD PTR [rdx+8]
  00286	f2 0f 58 04 1e	 addsd	 xmm0, QWORD PTR [rsi+rbx]
  0028b	f2 0f 11 04 1e	 movsd	 QWORD PTR [rsi+rbx], xmm0

; 573  : 			dMixBufferR[j] += dTempSample * v->dPanR;

  00290	f2 0f 59 52 10	 mulsd	 xmm2, QWORD PTR [rdx+16]
  00295	f2 0f 58 13	 addsd	 xmm2, QWORD PTR [rbx]
  00299	f2 0f 11 13	 movsd	 QWORD PTR [rbx], xmm2

; 574  : 
; 575  : 			v->dPhase += v->dDelta;

  0029d	f2 0f 10 4a d8	 movsd	 xmm1, QWORD PTR [rdx-40]
  002a2	0f 28 c1	 movaps	 xmm0, xmm1
  002a5	f2 0f 58 42 e8	 addsd	 xmm0, QWORD PTR [rdx-24]

; 576  : 
; 577  : 			// PAT2SMP needs multi-step, so use while() here (will be only one iteration in normal mixing mode)
; 578  : 			while (v->dPhase >= 1.0)

  002aa	66 0f 2f c6	 comisd	 xmm0, xmm6
  002ae	f2 0f 11 42 e8	 movsd	 QWORD PTR [rdx-24], xmm0
  002b3	72 49		 jb	 SHORT $LN5@mixChannel

; 579  : 			{
; 580  : 				v->dPhase -= 1.0;
; 581  : 
; 582  : 				v->dLastPhase = v->dPhase;
; 583  : 				v->dLastDelta = v->dDelta;
; 584  : 				v->dLastDeltaMul = v->dDeltaMul;

  002b5	f2 0f 10 52 e0	 movsd	 xmm2, QWORD PTR [rdx-32]
  002ba	8b 4a c8	 mov	 ecx, DWORD PTR [rdx-56]
  002bd	44 8b 4a c0	 mov	 r9d, DWORD PTR [rdx-64]
$LL8@mixChannel:

; 585  : 
; 586  : 				if (++v->pos >= v->length)

  002c1	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]
  002c4	f2 0f 5c c6	 subsd	 xmm0, xmm6
  002c8	8b c8		 mov	 ecx, eax
  002ca	41 3b c1	 cmp	 eax, r9d
  002cd	7c 0f		 jl	 SHORT $LN48@mixChannel

; 592  : 					v->data = v->newData;

  002cf	48 8b 42 b8	 mov	 rax, QWORD PTR [rdx-72]
  002d3	41 8b cf	 mov	 ecx, r15d
  002d6	44 8b 4a c4	 mov	 r9d, DWORD PTR [rdx-60]
  002da	48 89 42 b0	 mov	 QWORD PTR [rdx-80], rax
$LN48@mixChannel:

; 576  : 
; 577  : 			// PAT2SMP needs multi-step, so use while() here (will be only one iteration in normal mixing mode)
; 578  : 			while (v->dPhase >= 1.0)

  002de	66 0f 2f c6	 comisd	 xmm0, xmm6
  002e2	73 dd		 jae	 SHORT $LL8@mixChannel
  002e4	f2 0f 11 4a f0	 movsd	 QWORD PTR [rdx-16], xmm1
  002e9	f2 0f 11 02	 movsd	 QWORD PTR [rdx], xmm0
  002ed	f2 0f 11 52 f8	 movsd	 QWORD PTR [rdx-8], xmm2
  002f2	f2 0f 11 42 e8	 movsd	 QWORD PTR [rdx-24], xmm0
  002f7	89 4a c8	 mov	 DWORD PTR [rdx-56], ecx
  002fa	44 89 4a c0	 mov	 DWORD PTR [rdx-64], r9d
$LN5@mixChannel:

; 531  : 			continue;
; 532  : 
; 533  : 		bSmp = &blep[i];
; 534  : 		bVol = &blepVol[i];
; 535  : 
; 536  : 		for (int32_t j = 0; j < numSamples; j++)

  002fe	48 83 c3 08	 add	 rbx, 8
  00302	48 83 ef 01	 sub	 rdi, 1
  00306	0f 85 b4 fd ff
	ff		 jne	 $LL7@mixChannel
$LN2@mixChannel:

; 526  : 
; 527  : 	for (int32_t i = 0; i < AMIGA_VOICES; i++)

  0030c	48 83 c2 70	 add	 rdx, 112		; 00000070H
  00310	49 83 c0 50	 add	 r8, 80			; 00000050H
  00314	49 3b d5	 cmp	 rdx, r13
  00317	0f 8c 77 fd ff
	ff		 jl	 $LL4@mixChannel

; 593  : 				}
; 594  : 			}
; 595  : 		}
; 596  : 	}
; 597  : }

  0031d	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  00322	4c 8d 5c 24 50	 lea	 r11, QWORD PTR [rsp+80]
  00327	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  0032b	49 8b 6b 38	 mov	 rbp, QWORD PTR [r11+56]
  0032f	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  00333	45 0f 28 43 d0	 movaps	 xmm8, XMMWORD PTR [r11-48]
  00338	0f 28 7c 24 30	 movaps	 xmm7, XMMWORD PTR [rsp+48]
  0033d	49 8b e3	 mov	 rsp, r11
  00340	41 5f		 pop	 r15
  00342	41 5e		 pop	 r14
  00344	41 5d		 pop	 r13
  00346	41 5c		 pop	 r12
  00348	5f		 pop	 rdi
  00349	c3		 ret	 0
mixChannels ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT resetDitherSeed
_TEXT	SEGMENT
resetDitherSeed PROC					; COMDAT

; 601  : 	randSeed = INITIAL_DITHER_SEED;

  00000	c7 05 00 00 00
	00 00 50 34 12	 mov	 DWORD PTR randSeed, 305418240 ; 12345000H

; 602  : }

  0000a	c3		 ret	 0
resetDitherSeed ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT random32
_TEXT	SEGMENT
random32 PROC						; COMDAT

; 607  : 	randSeed = randSeed * 134775813 + 1;

  00000	69 05 00 00 00
	00 05 84 08 08	 imul	 eax, DWORD PTR randSeed, 134775813 ; 08088405H
  0000a	ff c0		 inc	 eax
  0000c	89 05 00 00 00
	00		 mov	 DWORD PTR randSeed, eax

; 608  : 	return randSeed;
; 609  : }

  00012	c3		 ret	 0
random32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT processMixedSamplesA1200
_TEXT	SEGMENT
dOut$ = 0
i$ = 64
out$ = 72
processMixedSamplesA1200 PROC				; COMDAT

; 612  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 613  : 	int32_t smp32;
; 614  : 	double dOut[2], dDither;
; 615  : 
; 616  : 	dOut[0] = dMixBufferL[i];

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR dMixBufferL
  0000b	4c 63 c1	 movsxd	 r8, ecx
  0000e	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  00013	0f 29 7c 24 10	 movaps	 XMMWORD PTR [rsp+16], xmm7

; 617  : 	dOut[1] = dMixBufferR[i];
; 618  : 
; 619  : 	// don't process any low-pass filter since the cut-off is around 28-31kHz on A1200
; 620  : 
; 621  : 	// process "LED" filter
; 622  : 	if (filterFlags & FILTER_LED_ENABLED)

  00018	f2 0f 10 3d 00
	00 00 00	 movsd	 xmm7, QWORD PTR __real@3ddb7cdfd9d7bdbb
  00020	f2 42 0f 10 04
	c0		 movsd	 xmm0, QWORD PTR [rax+r8*8]
  00026	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR dMixBufferR
  0002d	f2 0f 11 04 24	 movsd	 QWORD PTR dOut$[rsp], xmm0
  00032	f2 42 0f 10 0c
	c0		 movsd	 xmm1, QWORD PTR [rax+r8*8]
  00038	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR filterFlags
  0003f	f2 0f 11 4c 24
	08		 movsd	 QWORD PTR dOut$[rsp+8], xmm1
  00045	a8 02		 test	 al, 2
  00047	0f 84 bb 00 00
	00		 je	 $LN52@processMix

; 167  : 	filter->dLed[0] += filterC.dLed * (dIn[0] - filter->dLed[0])

  0004d	f2 0f 10 15 00
	00 00 00	 movsd	 xmm2, QWORD PTR filterLED
  00055	f2 0f 10 2d 08
	00 00 00	 movsd	 xmm5, QWORD PTR filterLED+8
  0005d	0f 28 ca	 movaps	 xmm1, xmm2
  00060	f2 0f 10 25 00
	00 00 00	 movsd	 xmm4, QWORD PTR filterLEDC
  00068	f2 0f 5c cd	 subsd	 xmm1, xmm5

; 168  : 		+ filterC.dLedFb * (filter->dLed[0] - filter->dLed[1]) + DENORMAL_OFFSET;
; 169  : 	filter->dLed[1] += filterC.dLed * (filter->dLed[0] - filter->dLed[1]) + DENORMAL_OFFSET;
; 170  : 	dOut[0] = filter->dLed[1];
; 171  : 
; 172  : 	// right channel "LED" filter
; 173  : 	filter->dLed[2] += filterC.dLed * (dIn[1] - filter->dLed[2])

  0006c	f2 0f 10 35 18
	00 00 00	 movsd	 xmm6, QWORD PTR filterLED+24
  00074	f2 0f 10 04 24	 movsd	 xmm0, QWORD PTR dOut$[rsp]
  00079	f2 0f 5c c2	 subsd	 xmm0, xmm2
  0007d	f2 0f 59 0d 08
	00 00 00	 mulsd	 xmm1, QWORD PTR filterLEDC+8
  00085	f2 0f 59 c4	 mulsd	 xmm0, xmm4
  00089	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0008d	f2 0f 10 44 24
	08		 movsd	 xmm0, QWORD PTR dOut$[rsp+8]
  00093	f2 0f 58 cf	 addsd	 xmm1, xmm7
  00097	f2 0f 58 d1	 addsd	 xmm2, xmm1
  0009b	f2 0f 11 15 00
	00 00 00	 movsd	 QWORD PTR filterLED, xmm2
  000a3	f2 0f 5c d5	 subsd	 xmm2, xmm5
  000a7	f2 0f 59 d4	 mulsd	 xmm2, xmm4
  000ab	f2 0f 58 d7	 addsd	 xmm2, xmm7
  000af	f2 0f 58 ea	 addsd	 xmm5, xmm2
  000b3	f2 0f 10 15 10
	00 00 00	 movsd	 xmm2, QWORD PTR filterLED+16
  000bb	0f 28 ca	 movaps	 xmm1, xmm2
  000be	f2 0f 5c c2	 subsd	 xmm0, xmm2
  000c2	f2 0f 5c ce	 subsd	 xmm1, xmm6
  000c6	f2 0f 11 2d 08
	00 00 00	 movsd	 QWORD PTR filterLED+8, xmm5
  000ce	f2 0f 59 c4	 mulsd	 xmm0, xmm4
  000d2	f2 0f 59 0d 08
	00 00 00	 mulsd	 xmm1, QWORD PTR filterLEDC+8
  000da	f2 0f 58 c8	 addsd	 xmm1, xmm0
  000de	f2 0f 58 cf	 addsd	 xmm1, xmm7
  000e2	f2 0f 58 d1	 addsd	 xmm2, xmm1
  000e6	f2 0f 11 15 10
	00 00 00	 movsd	 QWORD PTR filterLED+16, xmm2
  000ee	f2 0f 5c d6	 subsd	 xmm2, xmm6

; 174  : 		+ filterC.dLedFb * (filter->dLed[2] - filter->dLed[3]) + DENORMAL_OFFSET;
; 175  : 	filter->dLed[3] += filterC.dLed * (filter->dLed[2] - filter->dLed[3]) + DENORMAL_OFFSET;

  000f2	f2 0f 59 d4	 mulsd	 xmm2, xmm4
  000f6	f2 0f 58 d7	 addsd	 xmm2, xmm7
  000fa	f2 0f 58 f2	 addsd	 xmm6, xmm2
  000fe	f2 0f 11 35 18
	00 00 00	 movsd	 QWORD PTR filterLED+24, xmm6

; 617  : 	dOut[1] = dMixBufferR[i];
; 618  : 
; 619  : 	// don't process any low-pass filter since the cut-off is around 28-31kHz on A1200
; 620  : 
; 621  : 	// process "LED" filter
; 622  : 	if (filterFlags & FILTER_LED_ENABLED)

  00106	eb 0b		 jmp	 SHORT $LN6@processMix
$LN52@processMix:
  00108	f2 0f 10 74 24
	08		 movsd	 xmm6, QWORD PTR dOut$[rsp+8]
  0010e	f2 0f 10 2c 24	 movsd	 xmm5, QWORD PTR dOut$[rsp]
$LN6@processMix:

; 607  : 	randSeed = randSeed * 134775813 + 1;

  00113	69 0d 00 00 00
	00 05 84 08 08	 imul	 ecx, DWORD PTR randSeed, 134775813 ; 08088405H

; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  0011d	f2 0f 10 25 00
	00 00 00	 movsd	 xmm4, QWORD PTR filterHi
  00125	f2 0f 59 25 18
	00 00 00	 mulsd	 xmm4, QWORD PTR filterHi+24

; 191  : 	dOut[0] = filter->dBuffer[0];
; 192  : 
; 193  : 	// right channel low-pass
; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  0012d	f2 0f 10 1d 08
	00 00 00	 movsd	 xmm3, QWORD PTR filterHi+8
  00135	f2 0f 59 1d 18
	00 00 00	 mulsd	 xmm3, QWORD PTR filterHi+24

; 607  : 	randSeed = randSeed * 134775813 + 1;

  0013d	ff c1		 inc	 ecx

; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  0013f	f2 0f 10 15 10
	00 00 00	 movsd	 xmm2, QWORD PTR filterHi+16
  00147	0f 28 c2	 movaps	 xmm0, xmm2

; 634  : 	dOut[0] += dDither;

  0014a	69 c1 05 84 08
	08		 imul	 eax, ecx, 134775813	; 08088405H

; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  00150	f2 0f 59 c5	 mulsd	 xmm0, xmm5

; 204  : 	dOut[0] = dIn[0] - dLow[0]; // left channel high-pass

  00154	66 0f 14 ee	 unpcklpd xmm5, xmm6
  00158	66 0f 6e c9	 movd	 xmm1, ecx

; 607  : 	randSeed = randSeed * 134775813 + 1;

  0015c	ff c0		 inc	 eax

; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  0015e	f2 0f 59 d6	 mulsd	 xmm2, xmm6

; 607  : 	randSeed = randSeed * 134775813 + 1;

  00162	89 05 00 00 00
	00		 mov	 DWORD PTR randSeed, eax

; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  00168	f2 0f 58 e0	 addsd	 xmm4, xmm0

; 634  : 	dOut[0] += dDither;

  0016c	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1

; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  00170	f2 0f 58 da	 addsd	 xmm3, xmm2

; 630  : 	dOut[1] *= -((INT16_MAX+1.0) / AMIGA_VOICES);
; 631  : 
; 632  : 	// apply 0.5-bit dither
; 633  : 	dDither = random32() * (0.5 / (INT32_MAX+1.0)); // -0.5..0.5

  00174	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3df0000000000000

; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  0017c	f2 0f 58 e7	 addsd	 xmm4, xmm7

; 191  : 	dOut[0] = filter->dBuffer[0];
; 192  : 
; 193  : 	// right channel low-pass
; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  00180	f2 0f 58 df	 addsd	 xmm3, xmm7

; 204  : 	dOut[0] = dIn[0] - dLow[0]; // left channel high-pass

  00184	0f 28 c4	 movaps	 xmm0, xmm4

; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  00187	f2 0f 11 25 00
	00 00 00	 movsd	 QWORD PTR filterHi, xmm4

; 204  : 	dOut[0] = dIn[0] - dLow[0]; // left channel high-pass

  0018f	66 0f 14 c3	 unpcklpd xmm0, xmm3

; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  00193	f2 0f 11 1d 08
	00 00 00	 movsd	 QWORD PTR filterHi+8, xmm3

; 204  : 	dOut[0] = dIn[0] - dLow[0]; // left channel high-pass

  0019b	66 0f 5c e8	 subpd	 xmm5, xmm0
  0019f	66 0f 6e d8	 movd	 xmm3, eax

; 623  : 		lossyIntegratorLED(filterLEDC, &filterLED, dOut, dOut);
; 624  : 
; 625  : 	// process high-pass filter
; 626  : 	lossyIntegratorHighPass(&filterHi, dOut, dOut);
; 627  : 
; 628  : 	// normalize and flip phase (A500/A1200 has an inverted audio signal)
; 629  : 	dOut[0] *= -((INT16_MAX+1.0) / AMIGA_VOICES);

  001a3	66 0f 59 2d 00
	00 00 00	 mulpd	 xmm5, XMMWORD PTR __xmm@c0c0000000000000c0c0000000000000

; 634  : 	dOut[0] += dDither;

  001ab	f3 0f e6 db	 cvtdq2pd xmm3, xmm3
  001af	f2 0f 58 cd	 addsd	 xmm1, xmm5
  001b3	0f 28 c5	 movaps	 xmm0, xmm5
  001b6	f2 0f 59 1d 00
	00 00 00	 mulsd	 xmm3, QWORD PTR __real@3df0000000000000
  001be	66 0f 15 c5	 unpckhpd xmm0, xmm5
  001c2	f2 0f 2c c9	 cvttsd2si ecx, xmm1
  001c6	f2 0f 58 d8	 addsd	 xmm3, xmm0

; 635  : 	dDither = random32() * (0.5 / (INT32_MAX+1.0));
; 636  : 	dOut[1] += dDither;
; 637  : 
; 638  : 	smp32 = (int32_t)dOut[0];
; 639  : 	CLAMP16(smp32);

  001ca	0f bf c1	 movsx	 eax, cx
  001cd	3b c1		 cmp	 eax, ecx
  001cf	74 09		 je	 SHORT $LN3@processMix
  001d1	c1 f9 1f	 sar	 ecx, 31
  001d4	81 f1 ff 7f 00
	00		 xor	 ecx, 32767		; 00007fffH
$LN3@processMix:

; 640  : 	out[0] = (int16_t)smp32;

  001da	66 89 0a	 mov	 WORD PTR [rdx], cx
  001dd	f2 0f 2c cb	 cvttsd2si ecx, xmm3

; 641  : 
; 642  : 	smp32 = (int32_t)dOut[1];
; 643  : 	CLAMP16(smp32);

  001e1	0f bf c1	 movsx	 eax, cx
  001e4	3b c1		 cmp	 eax, ecx
  001e6	74 09		 je	 SHORT $LN51@processMix
  001e8	c1 f9 1f	 sar	 ecx, 31
  001eb	81 f1 ff 7f 00
	00		 xor	 ecx, 32767		; 00007fffH
$LN51@processMix:

; 644  : 	out[1] = (int16_t)smp32;
; 645  : }

  001f1	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  001f6	0f 28 7c 24 10	 movaps	 xmm7, XMMWORD PTR [rsp+16]
  001fb	66 89 4a 02	 mov	 WORD PTR [rdx+2], cx
  001ff	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00203	c3		 ret	 0
processMixedSamplesA1200 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT processMixedSamplesA500
_TEXT	SEGMENT
dOut$ = 0
i$ = 64
out$ = 72
processMixedSamplesA500 PROC				; COMDAT

; 648  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  00004	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR filterLo
  0000c	f2 0f 59 05 18
	00 00 00	 mulsd	 xmm0, QWORD PTR filterLo+24

; 653  : 	dOut[1] = dMixBufferR[i];

  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR dMixBufferR

; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  0001b	f2 0f 10 15 10
	00 00 00	 movsd	 xmm2, QWORD PTR filterLo+16

; 649  : 	int32_t smp32;
; 650  : 	double dOut[2], dDither;
; 651  : 
; 652  : 	dOut[0] = dMixBufferL[i];

  00023	4c 63 c1	 movsxd	 r8, ecx
  00026	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  0002b	0f 29 7c 24 10	 movaps	 XMMWORD PTR [rsp+16], xmm7

; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  00030	f2 0f 10 3d 00
	00 00 00	 movsd	 xmm7, QWORD PTR __real@3ddb7cdfd9d7bdbb

; 653  : 	dOut[1] = dMixBufferR[i];

  00038	f2 42 0f 10 24
	c0		 movsd	 xmm4, QWORD PTR [rax+r8*8]

; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  0003e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR dMixBufferL

; 191  : 	dOut[0] = filter->dBuffer[0];
; 192  : 
; 193  : 	// right channel low-pass
; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  00045	f2 0f 59 25 10
	00 00 00	 mulsd	 xmm4, QWORD PTR filterLo+16
  0004d	f2 42 0f 59 14
	c0		 mulsd	 xmm2, QWORD PTR [rax+r8*8]

; 654  : 
; 655  : 	// process low-pass filter
; 656  : 	lossyIntegrator(&filterLo, dOut, dOut);
; 657  : 
; 658  : 	// process "LED" filter
; 659  : 	if (filterFlags & FILTER_LED_ENABLED)

  00053	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR filterFlags

; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  0005a	f2 0f 58 d0	 addsd	 xmm2, xmm0

; 191  : 	dOut[0] = filter->dBuffer[0];
; 192  : 
; 193  : 	// right channel low-pass
; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  0005e	f2 0f 10 05 08
	00 00 00	 movsd	 xmm0, QWORD PTR filterLo+8
  00066	f2 0f 59 05 18
	00 00 00	 mulsd	 xmm0, QWORD PTR filterLo+24
  0006e	f2 0f 58 d7	 addsd	 xmm2, xmm7
  00072	f2 0f 58 e0	 addsd	 xmm4, xmm0
  00076	f2 0f 11 15 00
	00 00 00	 movsd	 QWORD PTR filterLo, xmm2
  0007e	f2 0f 11 14 24	 movsd	 QWORD PTR dOut$[rsp], xmm2
  00083	f2 0f 58 e7	 addsd	 xmm4, xmm7
  00087	f2 0f 11 25 08
	00 00 00	 movsd	 QWORD PTR filterLo+8, xmm4

; 195  : 	dOut[1] = filter->dBuffer[1];

  0008f	f2 0f 11 64 24
	08		 movsd	 QWORD PTR dOut$[rsp+8], xmm4

; 654  : 
; 655  : 	// process low-pass filter
; 656  : 	lossyIntegrator(&filterLo, dOut, dOut);
; 657  : 
; 658  : 	// process "LED" filter
; 659  : 	if (filterFlags & FILTER_LED_ENABLED)

  00095	a8 02		 test	 al, 2
  00097	0f 84 bb 00 00
	00		 je	 $LN54@processMix

; 167  : 	filter->dLed[0] += filterC.dLed * (dIn[0] - filter->dLed[0])

  0009d	f2 0f 10 15 00
	00 00 00	 movsd	 xmm2, QWORD PTR filterLED
  000a5	f2 0f 10 2d 08
	00 00 00	 movsd	 xmm5, QWORD PTR filterLED+8
  000ad	0f 28 ca	 movaps	 xmm1, xmm2
  000b0	f2 0f 10 25 00
	00 00 00	 movsd	 xmm4, QWORD PTR filterLEDC
  000b8	f2 0f 5c cd	 subsd	 xmm1, xmm5

; 168  : 		+ filterC.dLedFb * (filter->dLed[0] - filter->dLed[1]) + DENORMAL_OFFSET;
; 169  : 	filter->dLed[1] += filterC.dLed * (filter->dLed[0] - filter->dLed[1]) + DENORMAL_OFFSET;
; 170  : 	dOut[0] = filter->dLed[1];
; 171  : 
; 172  : 	// right channel "LED" filter
; 173  : 	filter->dLed[2] += filterC.dLed * (dIn[1] - filter->dLed[2])

  000bc	f2 0f 10 35 18
	00 00 00	 movsd	 xmm6, QWORD PTR filterLED+24
  000c4	f2 0f 10 04 24	 movsd	 xmm0, QWORD PTR dOut$[rsp]
  000c9	f2 0f 5c c2	 subsd	 xmm0, xmm2
  000cd	f2 0f 59 0d 08
	00 00 00	 mulsd	 xmm1, QWORD PTR filterLEDC+8
  000d5	f2 0f 59 c4	 mulsd	 xmm0, xmm4
  000d9	f2 0f 58 c8	 addsd	 xmm1, xmm0
  000dd	f2 0f 10 44 24
	08		 movsd	 xmm0, QWORD PTR dOut$[rsp+8]
  000e3	f2 0f 58 cf	 addsd	 xmm1, xmm7
  000e7	f2 0f 58 d1	 addsd	 xmm2, xmm1
  000eb	f2 0f 11 15 00
	00 00 00	 movsd	 QWORD PTR filterLED, xmm2
  000f3	f2 0f 5c d5	 subsd	 xmm2, xmm5
  000f7	f2 0f 59 d4	 mulsd	 xmm2, xmm4
  000fb	f2 0f 58 d7	 addsd	 xmm2, xmm7
  000ff	f2 0f 58 ea	 addsd	 xmm5, xmm2
  00103	f2 0f 10 15 10
	00 00 00	 movsd	 xmm2, QWORD PTR filterLED+16
  0010b	0f 28 ca	 movaps	 xmm1, xmm2
  0010e	f2 0f 5c c2	 subsd	 xmm0, xmm2
  00112	f2 0f 5c ce	 subsd	 xmm1, xmm6
  00116	f2 0f 11 2d 08
	00 00 00	 movsd	 QWORD PTR filterLED+8, xmm5
  0011e	f2 0f 59 c4	 mulsd	 xmm0, xmm4
  00122	f2 0f 59 0d 08
	00 00 00	 mulsd	 xmm1, QWORD PTR filterLEDC+8
  0012a	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0012e	f2 0f 58 cf	 addsd	 xmm1, xmm7
  00132	f2 0f 58 d1	 addsd	 xmm2, xmm1
  00136	f2 0f 11 15 10
	00 00 00	 movsd	 QWORD PTR filterLED+16, xmm2
  0013e	f2 0f 5c d6	 subsd	 xmm2, xmm6

; 174  : 		+ filterC.dLedFb * (filter->dLed[2] - filter->dLed[3]) + DENORMAL_OFFSET;
; 175  : 	filter->dLed[3] += filterC.dLed * (filter->dLed[2] - filter->dLed[3]) + DENORMAL_OFFSET;

  00142	f2 0f 59 d4	 mulsd	 xmm2, xmm4
  00146	f2 0f 58 d7	 addsd	 xmm2, xmm7
  0014a	f2 0f 58 f2	 addsd	 xmm6, xmm2
  0014e	f2 0f 11 35 18
	00 00 00	 movsd	 QWORD PTR filterLED+24, xmm6

; 654  : 
; 655  : 	// process low-pass filter
; 656  : 	lossyIntegrator(&filterLo, dOut, dOut);
; 657  : 
; 658  : 	// process "LED" filter
; 659  : 	if (filterFlags & FILTER_LED_ENABLED)

  00156	eb 0b		 jmp	 SHORT $LN8@processMix
$LN54@processMix:
  00158	f2 0f 10 74 24
	08		 movsd	 xmm6, QWORD PTR dOut$[rsp+8]
  0015e	f2 0f 10 2c 24	 movsd	 xmm5, QWORD PTR dOut$[rsp]
$LN8@processMix:

; 607  : 	randSeed = randSeed * 134775813 + 1;

  00163	69 0d 00 00 00
	00 05 84 08 08	 imul	 ecx, DWORD PTR randSeed, 134775813 ; 08088405H

; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  0016d	f2 0f 10 25 00
	00 00 00	 movsd	 xmm4, QWORD PTR filterHi
  00175	f2 0f 59 25 18
	00 00 00	 mulsd	 xmm4, QWORD PTR filterHi+24

; 191  : 	dOut[0] = filter->dBuffer[0];
; 192  : 
; 193  : 	// right channel low-pass
; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  0017d	f2 0f 10 1d 08
	00 00 00	 movsd	 xmm3, QWORD PTR filterHi+8
  00185	f2 0f 59 1d 18
	00 00 00	 mulsd	 xmm3, QWORD PTR filterHi+24

; 607  : 	randSeed = randSeed * 134775813 + 1;

  0018d	ff c1		 inc	 ecx

; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  0018f	f2 0f 10 15 10
	00 00 00	 movsd	 xmm2, QWORD PTR filterHi+16
  00197	0f 28 c2	 movaps	 xmm0, xmm2

; 671  : 	dOut[0] += dDither;

  0019a	69 c1 05 84 08
	08		 imul	 eax, ecx, 134775813	; 08088405H

; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  001a0	f2 0f 59 c5	 mulsd	 xmm0, xmm5

; 204  : 	dOut[0] = dIn[0] - dLow[0]; // left channel high-pass

  001a4	66 0f 14 ee	 unpcklpd xmm5, xmm6
  001a8	66 0f 6e c9	 movd	 xmm1, ecx

; 607  : 	randSeed = randSeed * 134775813 + 1;

  001ac	ff c0		 inc	 eax

; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  001ae	f2 0f 59 d6	 mulsd	 xmm2, xmm6

; 607  : 	randSeed = randSeed * 134775813 + 1;

  001b2	89 05 00 00 00
	00		 mov	 DWORD PTR randSeed, eax

; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  001b8	f2 0f 58 e0	 addsd	 xmm4, xmm0

; 671  : 	dOut[0] += dDither;

  001bc	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1

; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  001c0	f2 0f 58 da	 addsd	 xmm3, xmm2

; 667  : 	dOut[1] *= -((INT16_MAX+1.0) / AMIGA_VOICES);
; 668  : 
; 669  : 	// apply 0.5-bit dither
; 670  : 	dDither = random32() * (0.5 / (INT32_MAX+1.0)); // -0.5..0.5

  001c4	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3df0000000000000

; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  001cc	f2 0f 58 e7	 addsd	 xmm4, xmm7

; 191  : 	dOut[0] = filter->dBuffer[0];
; 192  : 
; 193  : 	// right channel low-pass
; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  001d0	f2 0f 58 df	 addsd	 xmm3, xmm7

; 204  : 	dOut[0] = dIn[0] - dLow[0]; // left channel high-pass

  001d4	0f 28 c4	 movaps	 xmm0, xmm4

; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  001d7	f2 0f 11 25 00
	00 00 00	 movsd	 QWORD PTR filterHi, xmm4

; 204  : 	dOut[0] = dIn[0] - dLow[0]; // left channel high-pass

  001df	66 0f 14 c3	 unpcklpd xmm0, xmm3

; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  001e3	f2 0f 11 1d 08
	00 00 00	 movsd	 QWORD PTR filterHi+8, xmm3

; 204  : 	dOut[0] = dIn[0] - dLow[0]; // left channel high-pass

  001eb	66 0f 5c e8	 subpd	 xmm5, xmm0
  001ef	66 0f 6e d8	 movd	 xmm3, eax

; 660  : 		lossyIntegratorLED(filterLEDC, &filterLED, dOut, dOut);
; 661  : 
; 662  : 	// process high-pass filter
; 663  : 	lossyIntegratorHighPass(&filterHi, dOut, dOut);
; 664  : 
; 665  : 	// normalize and flip phase (A500/A1200 has an inverted audio signal)
; 666  : 	dOut[0] *= -((INT16_MAX+1.0) / AMIGA_VOICES);

  001f3	66 0f 59 2d 00
	00 00 00	 mulpd	 xmm5, XMMWORD PTR __xmm@c0c0000000000000c0c0000000000000

; 671  : 	dOut[0] += dDither;

  001fb	f3 0f e6 db	 cvtdq2pd xmm3, xmm3
  001ff	f2 0f 58 cd	 addsd	 xmm1, xmm5
  00203	0f 28 c5	 movaps	 xmm0, xmm5
  00206	f2 0f 59 1d 00
	00 00 00	 mulsd	 xmm3, QWORD PTR __real@3df0000000000000
  0020e	66 0f 15 c5	 unpckhpd xmm0, xmm5
  00212	f2 0f 2c c9	 cvttsd2si ecx, xmm1
  00216	f2 0f 58 d8	 addsd	 xmm3, xmm0

; 672  : 	dDither = random32() * (0.5 / (INT32_MAX+1.0));
; 673  : 	dOut[1] += dDither;
; 674  : 
; 675  : 	smp32 = (int32_t)dOut[0];
; 676  : 	CLAMP16(smp32);

  0021a	0f bf c1	 movsx	 eax, cx
  0021d	3b c1		 cmp	 eax, ecx
  0021f	74 09		 je	 SHORT $LN3@processMix
  00221	c1 f9 1f	 sar	 ecx, 31
  00224	81 f1 ff 7f 00
	00		 xor	 ecx, 32767		; 00007fffH
$LN3@processMix:

; 677  : 	out[0] = (int16_t)smp32;

  0022a	66 89 0a	 mov	 WORD PTR [rdx], cx
  0022d	f2 0f 2c cb	 cvttsd2si ecx, xmm3

; 678  : 
; 679  : 	smp32 = (int32_t)dOut[1];
; 680  : 	CLAMP16(smp32);

  00231	0f bf c1	 movsx	 eax, cx
  00234	3b c1		 cmp	 eax, ecx
  00236	74 09		 je	 SHORT $LN53@processMix
  00238	c1 f9 1f	 sar	 ecx, 31
  0023b	81 f1 ff 7f 00
	00		 xor	 ecx, 32767		; 00007fffH
$LN53@processMix:

; 681  : 	out[1] = (int16_t)smp32;
; 682  : }

  00241	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00246	0f 28 7c 24 10	 movaps	 xmm7, XMMWORD PTR [rsp+16]
  0024b	66 89 4a 02	 mov	 WORD PTR [rdx+2], cx
  0024f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00253	c3		 ret	 0
processMixedSamplesA500 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_helpers.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_helpers.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT outputAudio
_TEXT	SEGMENT
titleTemp$8 = 32
target$ = 240
numSamples$ = 248
outputAudio PROC					; COMDAT

; 685  : {

$LN126:
  00000	48 8b c4	 mov	 rax, rsp
  00003	57		 push	 rdi
  00004	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  0000b	0f 29 70 e8	 movaps	 XMMWORD PTR [rax-24], xmm6
  0000f	48 8b f9	 mov	 rdi, rcx
  00012	0f 29 78 d8	 movaps	 XMMWORD PTR [rax-40], xmm7
  00016	44 0f 29 40 c8	 movaps	 XMMWORD PTR [rax-56], xmm8
  0001b	44 0f 29 48 b8	 movaps	 XMMWORD PTR [rax-72], xmm9
  00020	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00024	48 63 da	 movsxd	 rbx, edx

; 686  : 	int16_t *outStream, out[2];
; 687  : 	int32_t j;
; 688  : 
; 689  : 	mixChannels(numSamples);

  00027	8b cb		 mov	 ecx, ebx
  00029	e8 00 00 00 00	 call	 mixChannels

; 690  : 
; 691  : 	if (editor.isSMPRendering)

  0002e	0f b6 05 3f 00
	00 00		 movzx	 eax, BYTE PTR editor+63
  00035	4c 8b cb	 mov	 r9, rbx
  00038	48 8b 9c 24 f0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+240]
  00040	84 c0		 test	 al, al
  00042	0f 84 8d 02 00
	00		 je	 $LN11@outputAudi

; 692  : 	{
; 693  : 		// render to sample (PAT2SMP)
; 694  : 
; 695  : 		for (j = 0; j < numSamples; j++)

  00048	4d 85 c9	 test	 r9, r9
  0004b	0f 8e 90 06 00
	00		 jle	 $LN9@outputAudi
  00051	f2 0f 10 3d 00
	00 00 00	 movsd	 xmm7, QWORD PTR __real@3ddb7cdfd9d7bdbb
  00059	45 33 c0	 xor	 r8d, r8d
  0005c	f2 44 0f 10 05
	00 00 00 00	 movsd	 xmm8, QWORD PTR __real@3df0000000000000
  00065	f2 44 0f 10 0d
	00 00 00 00	 movsd	 xmm9, QWORD PTR __real@40c0000000000000
  0006e	66 90		 npad	 2
$LL4@outputAudi:

; 616  : 	dOut[0] = dMixBufferL[i];

  00070	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR dMixBufferL
  00077	f2 42 0f 10 2c
	c0		 movsd	 xmm5, QWORD PTR [rax+r8*8]

; 617  : 	dOut[1] = dMixBufferR[i];

  0007d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR dMixBufferR
  00084	f2 42 0f 10 34
	c0		 movsd	 xmm6, QWORD PTR [rax+r8*8]

; 618  : 
; 619  : 	// don't process any low-pass filter since the cut-off is around 28-31kHz on A1200
; 620  : 
; 621  : 	// process "LED" filter
; 622  : 	if (filterFlags & FILTER_LED_ENABLED)

  0008a	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR filterFlags
  00091	a8 02		 test	 al, 2
  00093	0f 84 b4 00 00
	00		 je	 $LN22@outputAudi

; 167  : 	filter->dLed[0] += filterC.dLed * (dIn[0] - filter->dLed[0])

  00099	f2 0f 10 15 00
	00 00 00	 movsd	 xmm2, QWORD PTR filterLED
  000a1	f2 0f 10 25 00
	00 00 00	 movsd	 xmm4, QWORD PTR filterLEDC
  000a9	f2 0f 5c ea	 subsd	 xmm5, xmm2
  000ad	0f 28 c2	 movaps	 xmm0, xmm2
  000b0	0f 28 cd	 movaps	 xmm1, xmm5
  000b3	f2 0f 10 2d 08
	00 00 00	 movsd	 xmm5, QWORD PTR filterLED+8
  000bb	f2 0f 59 cc	 mulsd	 xmm1, xmm4
  000bf	f2 0f 5c c5	 subsd	 xmm0, xmm5
  000c3	f2 0f 59 05 08
	00 00 00	 mulsd	 xmm0, QWORD PTR filterLEDC+8
  000cb	f2 0f 58 c8	 addsd	 xmm1, xmm0
  000cf	f2 0f 58 cf	 addsd	 xmm1, xmm7
  000d3	f2 0f 58 d1	 addsd	 xmm2, xmm1
  000d7	f2 0f 11 15 00
	00 00 00	 movsd	 QWORD PTR filterLED, xmm2
  000df	f2 0f 5c d5	 subsd	 xmm2, xmm5

; 168  : 		+ filterC.dLedFb * (filter->dLed[0] - filter->dLed[1]) + DENORMAL_OFFSET;
; 169  : 	filter->dLed[1] += filterC.dLed * (filter->dLed[0] - filter->dLed[1]) + DENORMAL_OFFSET;

  000e3	f2 0f 59 d4	 mulsd	 xmm2, xmm4
  000e7	f2 0f 58 d7	 addsd	 xmm2, xmm7
  000eb	f2 0f 58 ea	 addsd	 xmm5, xmm2

; 170  : 	dOut[0] = filter->dLed[1];
; 171  : 
; 172  : 	// right channel "LED" filter
; 173  : 	filter->dLed[2] += filterC.dLed * (dIn[1] - filter->dLed[2])

  000ef	f2 0f 10 15 10
	00 00 00	 movsd	 xmm2, QWORD PTR filterLED+16
  000f7	f2 0f 5c f2	 subsd	 xmm6, xmm2
  000fb	0f 28 c2	 movaps	 xmm0, xmm2
  000fe	f2 0f 11 2d 08
	00 00 00	 movsd	 QWORD PTR filterLED+8, xmm5
  00106	0f 28 ce	 movaps	 xmm1, xmm6
  00109	f2 0f 10 35 18
	00 00 00	 movsd	 xmm6, QWORD PTR filterLED+24
  00111	f2 0f 5c c6	 subsd	 xmm0, xmm6
  00115	f2 0f 59 cc	 mulsd	 xmm1, xmm4
  00119	f2 0f 59 05 08
	00 00 00	 mulsd	 xmm0, QWORD PTR filterLEDC+8
  00121	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00125	f2 0f 58 cf	 addsd	 xmm1, xmm7
  00129	f2 0f 58 d1	 addsd	 xmm2, xmm1
  0012d	f2 0f 11 15 10
	00 00 00	 movsd	 QWORD PTR filterLED+16, xmm2
  00135	f2 0f 5c d6	 subsd	 xmm2, xmm6

; 174  : 		+ filterC.dLedFb * (filter->dLed[2] - filter->dLed[3]) + DENORMAL_OFFSET;
; 175  : 	filter->dLed[3] += filterC.dLed * (filter->dLed[2] - filter->dLed[3]) + DENORMAL_OFFSET;

  00139	f2 0f 59 d4	 mulsd	 xmm2, xmm4
  0013d	f2 0f 58 d7	 addsd	 xmm2, xmm7
  00141	f2 0f 58 f2	 addsd	 xmm6, xmm2
  00145	f2 0f 11 35 18
	00 00 00	 movsd	 QWORD PTR filterLED+24, xmm6
$LN22@outputAudi:

; 607  : 	randSeed = randSeed * 134775813 + 1;

  0014d	69 05 00 00 00
	00 05 84 08 08	 imul	 eax, DWORD PTR randSeed, 134775813 ; 08088405H

; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  00157	0f 28 dd	 movaps	 xmm3, xmm5
  0015a	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR filterHi

; 191  : 	dOut[0] = filter->dBuffer[0];
; 192  : 
; 193  : 	// right channel low-pass
; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  00162	0f 28 e6	 movaps	 xmm4, xmm6
  00165	f2 0f 59 05 18
	00 00 00	 mulsd	 xmm0, QWORD PTR filterHi+24
  0016d	0f 57 c9	 xorps	 xmm1, xmm1

; 176  : 	dOut[1] = filter->dLed[3];
; 177  : }
; 178  : 
; 179  : void lossyIntegrator(lossyIntegrator_t *filter, double *dIn, double *dOut)
; 180  : {
; 181  : 	/* Low-pass filter implementation taken from:
; 182  : 	** https://bel.fi/alankila/modguide/interpolate.txt
; 183  : 	**
; 184  : 	** This implementation has a less smooth cutoff curve compared to the old one, so it's
; 185  : 	** maybe not the best. However, I stick to this one because it has a higher gain
; 186  : 	** at the end of the curve (closer to real tested Amiga 500). It also sounds much closer when
; 187  : 	** comparing whitenoise on an A500. */
; 188  : 
; 189  : 	// left channel low-pass
; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  00170	f2 0f 59 1d 10
	00 00 00	 mulsd	 xmm3, QWORD PTR filterHi+16

; 607  : 	randSeed = randSeed * 134775813 + 1;

  00178	ff c0		 inc	 eax

; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  0017a	f2 0f 59 25 10
	00 00 00	 mulsd	 xmm4, QWORD PTR filterHi+16
  00182	f2 0f 58 d8	 addsd	 xmm3, xmm0
  00186	f2 0f 10 05 08
	00 00 00	 movsd	 xmm0, QWORD PTR filterHi+8
  0018e	f2 0f 59 05 18
	00 00 00	 mulsd	 xmm0, QWORD PTR filterHi+24
  00196	f2 0f 58 df	 addsd	 xmm3, xmm7
  0019a	f2 0f 58 e0	 addsd	 xmm4, xmm0
  0019e	0f 57 c0	 xorps	 xmm0, xmm0

; 634  : 	dOut[0] += dDither;

  001a1	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  001a5	69 c0 05 84 08
	08		 imul	 eax, eax, 134775813	; 08088405H

; 204  : 	dOut[0] = dIn[0] - dLow[0]; // left channel high-pass

  001ab	f2 0f 5c eb	 subsd	 xmm5, xmm3

; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  001af	f2 0f 58 e7	 addsd	 xmm4, xmm7
  001b3	f2 0f 11 1d 00
	00 00 00	 movsd	 QWORD PTR filterHi, xmm3

; 633  : 	dDither = random32() * (0.5 / (INT32_MAX+1.0)); // -0.5..0.5

  001bb	f2 41 0f 59 c0	 mulsd	 xmm0, xmm8

; 607  : 	randSeed = randSeed * 134775813 + 1;

  001c0	ff c0		 inc	 eax

; 205  : 	dOut[1] = dIn[1] - dLow[1]; // right channel high-pass

  001c2	f2 41 0f 59 e9	 mulsd	 xmm5, xmm9

; 607  : 	randSeed = randSeed * 134775813 + 1;

  001c7	89 05 00 00 00
	00		 mov	 DWORD PTR randSeed, eax

; 205  : 	dOut[1] = dIn[1] - dLow[1]; // right channel high-pass

  001cd	f2 0f 5c f4	 subsd	 xmm6, xmm4

; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  001d1	f2 0f 11 25 08
	00 00 00	 movsd	 QWORD PTR filterHi+8, xmm4

; 634  : 	dOut[0] += dDither;

  001d9	f2 0f 2a c8	 cvtsi2sd xmm1, eax
  001dd	f2 0f 5c c5	 subsd	 xmm0, xmm5
  001e1	f2 41 0f 59 f1	 mulsd	 xmm6, xmm9
  001e6	f2 41 0f 59 c8	 mulsd	 xmm1, xmm8

; 635  : 	dDither = random32() * (0.5 / (INT32_MAX+1.0));
; 636  : 	dOut[1] += dDither;
; 637  : 
; 638  : 	smp32 = (int32_t)dOut[0];

  001eb	f2 0f 2c d0	 cvttsd2si edx, xmm0
  001ef	f2 0f 5c ce	 subsd	 xmm1, xmm6

; 639  : 	CLAMP16(smp32);

  001f3	0f bf c2	 movsx	 eax, dx
  001f6	3b c2		 cmp	 eax, edx
  001f8	74 09		 je	 SHORT $LN19@outputAudi
  001fa	c1 fa 1f	 sar	 edx, 31
  001fd	81 f2 ff 7f 00
	00		 xor	 edx, 32767		; 00007fffH
$LN19@outputAudi:

; 640  : 	out[0] = (int16_t)smp32;

  00203	f2 0f 2c c9	 cvttsd2si ecx, xmm1

; 641  : 
; 642  : 	smp32 = (int32_t)dOut[1];
; 643  : 	CLAMP16(smp32);

  00207	0f bf c1	 movsx	 eax, cx
  0020a	3b c1		 cmp	 eax, ecx
  0020c	74 09		 je	 SHORT $LN20@outputAudi
  0020e	c1 f9 1f	 sar	 ecx, 31
  00211	81 f1 ff 7f 00
	00		 xor	 ecx, 32767		; 00007fffH
$LN20@outputAudi:

; 644  : 	out[1] = (int16_t)smp32;

  00217	0f bf c1	 movsx	 eax, cx

; 696  : 		{
; 697  : 			processMixedSamplesA1200(j, out);
; 698  : 			editor.pat2SmpBuf[editor.pat2SmpPos++] = (int16_t)((out[0] + out[1]) >> 1); // mix to mono

  0021a	8b 0d 64 24 00
	00		 mov	 ecx, DWORD PTR editor+9316
  00220	0f bf d2	 movsx	 edx, dx
  00223	03 d0		 add	 edx, eax
  00225	48 8b 05 a0 22
	00 00		 mov	 rax, QWORD PTR editor+8864
  0022c	d1 fa		 sar	 edx, 1
  0022e	66 89 14 48	 mov	 WORD PTR [rax+rcx*2], dx
  00232	8b 05 64 24 00
	00		 mov	 eax, DWORD PTR editor+9316
  00238	ff c0		 inc	 eax
  0023a	89 05 64 24 00
	00		 mov	 DWORD PTR editor+9316, eax
  00240	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH

; 699  : 
; 700  : 			if (editor.pat2SmpPos >= MAX_SAMPLE_LEN)

  00245	73 11		 jae	 SHORT $LN85@outputAudi

; 692  : 	{
; 693  : 		// render to sample (PAT2SMP)
; 694  : 
; 695  : 		for (j = 0; j < numSamples; j++)

  00247	49 ff c0	 inc	 r8
  0024a	4d 3b c1	 cmp	 r8, r9
  0024d	0f 8c 1d fe ff
	ff		 jl	 $LL4@outputAudi

; 699  : 
; 700  : 			if (editor.pat2SmpPos >= MAX_SAMPLE_LEN)

  00253	e9 89 04 00 00	 jmp	 $LN9@outputAudi
$LN85@outputAudi:
; File C:\Programming\pt2-clone\src\pt2_helpers.c

; 124  : 		modEntry->modified = true;

  00258	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR modEntry

; 128  : 	if (modEntry->head.moduleTitle[0] != '\0')

  0025f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04HKDAFHLO@1?404@
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 702  : 				editor.smpRenderingDone = true;

  00266	c6 05 40 00 00
	00 01		 mov	 BYTE PTR editor+64, 1
; File C:\Programming\pt2-clone\src\pt2_helpers.c

; 128  : 	if (modEntry->head.moduleTitle[0] != '\0')

  0026d	4c 8d 48 24	 lea	 r9, QWORD PTR [rax+36]
  00271	48 8d 4c 24 20	 lea	 rcx, QWORD PTR titleTemp$8[rsp]
  00276	c6 40 11 01	 mov	 BYTE PTR [rax+17], 1
  0027a	41 80 39 00	 cmp	 BYTE PTR [r9], 0
  0027e	74 20		 je	 SHORT $LN35@outputAudi

; 129  : 	{
; 130  : 		if (modified)
; 131  : 		{
; 132  : 			if (ptConfig.modDot)

  00280	80 3d 1a 00 00
	00 00		 cmp	 BYTE PTR ptConfig+26, 0
  00287	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CM@EDIGGKIK@ProTracker?52?5clone?5v?$CFs?5?9?5?$CC?$CFs?4mo@
  0028e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@DHKCJFPA@ProTracker?52?5clone?5v?$CFs?5?9?5?$CCmod?4?$CF@
  00295	48 0f 44 d0	 cmove	 rdx, rax

; 133  : 				sprintf(titleTemp, "ProTracker 2 clone v%s - \"mod.%s\" (unsaved)", PROG_VER_STR, modEntry->head.moduleTitle);
; 134  : 			else
; 135  : 				sprintf(titleTemp, "ProTracker 2 clone v%s - \"%s.mod\" (unsaved)", PROG_VER_STR, modEntry->head.moduleTitle);
; 136  : 		}
; 137  : 		else
; 138  : 		{
; 139  : 			if (ptConfig.modDot)
; 140  : 				sprintf(titleTemp, "ProTracker 2 clone v%s - \"mod.%s\"", PROG_VER_STR, modEntry->head.moduleTitle);
; 141  : 			else
; 142  : 				sprintf(titleTemp, "ProTracker 2 clone v%s - \"%s.mod\"", PROG_VER_STR, modEntry->head.moduleTitle);
; 143  : 		}
; 144  : 	}

  00299	e8 00 00 00 00	 call	 sprintf
  0029e	eb 1e		 jmp	 SHORT $LN48@outputAudi
$LN35@outputAudi:

; 145  : 	else
; 146  : 	{
; 147  : 		if (modified)
; 148  : 		{
; 149  : 			if (ptConfig.modDot)

  002a0	80 3d 1a 00 00
	00 00		 cmp	 BYTE PTR ptConfig+26, 0
  002a7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DC@JKDFPOLK@ProTracker?52?5clone?5v?$CFs?5?9?5?$CCuntit@
  002ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@NGLNBGC@ProTracker?52?5clone?5v?$CFs?5?9?5?$CCmod?4u@
  002b5	48 0f 44 d0	 cmove	 rdx, rax

; 150  : 				sprintf(titleTemp, "ProTracker 2 clone v%s - \"mod.untitled\" (unsaved)", PROG_VER_STR);
; 151  : 			else
; 152  : 				sprintf(titleTemp, "ProTracker 2 clone v%s - \"untitled.mod\" (unsaved)", PROG_VER_STR);
; 153  : 		}

  002b9	e8 00 00 00 00	 call	 sprintf
$LN48@outputAudi:

; 154  : 		else
; 155  : 		{
; 156  : 			if (ptConfig.modDot)
; 157  : 				sprintf(titleTemp, "ProTracker 2 clone v%s - \"mod.untitled\"", PROG_VER_STR);
; 158  : 			else
; 159  : 				sprintf(titleTemp, "ProTracker 2 clone v%s - \"untitled.mod\"", PROG_VER_STR);
; 160  : 		}
; 161  : 	}
; 162  : 
; 163  : 	 SDL_SetWindowTitle(window, titleTemp);

  002be	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR window
  002c5	48 8d 54 24 20	 lea	 rdx, QWORD PTR titleTemp$8[rsp]
  002ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SDL_SetWindowTitle
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 707  : 	}

  002d0	e9 0c 04 00 00	 jmp	 $LN9@outputAudi
$LN11@outputAudi:

; 708  : 	else
; 709  : 	{
; 710  : 		// render to stream
; 711  : 
; 712  : 		outStream = target;
; 713  : 		if (filterFlags & FILTER_A500)

  002d5	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR filterFlags
  002dc	24 01		 and	 al, 1

; 714  : 		{
; 715  : 			for (j = 0; j < numSamples; j++)

  002de	4d 85 c9	 test	 r9, r9
  002e1	0f 8e fa 03 00
	00		 jle	 $LN9@outputAudi

; 708  : 	else
; 709  : 	{
; 710  : 		// render to stream
; 711  : 
; 712  : 		outStream = target;
; 713  : 		if (filterFlags & FILTER_A500)

  002e7	f2 0f 10 3d 00
	00 00 00	 movsd	 xmm7, QWORD PTR __real@3ddb7cdfd9d7bdbb
  002ef	45 33 c0	 xor	 r8d, r8d
  002f2	f2 44 0f 10 05
	00 00 00 00	 movsd	 xmm8, QWORD PTR __real@3df0000000000000
  002fb	f2 44 0f 10 0d
	00 00 00 00	 movsd	 xmm9, QWORD PTR __real@40c0000000000000
  00304	84 c0		 test	 al, al
  00306	0f 84 17 02 00
	00		 je	 $LL10@outputAudi
  0030c	0f 1f 40 00	 npad	 4
$LL7@outputAudi:

; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  00310	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR filterLo
  00318	f2 0f 59 05 18
	00 00 00	 mulsd	 xmm0, QWORD PTR filterLo+24

; 653  : 	dOut[1] = dMixBufferR[i];

  00320	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR dMixBufferR

; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  00327	f2 0f 10 2d 10
	00 00 00	 movsd	 xmm5, QWORD PTR filterLo+16

; 653  : 	dOut[1] = dMixBufferR[i];

  0032f	f2 42 0f 10 34
	c0		 movsd	 xmm6, QWORD PTR [rax+r8*8]

; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  00335	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR dMixBufferL

; 191  : 	dOut[0] = filter->dBuffer[0];
; 192  : 
; 193  : 	// right channel low-pass
; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  0033c	f2 0f 59 35 10
	00 00 00	 mulsd	 xmm6, QWORD PTR filterLo+16
  00344	f2 42 0f 59 2c
	c0		 mulsd	 xmm5, QWORD PTR [rax+r8*8]

; 659  : 	if (filterFlags & FILTER_LED_ENABLED)

  0034a	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR filterFlags

; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  00351	f2 0f 58 e8	 addsd	 xmm5, xmm0

; 191  : 	dOut[0] = filter->dBuffer[0];
; 192  : 
; 193  : 	// right channel low-pass
; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  00355	f2 0f 10 05 08
	00 00 00	 movsd	 xmm0, QWORD PTR filterLo+8
  0035d	f2 0f 59 05 18
	00 00 00	 mulsd	 xmm0, QWORD PTR filterLo+24
  00365	f2 0f 58 ef	 addsd	 xmm5, xmm7
  00369	f2 0f 58 f0	 addsd	 xmm6, xmm0
  0036d	f2 0f 11 2d 00
	00 00 00	 movsd	 QWORD PTR filterLo, xmm5
  00375	f2 0f 58 f7	 addsd	 xmm6, xmm7
  00379	f2 0f 11 35 08
	00 00 00	 movsd	 QWORD PTR filterLo+8, xmm6

; 659  : 	if (filterFlags & FILTER_LED_ENABLED)

  00381	a8 02		 test	 al, 2
  00383	0f 84 b4 00 00
	00		 je	 $LN57@outputAudi

; 167  : 	filter->dLed[0] += filterC.dLed * (dIn[0] - filter->dLed[0])

  00389	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR filterLED
  00391	f2 0f 10 25 00
	00 00 00	 movsd	 xmm4, QWORD PTR filterLEDC
  00399	f2 0f 5c eb	 subsd	 xmm5, xmm3
  0039d	0f 28 c3	 movaps	 xmm0, xmm3
  003a0	0f 28 cd	 movaps	 xmm1, xmm5
  003a3	f2 0f 10 2d 08
	00 00 00	 movsd	 xmm5, QWORD PTR filterLED+8
  003ab	f2 0f 5c c5	 subsd	 xmm0, xmm5
  003af	f2 0f 59 cc	 mulsd	 xmm1, xmm4
  003b3	f2 0f 59 05 08
	00 00 00	 mulsd	 xmm0, QWORD PTR filterLEDC+8
  003bb	f2 0f 58 c8	 addsd	 xmm1, xmm0
  003bf	f2 0f 58 cf	 addsd	 xmm1, xmm7
  003c3	f2 0f 58 d9	 addsd	 xmm3, xmm1

; 170  : 	dOut[0] = filter->dLed[1];
; 171  : 
; 172  : 	// right channel "LED" filter
; 173  : 	filter->dLed[2] += filterC.dLed * (dIn[1] - filter->dLed[2])

  003c7	f2 0f 10 0d 10
	00 00 00	 movsd	 xmm1, QWORD PTR filterLED+16
  003cf	f2 0f 5c f1	 subsd	 xmm6, xmm1
  003d3	0f 28 c1	 movaps	 xmm0, xmm1
  003d6	f2 0f 11 1d 00
	00 00 00	 movsd	 QWORD PTR filterLED, xmm3
  003de	f2 0f 5c dd	 subsd	 xmm3, xmm5
  003e2	f2 0f 59 f4	 mulsd	 xmm6, xmm4
  003e6	f2 0f 59 dc	 mulsd	 xmm3, xmm4
  003ea	f2 0f 58 df	 addsd	 xmm3, xmm7
  003ee	f2 0f 58 eb	 addsd	 xmm5, xmm3
  003f2	f2 0f 10 1d 18
	00 00 00	 movsd	 xmm3, QWORD PTR filterLED+24
  003fa	f2 0f 5c c3	 subsd	 xmm0, xmm3
  003fe	f2 0f 11 2d 08
	00 00 00	 movsd	 QWORD PTR filterLED+8, xmm5
  00406	f2 0f 59 05 08
	00 00 00	 mulsd	 xmm0, QWORD PTR filterLEDC+8
  0040e	f2 0f 58 c6	 addsd	 xmm0, xmm6
  00412	f2 0f 58 c7	 addsd	 xmm0, xmm7
  00416	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0041a	f2 0f 11 0d 10
	00 00 00	 movsd	 QWORD PTR filterLED+16, xmm1
  00422	f2 0f 5c cb	 subsd	 xmm1, xmm3

; 174  : 		+ filterC.dLedFb * (filter->dLed[2] - filter->dLed[3]) + DENORMAL_OFFSET;
; 175  : 	filter->dLed[3] += filterC.dLed * (filter->dLed[2] - filter->dLed[3]) + DENORMAL_OFFSET;

  00426	f2 0f 59 cc	 mulsd	 xmm1, xmm4
  0042a	f2 0f 58 cf	 addsd	 xmm1, xmm7
  0042e	f2 0f 58 d9	 addsd	 xmm3, xmm1
  00432	f2 0f 11 1d 18
	00 00 00	 movsd	 QWORD PTR filterLED+24, xmm3
  0043a	0f 28 f3	 movaps	 xmm6, xmm3
$LN57@outputAudi:

; 607  : 	randSeed = randSeed * 134775813 + 1;

  0043d	69 05 00 00 00
	00 05 84 08 08	 imul	 eax, DWORD PTR randSeed, 134775813 ; 08088405H

; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  00447	0f 28 dd	 movaps	 xmm3, xmm5
  0044a	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR filterHi

; 191  : 	dOut[0] = filter->dBuffer[0];
; 192  : 
; 193  : 	// right channel low-pass
; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  00452	0f 28 e6	 movaps	 xmm4, xmm6
  00455	f2 0f 59 05 18
	00 00 00	 mulsd	 xmm0, QWORD PTR filterHi+24
  0045d	0f 57 c9	 xorps	 xmm1, xmm1

; 176  : 	dOut[1] = filter->dLed[3];
; 177  : }
; 178  : 
; 179  : void lossyIntegrator(lossyIntegrator_t *filter, double *dIn, double *dOut)
; 180  : {
; 181  : 	/* Low-pass filter implementation taken from:
; 182  : 	** https://bel.fi/alankila/modguide/interpolate.txt
; 183  : 	**
; 184  : 	** This implementation has a less smooth cutoff curve compared to the old one, so it's
; 185  : 	** maybe not the best. However, I stick to this one because it has a higher gain
; 186  : 	** at the end of the curve (closer to real tested Amiga 500). It also sounds much closer when
; 187  : 	** comparing whitenoise on an A500. */
; 188  : 
; 189  : 	// left channel low-pass
; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  00460	f2 0f 59 1d 10
	00 00 00	 mulsd	 xmm3, QWORD PTR filterHi+16

; 607  : 	randSeed = randSeed * 134775813 + 1;

  00468	ff c0		 inc	 eax

; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  0046a	f2 0f 59 25 10
	00 00 00	 mulsd	 xmm4, QWORD PTR filterHi+16
  00472	f2 0f 58 d8	 addsd	 xmm3, xmm0
  00476	f2 0f 10 05 08
	00 00 00	 movsd	 xmm0, QWORD PTR filterHi+8
  0047e	f2 0f 59 05 18
	00 00 00	 mulsd	 xmm0, QWORD PTR filterHi+24
  00486	f2 0f 58 df	 addsd	 xmm3, xmm7
  0048a	f2 0f 58 e0	 addsd	 xmm4, xmm0
  0048e	0f 57 c0	 xorps	 xmm0, xmm0

; 671  : 	dOut[0] += dDither;

  00491	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  00495	69 c0 05 84 08
	08		 imul	 eax, eax, 134775813	; 08088405H

; 204  : 	dOut[0] = dIn[0] - dLow[0]; // left channel high-pass

  0049b	f2 0f 5c eb	 subsd	 xmm5, xmm3

; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  0049f	f2 0f 58 e7	 addsd	 xmm4, xmm7
  004a3	f2 0f 11 1d 00
	00 00 00	 movsd	 QWORD PTR filterHi, xmm3

; 670  : 	dDither = random32() * (0.5 / (INT32_MAX+1.0)); // -0.5..0.5

  004ab	f2 41 0f 59 c0	 mulsd	 xmm0, xmm8

; 607  : 	randSeed = randSeed * 134775813 + 1;

  004b0	ff c0		 inc	 eax

; 205  : 	dOut[1] = dIn[1] - dLow[1]; // right channel high-pass

  004b2	f2 41 0f 59 e9	 mulsd	 xmm5, xmm9

; 607  : 	randSeed = randSeed * 134775813 + 1;

  004b7	89 05 00 00 00
	00		 mov	 DWORD PTR randSeed, eax

; 205  : 	dOut[1] = dIn[1] - dLow[1]; // right channel high-pass

  004bd	f2 0f 5c f4	 subsd	 xmm6, xmm4

; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  004c1	f2 0f 11 25 08
	00 00 00	 movsd	 QWORD PTR filterHi+8, xmm4

; 671  : 	dOut[0] += dDither;

  004c9	f2 0f 2a c8	 cvtsi2sd xmm1, eax
  004cd	f2 0f 5c c5	 subsd	 xmm0, xmm5
  004d1	f2 41 0f 59 f1	 mulsd	 xmm6, xmm9
  004d6	f2 41 0f 59 c8	 mulsd	 xmm1, xmm8

; 672  : 	dDither = random32() * (0.5 / (INT32_MAX+1.0));
; 673  : 	dOut[1] += dDither;
; 674  : 
; 675  : 	smp32 = (int32_t)dOut[0];

  004db	f2 0f 2c d0	 cvttsd2si edx, xmm0
  004df	f2 0f 5c ce	 subsd	 xmm1, xmm6

; 676  : 	CLAMP16(smp32);

  004e3	0f bf c2	 movsx	 eax, dx
  004e6	3b c2		 cmp	 eax, edx
  004e8	74 09		 je	 SHORT $LN52@outputAudi
  004ea	c1 fa 1f	 sar	 edx, 31
  004ed	81 f2 ff 7f 00
	00		 xor	 edx, 32767		; 00007fffH
$LN52@outputAudi:

; 677  : 	out[0] = (int16_t)smp32;

  004f3	f2 0f 2c c9	 cvttsd2si ecx, xmm1

; 678  : 
; 679  : 	smp32 = (int32_t)dOut[1];
; 680  : 	CLAMP16(smp32);

  004f7	0f bf c1	 movsx	 eax, cx
  004fa	3b c1		 cmp	 eax, ecx
  004fc	74 09		 je	 SHORT $LN53@outputAudi
  004fe	c1 f9 1f	 sar	 ecx, 31
  00501	81 f1 ff 7f 00
	00		 xor	 ecx, 32767		; 00007fffH
$LN53@outputAudi:

; 716  : 			{
; 717  : 				processMixedSamplesA500(j, out);
; 718  : 				*outStream++ = out[0];

  00507	66 89 17	 mov	 WORD PTR [rdi], dx
  0050a	49 ff c0	 inc	 r8

; 719  : 				*outStream++ = out[1];

  0050d	66 89 4f 02	 mov	 WORD PTR [rdi+2], cx
  00511	48 83 c7 04	 add	 rdi, 4
  00515	4d 3b c1	 cmp	 r8, r9
  00518	0f 8c f2 fd ff
	ff		 jl	 $LL7@outputAudi

; 720  : 			}
; 721  : 		}

  0051e	e9 be 01 00 00	 jmp	 $LN9@outputAudi
$LL10@outputAudi:

; 616  : 	dOut[0] = dMixBufferL[i];

  00523	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR dMixBufferL
  0052a	f2 42 0f 10 2c
	c0		 movsd	 xmm5, QWORD PTR [rax+r8*8]

; 617  : 	dOut[1] = dMixBufferR[i];

  00530	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR dMixBufferR
  00537	f2 42 0f 10 34
	c0		 movsd	 xmm6, QWORD PTR [rax+r8*8]

; 618  : 
; 619  : 	// don't process any low-pass filter since the cut-off is around 28-31kHz on A1200
; 620  : 
; 621  : 	// process "LED" filter
; 622  : 	if (filterFlags & FILTER_LED_ENABLED)

  0053d	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR filterFlags
  00544	a8 02		 test	 al, 2
  00546	0f 84 b4 00 00
	00		 je	 $LN72@outputAudi

; 167  : 	filter->dLed[0] += filterC.dLed * (dIn[0] - filter->dLed[0])

  0054c	f2 0f 10 15 00
	00 00 00	 movsd	 xmm2, QWORD PTR filterLED
  00554	f2 0f 10 25 00
	00 00 00	 movsd	 xmm4, QWORD PTR filterLEDC
  0055c	f2 0f 5c ea	 subsd	 xmm5, xmm2
  00560	0f 28 c2	 movaps	 xmm0, xmm2
  00563	0f 28 cd	 movaps	 xmm1, xmm5
  00566	f2 0f 10 2d 08
	00 00 00	 movsd	 xmm5, QWORD PTR filterLED+8
  0056e	f2 0f 59 cc	 mulsd	 xmm1, xmm4
  00572	f2 0f 5c c5	 subsd	 xmm0, xmm5
  00576	f2 0f 59 05 08
	00 00 00	 mulsd	 xmm0, QWORD PTR filterLEDC+8
  0057e	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00582	f2 0f 58 cf	 addsd	 xmm1, xmm7
  00586	f2 0f 58 d1	 addsd	 xmm2, xmm1
  0058a	f2 0f 11 15 00
	00 00 00	 movsd	 QWORD PTR filterLED, xmm2
  00592	f2 0f 5c d5	 subsd	 xmm2, xmm5

; 168  : 		+ filterC.dLedFb * (filter->dLed[0] - filter->dLed[1]) + DENORMAL_OFFSET;
; 169  : 	filter->dLed[1] += filterC.dLed * (filter->dLed[0] - filter->dLed[1]) + DENORMAL_OFFSET;

  00596	f2 0f 59 d4	 mulsd	 xmm2, xmm4
  0059a	f2 0f 58 d7	 addsd	 xmm2, xmm7
  0059e	f2 0f 58 ea	 addsd	 xmm5, xmm2

; 170  : 	dOut[0] = filter->dLed[1];
; 171  : 
; 172  : 	// right channel "LED" filter
; 173  : 	filter->dLed[2] += filterC.dLed * (dIn[1] - filter->dLed[2])

  005a2	f2 0f 10 15 10
	00 00 00	 movsd	 xmm2, QWORD PTR filterLED+16
  005aa	f2 0f 5c f2	 subsd	 xmm6, xmm2
  005ae	0f 28 c2	 movaps	 xmm0, xmm2
  005b1	f2 0f 11 2d 08
	00 00 00	 movsd	 QWORD PTR filterLED+8, xmm5
  005b9	0f 28 ce	 movaps	 xmm1, xmm6
  005bc	f2 0f 10 35 18
	00 00 00	 movsd	 xmm6, QWORD PTR filterLED+24
  005c4	f2 0f 5c c6	 subsd	 xmm0, xmm6
  005c8	f2 0f 59 cc	 mulsd	 xmm1, xmm4
  005cc	f2 0f 59 05 08
	00 00 00	 mulsd	 xmm0, QWORD PTR filterLEDC+8
  005d4	f2 0f 58 c8	 addsd	 xmm1, xmm0
  005d8	f2 0f 58 cf	 addsd	 xmm1, xmm7
  005dc	f2 0f 58 d1	 addsd	 xmm2, xmm1
  005e0	f2 0f 11 15 10
	00 00 00	 movsd	 QWORD PTR filterLED+16, xmm2
  005e8	f2 0f 5c d6	 subsd	 xmm2, xmm6

; 174  : 		+ filterC.dLedFb * (filter->dLed[2] - filter->dLed[3]) + DENORMAL_OFFSET;
; 175  : 	filter->dLed[3] += filterC.dLed * (filter->dLed[2] - filter->dLed[3]) + DENORMAL_OFFSET;

  005ec	f2 0f 59 d4	 mulsd	 xmm2, xmm4
  005f0	f2 0f 58 d7	 addsd	 xmm2, xmm7
  005f4	f2 0f 58 f2	 addsd	 xmm6, xmm2
  005f8	f2 0f 11 35 18
	00 00 00	 movsd	 QWORD PTR filterLED+24, xmm6
$LN72@outputAudi:

; 607  : 	randSeed = randSeed * 134775813 + 1;

  00600	69 05 00 00 00
	00 05 84 08 08	 imul	 eax, DWORD PTR randSeed, 134775813 ; 08088405H

; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  0060a	0f 28 dd	 movaps	 xmm3, xmm5
  0060d	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR filterHi

; 191  : 	dOut[0] = filter->dBuffer[0];
; 192  : 
; 193  : 	// right channel low-pass
; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  00615	0f 28 e6	 movaps	 xmm4, xmm6
  00618	f2 0f 59 05 18
	00 00 00	 mulsd	 xmm0, QWORD PTR filterHi+24
  00620	0f 57 c9	 xorps	 xmm1, xmm1

; 176  : 	dOut[1] = filter->dLed[3];
; 177  : }
; 178  : 
; 179  : void lossyIntegrator(lossyIntegrator_t *filter, double *dIn, double *dOut)
; 180  : {
; 181  : 	/* Low-pass filter implementation taken from:
; 182  : 	** https://bel.fi/alankila/modguide/interpolate.txt
; 183  : 	**
; 184  : 	** This implementation has a less smooth cutoff curve compared to the old one, so it's
; 185  : 	** maybe not the best. However, I stick to this one because it has a higher gain
; 186  : 	** at the end of the curve (closer to real tested Amiga 500). It also sounds much closer when
; 187  : 	** comparing whitenoise on an A500. */
; 188  : 
; 189  : 	// left channel low-pass
; 190  : 	filter->dBuffer[0] = (filter->b0 * dIn[0]) + (filter->b1 * filter->dBuffer[0]) + DENORMAL_OFFSET;

  00623	f2 0f 59 1d 10
	00 00 00	 mulsd	 xmm3, QWORD PTR filterHi+16

; 607  : 	randSeed = randSeed * 134775813 + 1;

  0062b	ff c0		 inc	 eax

; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  0062d	f2 0f 59 25 10
	00 00 00	 mulsd	 xmm4, QWORD PTR filterHi+16
  00635	f2 0f 58 d8	 addsd	 xmm3, xmm0
  00639	f2 0f 10 05 08
	00 00 00	 movsd	 xmm0, QWORD PTR filterHi+8
  00641	f2 0f 59 05 18
	00 00 00	 mulsd	 xmm0, QWORD PTR filterHi+24
  00649	f2 0f 58 df	 addsd	 xmm3, xmm7
  0064d	f2 0f 58 e0	 addsd	 xmm4, xmm0
  00651	0f 57 c0	 xorps	 xmm0, xmm0

; 634  : 	dOut[0] += dDither;

  00654	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  00658	69 c0 05 84 08
	08		 imul	 eax, eax, 134775813	; 08088405H

; 204  : 	dOut[0] = dIn[0] - dLow[0]; // left channel high-pass

  0065e	f2 0f 5c eb	 subsd	 xmm5, xmm3

; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  00662	f2 0f 58 e7	 addsd	 xmm4, xmm7
  00666	f2 0f 11 1d 00
	00 00 00	 movsd	 QWORD PTR filterHi, xmm3

; 633  : 	dDither = random32() * (0.5 / (INT32_MAX+1.0)); // -0.5..0.5

  0066e	f2 41 0f 59 c0	 mulsd	 xmm0, xmm8

; 607  : 	randSeed = randSeed * 134775813 + 1;

  00673	ff c0		 inc	 eax

; 205  : 	dOut[1] = dIn[1] - dLow[1]; // right channel high-pass

  00675	f2 41 0f 59 e9	 mulsd	 xmm5, xmm9

; 607  : 	randSeed = randSeed * 134775813 + 1;

  0067a	89 05 00 00 00
	00		 mov	 DWORD PTR randSeed, eax

; 205  : 	dOut[1] = dIn[1] - dLow[1]; // right channel high-pass

  00680	f2 0f 5c f4	 subsd	 xmm6, xmm4

; 194  : 	filter->dBuffer[1] = (filter->b0 * dIn[1]) + (filter->b1 * filter->dBuffer[1]) + DENORMAL_OFFSET;

  00684	f2 0f 11 25 08
	00 00 00	 movsd	 QWORD PTR filterHi+8, xmm4

; 634  : 	dOut[0] += dDither;

  0068c	f2 0f 2a c8	 cvtsi2sd xmm1, eax
  00690	f2 0f 5c c5	 subsd	 xmm0, xmm5
  00694	f2 41 0f 59 f1	 mulsd	 xmm6, xmm9
  00699	f2 41 0f 59 c8	 mulsd	 xmm1, xmm8

; 635  : 	dDither = random32() * (0.5 / (INT32_MAX+1.0));
; 636  : 	dOut[1] += dDither;
; 637  : 
; 638  : 	smp32 = (int32_t)dOut[0];

  0069e	f2 0f 2c d0	 cvttsd2si edx, xmm0
  006a2	f2 0f 5c ce	 subsd	 xmm1, xmm6

; 639  : 	CLAMP16(smp32);

  006a6	0f bf c2	 movsx	 eax, dx
  006a9	3b c2		 cmp	 eax, edx
  006ab	74 09		 je	 SHORT $LN69@outputAudi
  006ad	c1 fa 1f	 sar	 edx, 31
  006b0	81 f2 ff 7f 00
	00		 xor	 edx, 32767		; 00007fffH
$LN69@outputAudi:

; 640  : 	out[0] = (int16_t)smp32;

  006b6	f2 0f 2c c9	 cvttsd2si ecx, xmm1

; 641  : 
; 642  : 	smp32 = (int32_t)dOut[1];
; 643  : 	CLAMP16(smp32);

  006ba	0f bf c1	 movsx	 eax, cx
  006bd	3b c1		 cmp	 eax, ecx
  006bf	74 09		 je	 SHORT $LN70@outputAudi
  006c1	c1 f9 1f	 sar	 ecx, 31
  006c4	81 f1 ff 7f 00
	00		 xor	 ecx, 32767		; 00007fffH
$LN70@outputAudi:

; 722  : 		else
; 723  : 		{
; 724  : 			for (j = 0; j < numSamples; j++)
; 725  : 			{
; 726  : 				processMixedSamplesA1200(j, out);
; 727  : 				*outStream++ = out[0];

  006ca	66 89 17	 mov	 WORD PTR [rdi], dx
  006cd	49 ff c0	 inc	 r8

; 728  : 				*outStream++ = out[1];

  006d0	66 89 4f 02	 mov	 WORD PTR [rdi+2], cx
  006d4	48 83 c7 04	 add	 rdi, 4
  006d8	4d 3b c1	 cmp	 r8, r9
  006db	0f 8c 42 fe ff
	ff		 jl	 $LL10@outputAudi
$LN9@outputAudi:

; 729  : 			}
; 730  : 		}
; 731  : 	}
; 732  : }

  006e1	4c 8d 9c 24 e0
	00 00 00	 lea	 r11, QWORD PTR [rsp+224]
  006e9	41 0f 28 73 f0	 movaps	 xmm6, XMMWORD PTR [r11-16]
  006ee	41 0f 28 7b e0	 movaps	 xmm7, XMMWORD PTR [r11-32]
  006f3	45 0f 28 43 d0	 movaps	 xmm8, XMMWORD PTR [r11-48]
  006f8	45 0f 28 4b c0	 movaps	 xmm9, XMMWORD PTR [r11-64]
  006fd	49 8b e3	 mov	 rsp, r11
  00700	5f		 pop	 rdi
  00701	c3		 ret	 0
outputAudio ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT audioCallback
_TEXT	SEGMENT
userdata$ = 48
stream$ = 56
len$ = 64
audioCallback PROC					; COMDAT

; 735  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 736  : 	int16_t *out;
; 737  : 	int32_t sampleBlock, samplesTodo;
; 738  : 
; 739  : 	(void)userdata;
; 740  : 
; 741  : 	if (forceMixerOff) // during MOD2WAV

  0000a	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR forceMixerOff, 0
  00011	48 8b f2	 mov	 rsi, rdx
  00014	49 63 d8	 movsxd	 rbx, r8d
  00017	74 17		 je	 SHORT $LN4@audioCallb

; 742  : 	{
; 743  : 		memset(stream, 0, len);

  00019	4c 8b c3	 mov	 r8, rbx
  0001c	33 d2		 xor	 edx, edx
  0001e	48 8b ce	 mov	 rcx, rsi

; 767  : 		}
; 768  : 	}
; 769  : }

  00021	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5e		 pop	 rsi

; 742  : 	{
; 743  : 		memset(stream, 0, len);

  0002b	e9 00 00 00 00	 jmp	 memset
$LN4@audioCallb:

; 744  : 		return;
; 745  : 	}
; 746  : 
; 747  : 	out = (int16_t *)stream;
; 748  : 
; 749  : 	sampleBlock = len >> 2;

  00030	c1 fb 02	 sar	 ebx, 2

; 750  : 	while (sampleBlock)

  00033	85 db		 test	 ebx, ebx
  00035	74 58		 je	 SHORT $LN3@audioCallb
  00037	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR sampleCounter
  0003d	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
$LL2@audioCallb:

; 751  : 	{
; 752  : 		samplesTodo = (sampleBlock < sampleCounter) ? sampleBlock : sampleCounter;

  00042	3b d8		 cmp	 ebx, eax
  00044	0f 4c c3	 cmovl	 eax, ebx
  00047	8b f8		 mov	 edi, eax

; 753  : 		if (samplesTodo > 0)

  00049	85 c0		 test	 eax, eax
  0004b	7e 1d		 jle	 SHORT $LN5@audioCallb

; 754  : 		{
; 755  : 			outputAudio(out, samplesTodo);

  0004d	8b d0		 mov	 edx, eax
  0004f	48 8b ce	 mov	 rcx, rsi
  00052	e8 00 00 00 00	 call	 outputAudio

; 756  : 			out += (uint32_t)samplesTodo * 2;

  00057	8d 04 3f	 lea	 eax, DWORD PTR [rdi+rdi]

; 757  : 
; 758  : 			sampleBlock -= samplesTodo;

  0005a	2b df		 sub	 ebx, edi
  0005c	48 8d 34 46	 lea	 rsi, QWORD PTR [rsi+rax*2]

; 759  : 			sampleCounter -= samplesTodo;

  00060	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR sampleCounter
  00066	2b c7		 sub	 eax, edi

; 760  : 		}

  00068	eb 16		 jmp	 SHORT $LN12@audioCallb
$LN5@audioCallb:

; 761  : 		else
; 762  : 		{
; 763  : 			if (editor.songPlaying)

  0006a	0f b6 05 3c 00
	00 00		 movzx	 eax, BYTE PTR editor+60
  00071	84 c0		 test	 al, al
  00073	74 05		 je	 SHORT $LN7@audioCallb

; 764  : 				intMusic();

  00075	e8 00 00 00 00	 call	 intMusic
$LN7@audioCallb:

; 765  : 
; 766  : 			sampleCounter = samplesPerTick;

  0007a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR samplesPerTick
$LN12@audioCallb:

; 750  : 	while (sampleBlock)

  00080	89 05 00 00 00
	00		 mov	 DWORD PTR sampleCounter, eax
  00086	85 db		 test	 ebx, ebx
  00088	75 b8		 jne	 SHORT $LL2@audioCallb
  0008a	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN3@audioCallb:

; 767  : 		}
; 768  : 	}
; 769  : }

  0008f	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00094	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00098	5e		 pop	 rsi
  00099	c3		 ret	 0
audioCallback ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT calculateFilterCoeffs
_TEXT	SEGMENT
calculateFilterCoeffs PROC				; COMDAT

; 145  : 	double dOmega = ((2.0 * M_PI) * dHz) / dSr;

  00000	f2 0f 10 15 00
	00 00 00	 movsd	 xmm2, QWORD PTR __real@3ff0000000000000
  00008	f2 0f 10 25 48
	05 00 00	 movsd	 xmm4, QWORD PTR audio+1352
  00010	0f 28 ea	 movaps	 xmm5, xmm2

; 146  : 	filter->b0 = 1.0 / (1.0 + (1.0 / dOmega));

  00013	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3f00af7429c4e0ea
  0001b	0f 28 ca	 movaps	 xmm1, xmm2

; 132  : 	dFb *= 0.62;

  0001e	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR ?dFb@?1??calcCoeffLED@@9@9
  00026	f2 0f 59 1d 00
	00 00 00	 mulsd	 xmm3, QWORD PTR __real@3fe3d70a3d70a3d7

; 145  : 	double dOmega = ((2.0 * M_PI) * dHz) / dSr;

  0002e	f2 0f 5e ec	 divsd	 xmm5, xmm4

; 132  : 	dFb *= 0.62;

  00032	f2 0f 11 1d 00
	00 00 00	 movsd	 QWORD PTR ?dFb@?1??calcCoeffLED@@9@9, xmm3

; 146  : 	filter->b0 = 1.0 / (1.0 + (1.0 / dOmega));

  0003a	f2 0f 5e c5	 divsd	 xmm0, xmm5
  0003e	f2 0f 58 c2	 addsd	 xmm0, xmm2
  00042	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00046	0f 28 c2	 movaps	 xmm0, xmm2
  00049	f2 0f 5c c1	 subsd	 xmm0, xmm1
  0004d	f2 0f 11 0d 10
	00 00 00	 movsd	 QWORD PTR filterLo+16, xmm1

; 147  : 	filter->b1 = 1.0 - filter->b0;

  00055	f2 0f 11 05 18
	00 00 00	 movsd	 QWORD PTR filterLo+24, xmm0

; 135  : 	if (dHz < dSr/2.0)

  0005d	0f 28 c4	 movaps	 xmm0, xmm4
  00060	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00068	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@40a5cd10d8cf05d9
  00070	76 16		 jbe	 SHORT $LN6@calculateF

; 136  : 		filter->dLed = ((2.0 * M_PI) * dHz) / dSr;

  00072	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@40d11f5bdca6355d
  0007a	f2 0f 5e cc	 divsd	 xmm1, xmm4
  0007e	f2 0f 11 0d 00
	00 00 00	 movsd	 QWORD PTR filterLEDC, xmm1
  00086	eb 0b		 jmp	 SHORT $LN7@calculateF
$LN6@calculateF:

; 137  : 	else
; 138  : 		filter->dLed = 1.0;

  00088	f2 0f 11 15 00
	00 00 00	 movsd	 QWORD PTR filterLEDC, xmm2
  00090	0f 28 ca	 movaps	 xmm1, xmm2
$LN7@calculateF:

; 139  : 
; 140  : 	filter->dLedFb = dFb + (dFb / (1.0 - filter->dLed)); // Q ~= 1/sqrt(2) (Butterworth)

  00093	0f 28 c2	 movaps	 xmm0, xmm2
  00096	f2 0f 5c c1	 subsd	 xmm0, xmm1
  0009a	0f 28 cb	 movaps	 xmm1, xmm3
  0009d	f2 0f 5e c8	 divsd	 xmm1, xmm0

; 146  : 	filter->b0 = 1.0 / (1.0 + (1.0 / dOmega));

  000a1	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3f984edf1c1e350c

; 140  : 	filter->dLedFb = dFb + (dFb / (1.0 - filter->dLed)); // Q ~= 1/sqrt(2) (Butterworth)

  000a9	f2 0f 58 cb	 addsd	 xmm1, xmm3

; 146  : 	filter->b0 = 1.0 / (1.0 + (1.0 / dOmega));

  000ad	f2 0f 5e c5	 divsd	 xmm0, xmm5

; 140  : 	filter->dLedFb = dFb + (dFb / (1.0 - filter->dLed)); // Q ~= 1/sqrt(2) (Butterworth)

  000b1	f2 0f 11 0d 08
	00 00 00	 movsd	 QWORD PTR filterLEDC+8, xmm1

; 146  : 	filter->b0 = 1.0 / (1.0 + (1.0 / dOmega));

  000b9	0f 28 ca	 movaps	 xmm1, xmm2
  000bc	f2 0f 58 c2	 addsd	 xmm0, xmm2
  000c0	f2 0f 5e c8	 divsd	 xmm1, xmm0
  000c4	f2 0f 5c d1	 subsd	 xmm2, xmm1
  000c8	f2 0f 11 0d 10
	00 00 00	 movsd	 QWORD PTR filterHi+16, xmm1

; 147  : 	filter->b1 = 1.0 - filter->b0;

  000d0	f2 0f 11 15 18
	00 00 00	 movsd	 QWORD PTR filterHi+24, xmm2

; 773  : 	double dCutOffHz;
; 774  : 
; 775  : 	/* Amiga 500 filter emulation, by aciddose
; 776  : 	**
; 777  : 	** First comes a static low-pass 6dB formed by the supply current
; 778  : 	** from the Paula's mixture of channels A+B / C+D into the opamp with
; 779  : 	** 0.1uF capacitor and 360 ohm resistor feedback in inverting mode biased by
; 780  : 	** dac vRef (used to center the output).
; 781  : 	**
; 782  : 	** R = 360 ohm
; 783  : 	** C = 0.1uF
; 784  : 	** Low Hz = 4420.97~ = 1 / (2pi * 360 * 0.0000001)
; 785  : 	**
; 786  : 	** Under spice simulation the circuit yields -3dB = 4400Hz.
; 787  : 	** In the Amiga 1200, the low-pass cutoff is 26kHz+, so the
; 788  : 	** static low-pass filter is disabled in the mixer in A1200 mode.
; 789  : 	**
; 790  : 	** Next comes a bog-standard Sallen-Key filter ("LED") with:
; 791  : 	** R1 = 10K ohm
; 792  : 	** R2 = 10K ohm
; 793  : 	** C1 = 6800pF
; 794  : 	** C2 = 3900pF
; 795  : 	** Q ~= 1/sqrt(2)
; 796  : 	**
; 797  : 	** This filter is optionally bypassed by an MPF-102 JFET chip when
; 798  : 	** the LED filter is turned off.
; 799  : 	**
; 800  : 	** Under spice simulation the circuit yields -3dB = 2800Hz.
; 801  : 	** 90 degrees phase = 3000Hz (so, should oscillate at 3kHz!)
; 802  : 	**
; 803  : 	** The buffered output of the Sallen-Key passes into an RC high-pass with:
; 804  : 	** R = 1.39K ohm (1K ohm + 390 ohm)
; 805  : 	** C = 22uF (also C = 330nF, for improved high-frequency)
; 806  : 	**
; 807  : 	** High Hz = 5.2~ = 1 / (2pi * 1390 * 0.000022)
; 808  : 	** Under spice simulation the circuit yields -3dB = 5.2Hz.
; 809  : 	*/
; 810  : 
; 811  : 	// Amiga 500 rev6 RC low-pass filter:
; 812  : 	const double dLp_R = 360.0; // R321 - 360 ohm resistor
; 813  : 	const double dLp_C = 1e-7;  // C321 - 0.1uF capacitor
; 814  : 	dCutOffHz = 1.0 / ((2.0 * M_PI) * dLp_R * dLp_C); // ~4420.97Hz
; 815  : #ifndef NO_FILTER_FINETUNING
; 816  : 	dCutOffHz += 580.0; // 8bitbubsy: finetuning to better match A500 low-pass testing
; 817  : #endif
; 818  : 	calcCoeffLossyIntegrator(audio.dAudioFreq, dCutOffHz, &filterLo);
; 819  : 
; 820  : 	// Amiga Sallen-Key "LED" filter:
; 821  : 	const double dLed_R1 = 10000.0; // R322 - 10K ohm resistor
; 822  : 	const double dLed_R2 = 10000.0; // R323 - 10K ohm resistor
; 823  : 	const double dLed_C1 = 6.8e-9;  // C322 - 6800pF capacitor
; 824  : 	const double dLed_C2 = 3.9e-9;  // C323 - 3900pF capacitor
; 825  : 	dCutOffHz = 1.0 / ((2.0 * M_PI) * sqrt(dLed_R1 * dLed_R2 * dLed_C1 * dLed_C2)); // ~3090.53Hz
; 826  : #ifndef NO_FILTER_FINETUNING
; 827  : 	dCutOffHz -= 300.0; // 8bitbubsy: finetuning to better match A500 & A1200 "LED" filter testing
; 828  : #endif
; 829  : 	calcCoeffLED(audio.dAudioFreq, dCutOffHz, &filterLEDC);
; 830  : 
; 831  : 	// Amiga RC high-pass filter:
; 832  : 	const double dHp_R = 1000.0 + 390.0; // R324 - 1K ohm resistor + R325 - 390 ohm resistor
; 833  : 	const double dHp_C = 2.2e-5; // C334 - 22uF capacitor
; 834  : 	dCutOffHz = 1.0 / ((2.0 * M_PI) * dHp_R * dHp_C); // ~5.20Hz
; 835  : #ifndef NO_FILTER_FINETUNING
; 836  : 	dCutOffHz += 1.5; // 8bitbubsy: finetuning to better match A500 & A1200 high-pass testing
; 837  : #endif
; 838  : 	calcCoeffLossyIntegrator(audio.dAudioFreq, dCutOffHz, &filterHi);
; 839  : }

  000d8	c3		 ret	 0
calculateFilterCoeffs ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT mixerCalcVoicePans
_TEXT	SEGMENT
stereoSeparation$ = 48
mixerCalcVoicePans PROC					; COMDAT

; 842  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 843  : 	uint8_t scaledPanPos = (stereoSeparation * 128) / 100;

  00004	0f b6 d1	 movzx	 edx, cl
  00007	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0000c	c1 e2 07	 shl	 edx, 7

; 844  : 
; 845  : 	ch1Pan = 128 - scaledPanPos;
; 846  : 	ch2Pan = 128 + scaledPanPos;
; 847  : 	ch3Pan = 128 + scaledPanPos;
; 848  : 	ch4Pan = 128 - scaledPanPos;
; 849  : 
; 850  : 	mixerSetVoicePan(0, ch1Pan);

  0000f	33 c9		 xor	 ecx, ecx
  00011	f7 ea		 imul	 edx
  00013	c1 fa 05	 sar	 edx, 5
  00016	8b c2		 mov	 eax, edx
  00018	c1 e8 1f	 shr	 eax, 31
  0001b	03 d0		 add	 edx, eax
  0001d	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  00022	44 0f b6 c2	 movzx	 r8d, dl
  00026	44 8b c8	 mov	 r9d, eax
  00029	66 45 2b c8	 sub	 r9w, r8w
  0002d	66 44 03 c0	 add	 r8w, ax
  00031	41 0f b7 d1	 movzx	 edx, r9w
  00035	66 44 89 05 00
	00 00 00	 mov	 WORD PTR ch2Pan, r8w
  0003d	66 44 89 05 00
	00 00 00	 mov	 WORD PTR ch3Pan, r8w
  00045	66 44 89 0d 00
	00 00 00	 mov	 WORD PTR ch1Pan, r9w
  0004d	66 44 89 0d 00
	00 00 00	 mov	 WORD PTR ch4Pan, r9w
  00055	e8 00 00 00 00	 call	 mixerSetVoicePan

; 851  : 	mixerSetVoicePan(1, ch2Pan);

  0005a	b1 01		 mov	 cl, 1
  0005c	41 0f b7 d0	 movzx	 edx, r8w
  00060	e8 00 00 00 00	 call	 mixerSetVoicePan

; 852  : 	mixerSetVoicePan(2, ch3Pan);

  00065	b1 02		 mov	 cl, 2
  00067	e8 00 00 00 00	 call	 mixerSetVoicePan

; 853  : 	mixerSetVoicePan(3, ch4Pan);

  0006c	b1 03		 mov	 cl, 3
  0006e	41 0f b7 d1	 movzx	 edx, r9w

; 854  : }

  00072	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 853  : 	mixerSetVoicePan(3, ch4Pan);

  00076	e9 00 00 00 00	 jmp	 mixerSetVoicePan
mixerCalcVoicePans ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT setupAudio
_TEXT	SEGMENT
want$ = 48
have$ = 80
setupAudio PROC						; COMDAT

; 857  : {

$LN52:
  00000	40 53		 push	 rbx
  00002	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 858  : 	SDL_AudioSpec want, have;
; 859  : 
; 860  : 	want.freq = ptConfig.soundFrequency;

  00009	8b 05 24 00 00
	00		 mov	 eax, DWORD PTR ptConfig+36

; 861  : 	want.format = AUDIO_S16;
; 862  : 	want.channels = 2;
; 863  : 	want.callback = audioCallback;
; 864  : 	want.userdata = NULL;
; 865  : 	want.samples = ptConfig.soundBufferSize;
; 866  : 
; 867  : 	dev = SDL_OpenAudioDevice(NULL, 0, &want, &have, 0);

  0000f	4c 8d 4c 24 50	 lea	 r9, QWORD PTR have$[rsp]
  00014	89 44 24 30	 mov	 DWORD PTR want$[rsp], eax
  00018	4c 8d 44 24 30	 lea	 r8, QWORD PTR want$[rsp]
  0001d	b8 10 80 00 00	 mov	 eax, 32784		; 00008010H
  00022	c6 44 24 36 02	 mov	 BYTE PTR want$[rsp+6], 2
  00027	66 89 44 24 34	 mov	 WORD PTR want$[rsp+4], ax
  0002c	33 db		 xor	 ebx, ebx
  0002e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:audioCallback
  00035	48 89 5c 24 48	 mov	 QWORD PTR want$[rsp+24], rbx
  0003a	48 89 44 24 40	 mov	 QWORD PTR want$[rsp+16], rax
  0003f	33 d2		 xor	 edx, edx
  00041	0f b7 05 28 00
	00 00		 movzx	 eax, WORD PTR ptConfig+40
  00048	33 c9		 xor	 ecx, ecx
  0004a	66 89 44 24 38	 mov	 WORD PTR want$[rsp+8], ax
  0004f	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SDL_OpenAudioDevice
  00059	89 05 00 00 00
	00		 mov	 DWORD PTR dev, eax

; 868  : 	if (dev == 0)

  0005f	85 c0		 test	 eax, eax
  00061	75 20		 jne	 SHORT $LN2@setupAudio

; 869  : 	{
; 870  : 		showErrorMsgBox("Unable to open audio device: %s", SDL_GetError());

  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SDL_GetError
  00069	48 8b d0	 mov	 rdx, rax
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@DJMKAAEN@Unable?5to?5open?5audio?5device?3?5?$CFs@
  00073	e8 00 00 00 00	 call	 showErrorMsgBox

; 921  : }

  00078	32 c0		 xor	 al, al
  0007a	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00081	5b		 pop	 rbx
  00082	c3		 ret	 0
$LN2@setupAudio:

; 871  : 		return false;
; 872  : 	}
; 873  : 
; 874  : 	if (have.freq < 32000) // lower than this is not safe for one-step mixer w/ BLEP

  00083	8b 4c 24 50	 mov	 ecx, DWORD PTR have$[rsp]
  00087	81 f9 00 7d 00
	00		 cmp	 ecx, 32000		; 00007d00H
  0008d	7d 17		 jge	 SHORT $LN3@setupAudio

; 875  : 	{
; 876  : 		showErrorMsgBox("Unable to open audio: The audio output rate couldn't be used!");

  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DO@LPEDDBAN@Unable?5to?5open?5audio?3?5The?5audio@

; 921  : }

  00096	e8 00 00 00 00	 call	 showErrorMsgBox
  0009b	32 c0		 xor	 al, al
  0009d	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  000a4	5b		 pop	 rbx
  000a5	c3		 ret	 0
$LN3@setupAudio:

; 877  : 		return false;
; 878  : 	}
; 879  : 
; 880  : 	if (have.format != want.format)

  000a6	0f b7 44 24 34	 movzx	 eax, WORD PTR want$[rsp+4]
  000ab	66 39 44 24 54	 cmp	 WORD PTR have$[rsp+4], ax
  000b0	74 17		 je	 SHORT $LN4@setupAudio

; 881  : 	{
; 882  : 		showErrorMsgBox("Unable to open audio: The sample format (signed 16-bit) couldn't be used!");

  000b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EK@FLPNBHOI@Unable?5to?5open?5audio?3?5The?5sampl@

; 921  : }

  000b9	e8 00 00 00 00	 call	 showErrorMsgBox
  000be	32 c0		 xor	 al, al
  000c0	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  000c7	5b		 pop	 rbx
  000c8	c3		 ret	 0
$LN4@setupAudio:
  000c9	66 0f 6e c1	 movd	 xmm0, ecx

; 883  : 		return false;
; 884  : 	}
; 885  : 
; 886  : 	maxSamplesToMix = (int32_t)ceil((have.freq * 2.5) / 32.0);

  000cd	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  000d7	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000db	0f 57 c9	 xorps	 xmm1, xmm1
  000de	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fb4000000000000
  000e6	f2 48 0f 2c c8	 cvttsd2si rcx, xmm0
  000eb	48 3b c8	 cmp	 rcx, rax
  000ee	74 28		 je	 SHORT $LN44@setupAudio
  000f0	0f 57 c9	 xorps	 xmm1, xmm1
  000f3	f2 48 0f 2a c9	 cvtsi2sd xmm1, rcx
  000f8	66 0f 2e c8	 ucomisd xmm1, xmm0
  000fc	74 1a		 je	 SHORT $LN44@setupAudio
  000fe	66 0f 14 c0	 unpcklpd xmm0, xmm0
  00102	66 48 0f 50 c0	 movmskpd rax, xmm0
  00107	0f 57 c0	 xorps	 xmm0, xmm0
  0010a	83 e0 01	 and	 eax, 1
  0010d	83 f0 01	 xor	 eax, 1
  00110	48 03 c8	 add	 rcx, rax
  00113	f2 48 0f 2a c1	 cvtsi2sd xmm0, rcx
$LN44@setupAudio:
  00118	f2 0f 2c c0	 cvttsd2si eax, xmm0
  0011c	48 63 c8	 movsxd	 rcx, eax
  0011f	89 05 00 00 00
	00		 mov	 DWORD PTR maxSamplesToMix, eax

; 887  : 
; 888  : 	dMixBufferLUnaligned = (double *)MALLOC_PAD(maxSamplesToMix * sizeof (double), 256);

  00125	48 8d 0c cd 00
	01 00 00	 lea	 rcx, QWORD PTR [rcx*8+256]
  0012d	e8 00 00 00 00	 call	 malloc

; 889  : 	dMixBufferRUnaligned = (double *)MALLOC_PAD(maxSamplesToMix * sizeof (double), 256);

  00132	48 63 0d 00 00
	00 00		 movsxd	 rcx, DWORD PTR maxSamplesToMix
  00139	48 89 05 00 00
	00 00		 mov	 QWORD PTR dMixBufferLUnaligned, rax
  00140	48 8d 0c cd 00
	01 00 00	 lea	 rcx, QWORD PTR [rcx*8+256]
  00148	e8 00 00 00 00	 call	 malloc

; 890  : 
; 891  : 	editor.mod2WavBuffer = (int16_t *)malloc(sizeof (int16_t) * maxSamplesToMix);

  0014d	48 63 0d 00 00
	00 00		 movsxd	 rcx, DWORD PTR maxSamplesToMix
  00154	48 03 c9	 add	 rcx, rcx
  00157	48 89 05 00 00
	00 00		 mov	 QWORD PTR dMixBufferRUnaligned, rax
  0015e	e8 00 00 00 00	 call	 malloc

; 892  : 
; 893  : 	if (dMixBufferLUnaligned == NULL || dMixBufferRUnaligned == NULL || editor.mod2WavBuffer == NULL)

  00163	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR dMixBufferLUnaligned
  0016a	48 89 05 98 22
	00 00		 mov	 QWORD PTR editor+8856, rax
  00171	48 85 d2	 test	 rdx, rdx
  00174	0f 84 9e 02 00
	00		 je	 $LN6@setupAudio
  0017a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dMixBufferRUnaligned
  00181	48 85 c9	 test	 rcx, rcx
  00184	0f 84 8e 02 00
	00		 je	 $LN6@setupAudio
  0018a	48 85 c0	 test	 rax, rax
  0018d	0f 84 85 02 00
	00		 je	 $LN6@setupAudio

; 896  : 		return false;
; 897  : 	}
; 898  : 
; 899  : 	dMixBufferL = (double *)ALIGN_PTR(dMixBufferLUnaligned, 256);
; 900  : 	dMixBufferR = (double *)ALIGN_PTR(dMixBufferRUnaligned, 256);
; 901  : 
; 902  : 	audio.audioBufferSize = have.samples;
; 903  : 	ptConfig.soundFrequency = have.freq;

  00193	44 8b 5c 24 50	 mov	 r11d, DWORD PTR have$[rsp]
  00198	48 8d 82 ff 00
	00 00		 lea	 rax, QWORD PTR [rdx+255]

; 904  : 	audio.audioFreq = ptConfig.soundFrequency;
; 905  : 	audio.dAudioFreq = (double)ptConfig.soundFrequency;
; 906  : 	audio.dPeriodToDeltaDiv = PAULA_PAL_CLK / audio.dAudioFreq;

  0019f	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@414b0f8780000000
  001a7	48 25 00 ff ff
	ff		 and	 rax, -256		; ffffffffffffff00H

; 907  : 
; 908  : 	mixerCalcVoicePans(ptConfig.stereoSeparation);

  001ad	44 0f b6 15 1e
	00 00 00	 movzx	 r10d, BYTE PTR ptConfig+30
  001b5	0f 29 74 24 70	 movaps	 XMMWORD PTR [rsp+112], xmm6
  001ba	0f 57 f6	 xorps	 xmm6, xmm6
  001bd	48 89 05 00 00
	00 00		 mov	 QWORD PTR dMixBufferL, rax
  001c4	48 8d 81 ff 00
	00 00		 lea	 rax, QWORD PTR [rcx+255]
  001cb	f2 49 0f 2a f3	 cvtsi2sd xmm6, r11
  001d0	48 25 00 ff ff
	ff		 and	 rax, -256		; ffffffffffffff00H
  001d6	44 89 1d 24 00
	00 00		 mov	 DWORD PTR ptConfig+36, r11d
  001dd	48 89 05 00 00
	00 00		 mov	 QWORD PTR dMixBufferR, rax
  001e4	41 0f b6 ca	 movzx	 ecx, r10b
  001e8	0f b7 44 24 58	 movzx	 eax, WORD PTR have$[rsp+8]
  001ed	89 05 44 05 00
	00		 mov	 DWORD PTR audio+1348, eax
  001f3	44 89 1d 40 05
	00 00		 mov	 DWORD PTR audio+1344, r11d
  001fa	f2 0f 5e c6	 divsd	 xmm0, xmm6
  001fe	f2 0f 11 35 48
	05 00 00	 movsd	 QWORD PTR audio+1352, xmm6
  00206	f2 0f 11 05 50
	05 00 00	 movsd	 QWORD PTR audio+1360, xmm0
  0020e	e8 00 00 00 00	 call	 mixerCalcVoicePans

; 145  : 	double dOmega = ((2.0 * M_PI) * dHz) / dSr;

  00213	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@3ff0000000000000

; 146  : 	filter->b0 = 1.0 / (1.0 + (1.0 / dOmega));

  0021b	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3f00af7429c4e0ea
  00223	0f 28 c3	 movaps	 xmm0, xmm3

; 132  : 	dFb *= 0.62;

  00226	f2 0f 10 25 00
	00 00 00	 movsd	 xmm4, QWORD PTR ?dFb@?1??calcCoeffLED@@9@9

; 146  : 	filter->b0 = 1.0 / (1.0 + (1.0 / dOmega));

  0022e	0f 28 d3	 movaps	 xmm2, xmm3

; 910  : 
; 911  : 	filterFlags = ptConfig.a500LowPassFilter ? FILTER_A500 : 0;

  00231	38 1d 12 00 00
	00		 cmp	 BYTE PTR ptConfig+18, bl

; 132  : 	dFb *= 0.62;

  00237	f2 0f 59 25 00
	00 00 00	 mulsd	 xmm4, QWORD PTR __real@3fe3d70a3d70a3d7

; 909  : 	defStereoSep = ptConfig.stereoSeparation;

  0023f	44 88 15 00 00
	00 00		 mov	 BYTE PTR defStereoSep, r10b

; 145  : 	double dOmega = ((2.0 * M_PI) * dHz) / dSr;

  00246	f2 0f 5e c6	 divsd	 xmm0, xmm6

; 910  : 
; 911  : 	filterFlags = ptConfig.a500LowPassFilter ? FILTER_A500 : 0;

  0024a	0f 95 05 00 00
	00 00		 setne	 BYTE PTR filterFlags

; 132  : 	dFb *= 0.62;

  00251	f2 0f 11 25 00
	00 00 00	 movsd	 QWORD PTR ?dFb@?1??calcCoeffLED@@9@9, xmm4

; 146  : 	filter->b0 = 1.0 / (1.0 + (1.0 / dOmega));

  00259	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0025d	0f 28 c3	 movaps	 xmm0, xmm3
  00260	f2 0f 58 cb	 addsd	 xmm1, xmm3
  00264	f2 0f 5e d1	 divsd	 xmm2, xmm1
  00268	f2 0f 5c c2	 subsd	 xmm0, xmm2
  0026c	f2 0f 11 15 10
	00 00 00	 movsd	 QWORD PTR filterLo+16, xmm2

; 135  : 	if (dHz < dSr/2.0)

  00274	f2 0f 10 15 00
	00 00 00	 movsd	 xmm2, QWORD PTR __real@3fe0000000000000

; 147  : 	filter->b1 = 1.0 - filter->b0;

  0027c	f2 0f 11 05 18
	00 00 00	 movsd	 QWORD PTR filterLo+24, xmm0

; 135  : 	if (dHz < dSr/2.0)

  00284	0f 28 c6	 movaps	 xmm0, xmm6
  00287	f2 0f 59 c2	 mulsd	 xmm0, xmm2
  0028b	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@40a5cd10d8cf05d9
  00293	76 16		 jbe	 SHORT $LN13@setupAudio

; 136  : 		filter->dLed = ((2.0 * M_PI) * dHz) / dSr;

  00295	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@40d11f5bdca6355d
  0029d	f2 0f 5e ce	 divsd	 xmm1, xmm6
  002a1	f2 0f 11 0d 00
	00 00 00	 movsd	 QWORD PTR filterLEDC, xmm1
  002a9	eb 0b		 jmp	 SHORT $LN14@setupAudio
$LN13@setupAudio:

; 137  : 	else
; 138  : 		filter->dLed = 1.0;

  002ab	f2 0f 11 1d 00
	00 00 00	 movsd	 QWORD PTR filterLEDC, xmm3
  002b3	0f 28 cb	 movaps	 xmm1, xmm3
$LN14@setupAudio:

; 139  : 
; 140  : 	filter->dLedFb = dFb + (dFb / (1.0 - filter->dLed)); // Q ~= 1/sqrt(2) (Butterworth)

  002b6	f2 0f 10 2d 00
	00 00 00	 movsd	 xmm5, QWORD PTR __real@3eb7a68b994d1178
  002be	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:audio
  002c5	0f 28 c3	 movaps	 xmm0, xmm3
  002c8	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  002ce	f2 0f 5c c1	 subsd	 xmm0, xmm1
  002d2	0f 28 cc	 movaps	 xmm1, xmm4
  002d5	f2 0f 5e c8	 divsd	 xmm1, xmm0

; 145  : 	double dOmega = ((2.0 * M_PI) * dHz) / dSr;

  002d9	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4045101d282be213
  002e1	f2 0f 5e c6	 divsd	 xmm0, xmm6

; 140  : 	filter->dLedFb = dFb + (dFb / (1.0 - filter->dLed)); // Q ~= 1/sqrt(2) (Butterworth)

  002e5	0f 28 74 24 70	 movaps	 xmm6, XMMWORD PTR [rsp+112]
  002ea	f2 0f 58 cc	 addsd	 xmm1, xmm4
  002ee	f2 0f 10 25 00
	00 00 00	 movsd	 xmm4, QWORD PTR __real@3f9ffff7218ba683
  002f6	f2 0f 11 0d 08
	00 00 00	 movsd	 QWORD PTR filterLEDC+8, xmm1

; 146  : 	filter->b0 = 1.0 / (1.0 + (1.0 / dOmega));

  002fe	0f 28 cb	 movaps	 xmm1, xmm3
  00301	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00305	0f 28 c3	 movaps	 xmm0, xmm3
  00308	f2 0f 58 cb	 addsd	 xmm1, xmm3
  0030c	f2 0f 5e c1	 divsd	 xmm0, xmm1
  00310	f2 0f 5c d8	 subsd	 xmm3, xmm0
  00314	f2 0f 11 05 10
	00 00 00	 movsd	 QWORD PTR filterHi+16, xmm0

; 147  : 	filter->b1 = 1.0 - filter->b0;

  0031c	f2 0f 11 1d 18
	00 00 00	 movsd	 QWORD PTR filterHi+24, xmm3

; 140  : 	filter->dLedFb = dFb + (dFb / (1.0 - filter->dLed)); // Q ~= 1/sqrt(2) (Butterworth)

  00324	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR __real@3fa4d00788ffda07
  0032c	0f 1f 40 00	 npad	 4
$LL34@setupAudio:

; 86   : 	if (bpm == 0)

  00330	45 85 c0	 test	 r8d, r8d
  00333	75 05		 jne	 SHORT $LN35@setupAudio

; 87   : 		return 0;

  00335	0f b7 cb	 movzx	 ecx, bx
  00338	eb 2f		 jmp	 SHORT $LN36@setupAudio
$LN35@setupAudio:
  0033a	0f 57 c9	 xorps	 xmm1, xmm1

; 88   : 
; 89   : 	ciaVal = (uint32_t)(1773447 / bpm); // yes, PT truncates here

  0033d	b8 87 0f 1b 00	 mov	 eax, 1773447		; 001b0f87H
  00342	33 d2		 xor	 edx, edx
  00344	0f 57 c0	 xorps	 xmm0, xmm0
  00347	41 f7 f0	 div	 r8d
  0034a	8b c8		 mov	 ecx, eax

; 91   : 
; 92   : 	return (uint16_t)((audioFreq * dFreqMul) + 0.5);

  0034c	41 8b c3	 mov	 eax, r11d
  0034f	f2 48 0f 2a c9	 cvtsi2sd xmm1, rcx
  00354	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  00359	f2 0f 59 cd	 mulsd	 xmm1, xmm5
  0035d	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00361	f2 0f 58 ca	 addsd	 xmm1, xmm2
  00365	f2 0f 2c c9	 cvttsd2si ecx, xmm1
$LN36@setupAudio:

; 99   : 		audio.bpmTab[i-32] = bpm2SmpsPerTick(i, audio.audioFreq);

  00369	41 8d 40 e0	 lea	 eax, DWORD PTR [r8-32]
  0036d	44 8b c8	 mov	 r9d, eax
  00370	66 41 89 0c 42	 mov	 WORD PTR [r10+rax*2], cx

; 86   : 	if (bpm == 0)

  00375	45 85 c0	 test	 r8d, r8d
  00378	75 05		 jne	 SHORT $LN37@setupAudio

; 87   : 		return 0;

  0037a	0f b7 c3	 movzx	 eax, bx
  0037d	eb 20		 jmp	 SHORT $LN38@setupAudio
$LN37@setupAudio:
  0037f	0f 57 c0	 xorps	 xmm0, xmm0

; 88   : 
; 89   : 	ciaVal = (uint32_t)(1773447 / bpm); // yes, PT truncates here

  00382	33 d2		 xor	 edx, edx
  00384	b8 87 0f 1b 00	 mov	 eax, 1773447		; 001b0f87H
  00389	41 f7 f0	 div	 r8d
  0038c	8b c8		 mov	 ecx, eax

; 90   : 	dFreqMul = ciaVal * (1.0 / CIA_PAL_CLK);

  0038e	f2 48 0f 2a c1	 cvtsi2sd xmm0, rcx

; 91   : 
; 92   : 	return (uint16_t)((audioFreq * dFreqMul) + 0.5);

  00393	f2 0f 59 c3	 mulsd	 xmm0, xmm3
  00397	f2 0f 58 c2	 addsd	 xmm0, xmm2
  0039b	f2 0f 2c c0	 cvttsd2si eax, xmm0
$LN38@setupAudio:

; 100  : 		audio.bpmTab28kHz[i-32] = bpm2SmpsPerTick(i, 28836);

  0039f	66 43 89 84 4a
	c0 01 00 00	 mov	 WORD PTR [r10+r9*2+448], ax

; 86   : 	if (bpm == 0)

  003a8	45 85 c0	 test	 r8d, r8d
  003ab	75 05		 jne	 SHORT $LN39@setupAudio

; 87   : 		return 0;

  003ad	0f b7 c3	 movzx	 eax, bx
  003b0	eb 20		 jmp	 SHORT $LN40@setupAudio
$LN39@setupAudio:
  003b2	0f 57 c0	 xorps	 xmm0, xmm0

; 88   : 
; 89   : 	ciaVal = (uint32_t)(1773447 / bpm); // yes, PT truncates here

  003b5	33 d2		 xor	 edx, edx
  003b7	b8 87 0f 1b 00	 mov	 eax, 1773447		; 001b0f87H
  003bc	41 f7 f0	 div	 r8d
  003bf	8b c8		 mov	 ecx, eax

; 90   : 	dFreqMul = ciaVal * (1.0 / CIA_PAL_CLK);

  003c1	f2 48 0f 2a c1	 cvtsi2sd xmm0, rcx

; 91   : 
; 92   : 	return (uint16_t)((audioFreq * dFreqMul) + 0.5);

  003c6	f2 0f 59 c4	 mulsd	 xmm0, xmm4
  003ca	f2 0f 58 c2	 addsd	 xmm0, xmm2
  003ce	f2 0f 2c c0	 cvttsd2si eax, xmm0
$LN40@setupAudio:

; 97   : 	for (uint32_t i = 32; i <= 255; i++)

  003d2	41 ff c0	 inc	 r8d

; 101  : 		audio.bpmTab22kHz[i-32] = bpm2SmpsPerTick(i, 22168);

  003d5	66 43 89 84 4a
	80 03 00 00	 mov	 WORD PTR [r10+r9*2+896], ax
  003de	41 81 f8 ff 00
	00 00		 cmp	 r8d, 255		; 000000ffH
  003e5	77 0c		 ja	 SHORT $LN48@setupAudio

; 93   : }
; 94   : 
; 95   : static void generateBpmTables(void)
; 96   : {
; 97   : 	for (uint32_t i = 32; i <= 255; i++)

  003e7	44 8b 1d 40 05
	00 00		 mov	 r11d, DWORD PTR audio+1344
  003ee	e9 3d ff ff ff	 jmp	 $LL34@setupAudio
$LN48@setupAudio:

; 912  : 
; 913  : 	calculateFilterCoeffs();
; 914  : 	generateBpmTables();
; 915  : 
; 916  : 	samplesPerTick = 0;
; 917  : 	sampleCounter = 0;
; 918  : 
; 919  : 	SDL_PauseAudioDevice(dev, false);

  003f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR dev
  003f9	33 d2		 xor	 edx, edx
  003fb	89 1d 00 00 00
	00		 mov	 DWORD PTR samplesPerTick, ebx
  00401	89 1d 00 00 00
	00		 mov	 DWORD PTR sampleCounter, ebx
  00407	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SDL_PauseAudioDevice

; 920  : 	return true;

  0040d	b0 01		 mov	 al, 1

; 921  : }

  0040f	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00416	5b		 pop	 rbx
  00417	c3		 ret	 0
$LN6@setupAudio:

; 894  : 	{
; 895  : 		showErrorMsgBox("Out of memory!");

  00418	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@MCKMEEL@Out?5of?5memory?$CB@

; 921  : }

  0041f	e8 00 00 00 00	 call	 showErrorMsgBox
  00424	32 c0		 xor	 al, al
  00426	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  0042d	5b		 pop	 rbx
  0042e	c3		 ret	 0
setupAudio ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT audioClose
_TEXT	SEGMENT
audioClose PROC						; COMDAT

; 924  : {

$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 925  : 	if (dev > 0)

  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR dev
  0000c	33 db		 xor	 ebx, ebx
  0000e	85 c9		 test	 ecx, ecx
  00010	74 1b		 je	 SHORT $LN2@audioClose

; 926  : 	{
; 927  : 		SDL_PauseAudioDevice(dev, true);

  00012	8d 53 01	 lea	 edx, QWORD PTR [rbx+1]
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SDL_PauseAudioDevice

; 928  : 		SDL_CloseAudioDevice(dev);

  0001b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR dev
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SDL_CloseAudioDevice

; 929  : 		dev = 0;

  00027	89 1d 00 00 00
	00		 mov	 DWORD PTR dev, ebx
$LN2@audioClose:

; 930  : 	}
; 931  : 
; 932  : 	if (dMixBufferLUnaligned != NULL)

  0002d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dMixBufferLUnaligned
  00034	48 85 c9	 test	 rcx, rcx
  00037	74 0c		 je	 SHORT $LN3@audioClose

; 933  : 	{
; 934  : 		free(dMixBufferLUnaligned);

  00039	e8 00 00 00 00	 call	 free

; 935  : 		dMixBufferLUnaligned = NULL;

  0003e	48 89 1d 00 00
	00 00		 mov	 QWORD PTR dMixBufferLUnaligned, rbx
$LN3@audioClose:

; 936  : 	}
; 937  : 
; 938  : 	if (dMixBufferRUnaligned != NULL)

  00045	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dMixBufferRUnaligned
  0004c	48 85 c9	 test	 rcx, rcx
  0004f	74 0c		 je	 SHORT $LN4@audioClose

; 939  : 	{
; 940  : 		free(dMixBufferRUnaligned);

  00051	e8 00 00 00 00	 call	 free

; 941  : 		dMixBufferRUnaligned = NULL;

  00056	48 89 1d 00 00
	00 00		 mov	 QWORD PTR dMixBufferRUnaligned, rbx
$LN4@audioClose:

; 942  : 	}
; 943  : 
; 944  : 	if (editor.mod2WavBuffer != NULL)

  0005d	48 8b 0d 98 22
	00 00		 mov	 rcx, QWORD PTR editor+8856
  00064	48 85 c9	 test	 rcx, rcx
  00067	74 0c		 je	 SHORT $LN5@audioClose

; 945  : 	{
; 946  : 		free(editor.mod2WavBuffer);

  00069	e8 00 00 00 00	 call	 free

; 947  : 		editor.mod2WavBuffer = NULL;

  0006e	48 89 1d 98 22
	00 00		 mov	 QWORD PTR editor+8856, rbx
$LN5@audioClose:

; 948  : 	}
; 949  : }

  00075	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
audioClose ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT mixerSetSamplesPerTick
_TEXT	SEGMENT
val$ = 8
mixerSetSamplesPerTick PROC				; COMDAT

; 953  : 	samplesPerTick = val;

  00000	89 0d 00 00 00
	00		 mov	 DWORD PTR samplesPerTick, ecx

; 954  : }

  00006	c3		 ret	 0
mixerSetSamplesPerTick ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT mixerClearSampleCounter
_TEXT	SEGMENT
mixerClearSampleCounter PROC				; COMDAT

; 958  : 	sampleCounter = 0;

  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR sampleCounter, 0

; 959  : }

  0000a	c3		 ret	 0
mixerClearSampleCounter ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_textout.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_textout.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_textout.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_textout.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT toggleAmigaPanMode
_TEXT	SEGMENT
toggleAmigaPanMode PROC					; COMDAT

; 962  : {

$LN36:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 963  : 	amigaPanFlag ^= 1;

  00004	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR amigaPanFlag
  0000b	34 01		 xor	 al, 1
  0000d	0f 95 05 00 00
	00 00		 setne	 BYTE PTR amigaPanFlag
  00014	84 c0		 test	 al, al

; 964  : 	if (!amigaPanFlag)

  00016	75 4b		 jne	 SHORT $LN2@toggleAmig

; 966  : 		mixerCalcVoicePans(defStereoSep);

  00018	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR defStereoSep
  0001f	e8 00 00 00 00	 call	 mixerCalcVoicePans
  00024	33 c0		 xor	 eax, eax
; File C:\Programming\pt2-clone\src\pt2_textout.c

; 623  : 	editor.errorMsgActive = true;

  00026	66 c7 05 08 01
	00 00 01 00	 mov	 WORD PTR editor+264, 1
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 966  : 		mixerCalcVoicePans(defStereoSep);

  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
; File C:\Programming\pt2-clone\src\pt2_textout.c

; 625  : 	editor.errorMsgCounter = 0;

  00036	c6 05 82 22 00
	00 00		 mov	 BYTE PTR editor+8834, 0
  0003d	0f 1f 00	 npad	 3
$LL12@toggleAmig:

; 615  : 	strcpy(editor.ui.statusMessage, msg);

  00040	0f b6 8c 10 00
	00 00 00	 movzx	 ecx, BYTE PTR ??_C@_0BC@BCFDABOJ@AMIGA?5PANNING?5OFF@[rax+rdx]
  00048	88 8c 10 90 37
	00 00		 mov	 BYTE PTR editor[rax+rdx+14224], cl
  0004f	48 8d 40 01	 lea	 rax, QWORD PTR [rax+1]
  00053	84 c9		 test	 cl, cl
  00055	75 e9		 jne	 SHORT $LL12@toggleAmig
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 974  : }

  00057	c6 05 03 38 00
	00 01		 mov	 BYTE PTR editor+14339, 1
  0005e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00062	c3		 ret	 0
$LN2@toggleAmig:

; 971  : 		mixerCalcVoicePans(100);

  00063	b1 64		 mov	 cl, 100			; 00000064H
  00065	e8 00 00 00 00	 call	 mixerCalcVoicePans
  0006a	33 c0		 xor	 eax, eax
; File C:\Programming\pt2-clone\src\pt2_textout.c

; 623  : 	editor.errorMsgActive = true;

  0006c	66 c7 05 08 01
	00 00 01 00	 mov	 WORD PTR editor+264, 1
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 971  : 		mixerCalcVoicePans(100);

  00075	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
; File C:\Programming\pt2-clone\src\pt2_textout.c

; 625  : 	editor.errorMsgCounter = 0;

  0007c	c6 05 82 22 00
	00 00		 mov	 BYTE PTR editor+8834, 0
  00083	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL20@toggleAmig:

; 615  : 	strcpy(editor.ui.statusMessage, msg);

  00090	0f b6 8c 10 00
	00 00 00	 movzx	 ecx, BYTE PTR ??_C@_0BB@LDIONHPE@AMIGA?5PANNING?5ON@[rax+rdx]
  00098	88 8c 10 90 37
	00 00		 mov	 BYTE PTR editor[rax+rdx+14224], cl
  0009f	48 8d 40 01	 lea	 rax, QWORD PTR [rax+1]
  000a3	84 c9		 test	 cl, cl
  000a5	75 e9		 jne	 SHORT $LL20@toggleAmig
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 974  : }

  000a7	c6 05 03 38 00
	00 01		 mov	 BYTE PTR editor+14339, 1
  000ae	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b2	c3		 ret	 0
toggleAmigaPanMode ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT getAudioFrame
_TEXT	SEGMENT
outStream$ = 48
getAudioFrame PROC					; COMDAT

; 979  : {

$LN13:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f1	 mov	 rsi, rcx

; 980  : 	int32_t smpCounter, samplesToMix;
; 981  : 
; 982  : 	if (!intMusic())

  0000d	e8 00 00 00 00	 call	 intMusic
  00012	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR wavRenderingDone
  00019	84 c0		 test	 al, al

; 983  : 		wavRenderingDone = true;
; 984  : 
; 985  : 	smpCounter = samplesPerTick;

  0001b	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR samplesPerTick
  00021	b9 01 00 00 00	 mov	 ecx, 1
  00026	0f 44 d1	 cmove	 edx, ecx
  00029	88 15 00 00 00
	00		 mov	 BYTE PTR wavRenderingDone, dl

; 986  : 	while (smpCounter > 0)

  0002f	85 db		 test	 ebx, ebx
  00031	7e 4b		 jle	 SHORT $LN11@getAudioFr
  00033	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00038	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL2@getAudioFr:

; 987  : 	{
; 988  : 		samplesToMix = smpCounter;
; 989  : 		if (samplesToMix > maxSamplesToMix)

  00040	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR maxSamplesToMix
  00046	8b fb		 mov	 edi, ebx

; 990  : 			samplesToMix = maxSamplesToMix;
; 991  : 
; 992  : 		outputAudio(outStream, samplesToMix);

  00048	48 8b ce	 mov	 rcx, rsi
  0004b	0f 4f 3d 00 00
	00 00		 cmovg	 edi, DWORD PTR maxSamplesToMix
  00052	8b d7		 mov	 edx, edi
  00054	e8 00 00 00 00	 call	 outputAudio

; 993  : 		outStream += (uint32_t)samplesToMix * 2;
; 994  : 
; 995  : 		smpCounter -= samplesToMix;

  00059	2b df		 sub	 ebx, edi
  0005b	8d 04 3f	 lea	 eax, DWORD PTR [rdi+rdi]
  0005e	48 8d 34 46	 lea	 rsi, QWORD PTR [rsi+rax*2]
  00062	85 db		 test	 ebx, ebx
  00064	7f da		 jg	 SHORT $LL2@getAudioFr

; 996  : 	}
; 997  : 
; 998  : 	return (uint32_t)samplesPerTick * 2; // * 2 for stereo

  00066	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR samplesPerTick
  0006c	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  00071	03 c0		 add	 eax, eax

; 999  : }

  00073	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00078	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007c	5e		 pop	 rsi
  0007d	c3		 ret	 0
$LN11@getAudioFr:

; 996  : 	}
; 997  : 
; 998  : 	return (uint32_t)samplesPerTick * 2; // * 2 for stereo

  0007e	8d 04 1b	 lea	 eax, DWORD PTR [rbx+rbx]

; 999  : }

  00081	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00086	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008a	5e		 pop	 rsi
  0008b	c3		 ret	 0
getAudioFrame ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT mod2WavThreadFunc
_TEXT	SEGMENT
wavHeader$ = 32
ptr$ = 128
mod2WavThreadFunc PROC					; COMDAT

; 1002 : {

  00000	40 55		 push	 rbp
  00002	41 57		 push	 r15
  00004	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00008	48 8b e9	 mov	 rbp, rcx

; 1003 : 	uint32_t size, totalSampleCounter, totalRiffChunkLen;
; 1004 : 	FILE *fOut;
; 1005 : 	wavHeader_t wavHeader;
; 1006 : 
; 1007 : 	fOut = (FILE *)ptr;
; 1008 : 	if (fOut == NULL)

  0000b	48 85 c9	 test	 rcx, rcx
  0000e	75 0b		 jne	 SHORT $LN4@mod2WavThr

; 1009 : 		return true;

  00010	8d 41 01	 lea	 eax, QWORD PTR [rcx+1]

; 1061 : }

  00013	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00017	41 5f		 pop	 r15
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
$LN4@mod2WavThr:

; 1010 : 
; 1011 : 	// skip wav header place, render data first
; 1012 : 	fseek(fOut, sizeof (wavHeader_t), SEEK_SET);

  0001b	45 33 c0	 xor	 r8d, r8d
  0001e	4c 89 64 24 60	 mov	 QWORD PTR [rsp+96], r12
  00023	4c 89 6c 24 58	 mov	 QWORD PTR [rsp+88], r13
  00028	4c 89 74 24 50	 mov	 QWORD PTR [rsp+80], r14
  0002d	41 8d 50 2c	 lea	 edx, QWORD PTR [r8+44]
  00031	e8 00 00 00 00	 call	 fseek

; 1013 : 
; 1014 : 	wavRenderingDone = false;
; 1015 : 
; 1016 : 	totalSampleCounter = 0;
; 1017 : 	while (editor.isWAVRendering && !wavRenderingDone && !editor.abortMod2Wav)

  00036	0f b6 05 3e 00
	00 00		 movzx	 eax, BYTE PTR editor+62
  0003d	45 33 e4	 xor	 r12d, r12d
  00040	c6 05 00 00 00
	00 00		 mov	 BYTE PTR wavRenderingDone, 0
  00047	45 8b f4	 mov	 r14d, r12d
  0004a	45 8d 7c 24 01	 lea	 r15d, QWORD PTR [r12+1]
  0004f	45 8d 6c 24 02	 lea	 r13d, QWORD PTR [r12+2]
  00054	84 c0		 test	 al, al
  00056	0f 84 dd 00 00
	00		 je	 $LN24@mod2WavThr
  0005c	48 89 9c 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbx
  00064	48 89 b4 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rsi
  0006c	48 89 bc 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rdi
  00074	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL2@mod2WavThr:
  00080	44 38 25 00 00
	00 00		 cmp	 BYTE PTR wavRenderingDone, r12b
  00087	0f 85 94 00 00
	00		 jne	 $LN27@mod2WavThr
  0008d	44 38 25 21 01
	00 00		 cmp	 BYTE PTR editor+289, r12b
  00094	0f 85 87 00 00
	00		 jne	 $LN27@mod2WavThr

; 1018 : 	{
; 1019 : 		size = getAudioFrame(editor.mod2WavBuffer);

  0009a	48 8b 35 98 22
	00 00		 mov	 rsi, QWORD PTR editor+8856

; 982  : 	if (!intMusic())

  000a1	e8 00 00 00 00	 call	 intMusic
  000a6	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR wavRenderingDone
  000ad	84 c0		 test	 al, al

; 983  : 		wavRenderingDone = true;
; 984  : 
; 985  : 	smpCounter = samplesPerTick;

  000af	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR samplesPerTick
  000b5	41 0f 44 cf	 cmove	 ecx, r15d
  000b9	88 0d 00 00 00
	00		 mov	 BYTE PTR wavRenderingDone, cl

; 986  : 	while (smpCounter > 0)

  000bf	85 db		 test	 ebx, ebx
  000c1	7e 2c		 jle	 SHORT $LN12@mod2WavThr
$LL11@mod2WavThr:

; 987  : 	{
; 988  : 		samplesToMix = smpCounter;
; 989  : 		if (samplesToMix > maxSamplesToMix)

  000c3	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR maxSamplesToMix
  000c9	8b fb		 mov	 edi, ebx

; 990  : 			samplesToMix = maxSamplesToMix;
; 991  : 
; 992  : 		outputAudio(outStream, samplesToMix);

  000cb	48 8b ce	 mov	 rcx, rsi
  000ce	0f 4f 3d 00 00
	00 00		 cmovg	 edi, DWORD PTR maxSamplesToMix
  000d5	8b d7		 mov	 edx, edi
  000d7	e8 00 00 00 00	 call	 outputAudio

; 993  : 		outStream += (uint32_t)samplesToMix * 2;
; 994  : 
; 995  : 		smpCounter -= samplesToMix;

  000dc	2b df		 sub	 ebx, edi
  000de	8d 04 3f	 lea	 eax, DWORD PTR [rdi+rdi]
  000e1	48 8d 34 46	 lea	 rsi, QWORD PTR [rsi+rax*2]
  000e5	85 db		 test	 ebx, ebx
  000e7	7f da		 jg	 SHORT $LL11@mod2WavThr
  000e9	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR samplesPerTick
$LN12@mod2WavThr:

; 996  : 	}
; 997  : 
; 998  : 	return (uint32_t)samplesPerTick * 2; // * 2 for stereo

  000ef	03 db		 add	 ebx, ebx

; 1020 : 		if (size > 0)

  000f1	74 18		 je	 SHORT $LN5@mod2WavThr

; 1021 : 		{
; 1022 : 			fwrite(editor.mod2WavBuffer, sizeof (int16_t), size, fOut);

  000f3	48 8b 0d 98 22
	00 00		 mov	 rcx, QWORD PTR editor+8856
  000fa	4c 8b cd	 mov	 r9, rbp
  000fd	44 8b c3	 mov	 r8d, ebx
  00100	49 8b d5	 mov	 rdx, r13
  00103	e8 00 00 00 00	 call	 fwrite

; 1023 : 			totalSampleCounter += size;

  00108	44 03 f3	 add	 r14d, ebx
$LN5@mod2WavThr:

; 1024 : 		}
; 1025 : 
; 1026 : 		editor.ui.updateMod2WavDialog = true;

  0010b	0f b6 05 3e 00
	00 00		 movzx	 eax, BYTE PTR editor+62
  00112	44 88 3d 06 38
	00 00		 mov	 BYTE PTR editor+14342, r15b
  00119	84 c0		 test	 al, al
  0011b	0f 85 5f ff ff
	ff		 jne	 $LL2@mod2WavThr
$LN27@mod2WavThr:
  00121	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR [rsp+136]
  00129	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  00131	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR [rsp+144]
$LN24@mod2WavThr:

; 1027 : 	}
; 1028 : 
; 1029 : 	if (totalSampleCounter & 1)

  00139	45 84 f7	 test	 r14b, r15b
  0013c	74 0a		 je	 SHORT $LN6@mod2WavThr

; 1030 : 		fputc(0, fOut); // pad align byte

  0013e	48 8b d5	 mov	 rdx, rbp
  00141	33 c9		 xor	 ecx, ecx
  00143	e8 00 00 00 00	 call	 fputc
$LN6@mod2WavThr:

; 1031 : 
; 1032 : 	if ((ftell(fOut) - 8) > 0)

  00148	48 8b cd	 mov	 rcx, rbp
  0014b	e8 00 00 00 00	 call	 ftell
  00150	83 e8 08	 sub	 eax, 8
  00153	85 c0		 test	 eax, eax
  00155	7e 0c		 jle	 SHORT $LN7@mod2WavThr

; 1033 : 		totalRiffChunkLen = ftell(fOut) - 8;

  00157	48 8b cd	 mov	 rcx, rbp
  0015a	e8 00 00 00 00	 call	 ftell
  0015f	44 8d 60 f8	 lea	 r12d, DWORD PTR [rax-8]
$LN7@mod2WavThr:

; 1034 : 	else
; 1035 : 		totalRiffChunkLen = 0;
; 1036 : 
; 1037 : 	editor.ui.mod2WavFinished = true;
; 1038 : 	editor.ui.updateMod2WavDialog = true;
; 1039 : 
; 1040 : 	// go back and fill the missing WAV header
; 1041 : 	fseek(fOut, 0, SEEK_SET);

  00163	45 33 c0	 xor	 r8d, r8d
  00166	66 c7 05 06 38
	00 00 01 01	 mov	 WORD PTR editor+14342, 257 ; 00000101H
  0016f	33 d2		 xor	 edx, edx
  00171	48 8b cd	 mov	 rcx, rbp
  00174	e8 00 00 00 00	 call	 fseek

; 1042 : 
; 1043 : 	wavHeader.chunkID = 0x46464952; // "RIFF"
; 1044 : 	wavHeader.chunkSize = totalRiffChunkLen;
; 1045 : 	wavHeader.format = 0x45564157; // "WAVE"
; 1046 : 	wavHeader.subchunk1ID = 0x20746D66; // "fmt "
; 1047 : 	wavHeader.subchunk1Size = 16;
; 1048 : 	wavHeader.audioFormat = 1;
; 1049 : 	wavHeader.numChannels = 2;
; 1050 : 	wavHeader.sampleRate = audio.audioFreq;

  00179	8b 05 40 05 00
	00		 mov	 eax, DWORD PTR audio+1344
  0017f	b9 10 00 00 00	 mov	 ecx, 16
  00184	89 44 24 38	 mov	 DWORD PTR wavHeader$[rsp+24], eax

; 1051 : 	wavHeader.bitsPerSample = 16;
; 1052 : 	wavHeader.byteRate = wavHeader.sampleRate * wavHeader.numChannels * (wavHeader.bitsPerSample / 8);
; 1053 : 	wavHeader.blockAlign = wavHeader.numChannels * (wavHeader.bitsPerSample / 8);
; 1054 : 	wavHeader.subchunk2ID = 0x61746164; // "data"
; 1055 : 	wavHeader.subchunk2Size = totalSampleCounter * (wavHeader.bitsPerSample / 8);
; 1056 : 
; 1057 : 	fwrite(&wavHeader, sizeof (wavHeader_t), 1, fOut);

  00188	4c 8b cd	 mov	 r9, rbp
  0018b	89 4c 24 30	 mov	 DWORD PTR wavHeader$[rsp+16], ecx
  0018f	4d 8b c7	 mov	 r8, r15
  00192	c7 44 24 20 52
	49 46 46	 mov	 DWORD PTR wavHeader$[rsp], 1179011410 ; 46464952H
  0019a	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR [rax*4]
  001a1	44 89 64 24 24	 mov	 DWORD PTR wavHeader$[rsp+4], r12d
  001a6	89 44 24 3c	 mov	 DWORD PTR wavHeader$[rsp+28], eax
  001aa	8d 51 1c	 lea	 edx, QWORD PTR [rcx+28]
  001ad	43 8d 04 36	 lea	 eax, DWORD PTR [r14+r14]
  001b1	c7 44 24 28 57
	41 56 45	 mov	 DWORD PTR wavHeader$[rsp+8], 1163280727 ; 45564157H
  001b9	48 8d 4c 24 20	 lea	 rcx, QWORD PTR wavHeader$[rsp]
  001be	89 44 24 48	 mov	 DWORD PTR wavHeader$[rsp+40], eax
  001c2	c7 44 24 2c 66
	6d 74 20	 mov	 DWORD PTR wavHeader$[rsp+12], 544501094 ; 20746d66H
  001ca	c7 44 24 34 01
	00 02 00	 mov	 DWORD PTR wavHeader$[rsp+20], 131073 ; 00020001H
  001d2	c7 44 24 40 04
	00 10 00	 mov	 DWORD PTR wavHeader$[rsp+32], 1048580 ; 00100004H
  001da	c7 44 24 44 64
	61 74 61	 mov	 DWORD PTR wavHeader$[rsp+36], 1635017060 ; 61746164H
  001e2	e8 00 00 00 00	 call	 fwrite

; 1058 : 	fclose(fOut);

  001e7	48 8b cd	 mov	 rcx, rbp
  001ea	e8 00 00 00 00	 call	 fclose

; 1059 : 
; 1060 : 	return true;

  001ef	4c 8b 74 24 50	 mov	 r14, QWORD PTR [rsp+80]
  001f4	41 8b c7	 mov	 eax, r15d
  001f7	4c 8b 6c 24 58	 mov	 r13, QWORD PTR [rsp+88]
  001fc	4c 8b 64 24 60	 mov	 r12, QWORD PTR [rsp+96]

; 1061 : }

  00201	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00205	41 5f		 pop	 r15
  00207	5d		 pop	 rbp
  00208	c3		 ret	 0
mod2WavThreadFunc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\sys\stat.h
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_mouse.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_mouse.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_textout.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_textout.c
; File C:\Programming\pt2-clone\src\pt2_mouse.c
; File C:\Programming\pt2-clone\src\pt2_textout.c
; File C:\Programming\pt2-clone\src\pt2_mouse.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_modplayer.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_mouse.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_mouse.c
; File C:\Programming\pt2-clone\src\pt2_modplayer.c
; File C:\Programming\pt2-clone\src\pt2_textout.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Programming\pt2-clone\src\pt2_textout.c
; File C:\Programming\pt2-clone\src\pt2_mouse.c
; File C:\Programming\pt2-clone\src\pt2_textout.c
; File C:\Programming\pt2-clone\src\pt2_mouse.c
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT renderToWav
_TEXT	SEGMENT
statBuffer$ = 48
fileName$ = 112
checkIfFileExist$ = 120
renderToWav PROC					; COMDAT

; 1064 : {

$LN106:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8b d9	 mov	 rbx, rcx

; 1065 : 	FILE *fOut;
; 1066 : 	struct stat statBuffer;
; 1067 : 
; 1068 : 	if (checkIfFileExist)

  0000d	84 d2		 test	 dl, dl
  0000f	74 6f		 je	 SHORT $LN3@renderToWa
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\sys\stat.h

; 242  :             return _stat64i32(_FileName, (struct _stat64i32*)_Stat);

  00011	48 8d 54 24 30	 lea	 rdx, QWORD PTR statBuffer$[rsp]
  00016	e8 00 00 00 00	 call	 _stat64i32
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 1070 : 		if (stat(fileName, &statBuffer) == 0)

  0001b	85 c0		 test	 eax, eax
  0001d	75 61		 jne	 SHORT $LN3@renderToWa
; File C:\Programming\pt2-clone\src\pt2_mouse.c

; 105  : 		case POINTER_MODE_MSG1:   pointerSetColor(POINTER_PURPLE); break;

  0001f	b1 03		 mov	 cl, 3
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 1072 : 			editor.ui.askScreenShown = true;

  00021	c6 05 dc 37 00
	00 01		 mov	 BYTE PTR editor+14300, 1

; 1073 : 			editor.ui.askScreenType = ASK_MOD2WAV_OVERWRITE;

  00028	c6 05 fc 37 00
	00 05		 mov	 BYTE PTR editor+14332, 5
; File C:\Programming\pt2-clone\src\pt2_mouse.c

; 95   : 	editor.ui.pointerMode = pointerMode;

  0002f	c6 05 f9 37 00
	00 03		 mov	 BYTE PTR editor+14329, 3

; 105  : 		case POINTER_MODE_MSG1:   pointerSetColor(POINTER_PURPLE); break;

  00036	e8 00 00 00 00	 call	 pointerSetColor
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 1073 : 			editor.ui.askScreenType = ASK_MOD2WAV_OVERWRITE;

  0003b	33 db		 xor	 ebx, ebx
  0003d	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:__ImageBase
  00044	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL27@renderToWa:
; File C:\Programming\pt2-clone\src\pt2_textout.c

; 615  : 	strcpy(editor.ui.statusMessage, msg);

  00050	0f b6 84 3b 00
	00 00 00	 movzx	 eax, BYTE PTR ??_C@_0BA@ELDAEBLE@OVERWRITE?5FILE?$DP@[rbx+rdi]
  00058	88 84 3b 90 37
	00 00		 mov	 BYTE PTR editor[rbx+rdi+14224], al
  0005f	48 8d 5b 01	 lea	 rbx, QWORD PTR [rbx+1]
  00063	84 c0		 test	 al, al
  00065	75 e9		 jne	 SHORT $LL27@renderToWa

; 616  : 	editor.ui.updateStatusText = true;

  00067	c6 05 03 38 00
	00 01		 mov	 BYTE PTR editor+14339, 1
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 1078 : 			renderAskDialog();

  0006e	e8 00 00 00 00	 call	 renderAskDialog

; 1079 : 
; 1080 : 			return false;

  00073	32 c0		 xor	 al, al

; 1132 : }

  00075	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  0007a	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0007e	5f		 pop	 rdi
  0007f	c3		 ret	 0
$LN3@renderToWa:

; 1081 : 		}
; 1082 : 	}
; 1083 : 
; 1084 : 	if (editor.ui.askScreenShown)

  00080	80 3d dc 37 00
	00 00		 cmp	 BYTE PTR editor+14300, 0
  00087	48 89 74 24 70	 mov	 QWORD PTR [rsp+112], rsi
  0008c	74 10		 je	 SHORT $LN4@renderToWa

; 1085 : 	{
; 1086 : 		editor.ui.askScreenShown = false;

  0008e	c6 05 dc 37 00
	00 00		 mov	 BYTE PTR editor+14300, 0

; 1087 : 		editor.ui.answerNo = false;

  00095	66 c7 05 d8 37
	00 00 00 00	 mov	 WORD PTR editor+14296, 0
$LN4@renderToWa:

; 1088 : 		editor.ui.answerYes = false;
; 1089 : 	}
; 1090 : 
; 1091 : 	fOut = fopen(fileName, "wb");

  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02GMLFBBN@wb@
  000a5	48 8b cb	 mov	 rcx, rbx
  000a8	e8 00 00 00 00	 call	 fopen
  000ad	48 8b f0	 mov	 rsi, rax

; 1092 : 	if (fOut == NULL)

  000b0	48 85 c0	 test	 rax, rax
  000b3	75 52		 jne	 SHORT $LN5@renderToWa
; File C:\Programming\pt2-clone\src\pt2_textout.c

; 635  : 	editor.errorMsgActive = true;

  000b5	66 c7 05 08 01
	00 00 01 01	 mov	 WORD PTR editor+264, 257 ; 00000101H
  000be	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:__ImageBase

; 636  : 	editor.errorMsgBlock = true;
; 637  : 	editor.errorMsgCounter = 0;

  000c5	88 05 82 22 00
	00		 mov	 BYTE PTR editor+8834, al
  000cb	33 db		 xor	 ebx, ebx
  000cd	0f 1f 00	 npad	 3
$LL35@renderToWa:

; 615  : 	strcpy(editor.ui.statusMessage, msg);

  000d0	0f b6 84 3b 00
	00 00 00	 movzx	 eax, BYTE PTR ??_C@_0P@KJEHIBPC@FILE?5I?1O?5ERROR@[rbx+rdi]
  000d8	88 84 3b 90 37
	00 00		 mov	 BYTE PTR editor[rbx+rdi+14224], al
  000df	48 8d 5b 01	 lea	 rbx, QWORD PTR [rbx+1]
  000e3	84 c0		 test	 al, al
  000e5	75 e9		 jne	 SHORT $LL35@renderToWa
; File C:\Programming\pt2-clone\src\pt2_mouse.c

; 126  : 	pointerSetColor(POINTER_RED);

  000e7	b1 05		 mov	 cl, 5
; File C:\Programming\pt2-clone\src\pt2_textout.c

; 616  : 	editor.ui.updateStatusText = true;

  000e9	c6 05 03 38 00
	00 01		 mov	 BYTE PTR editor+14339, 1
; File C:\Programming\pt2-clone\src\pt2_mouse.c

; 126  : 	pointerSetColor(POINTER_RED);

  000f0	e8 00 00 00 00	 call	 pointerSetColor
  000f5	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 1128 : 		return false;

  000fa	32 c0		 xor	 al, al

; 1132 : }

  000fc	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  00101	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00105	5f		 pop	 rdi
  00106	c3		 ret	 0
$LN5@renderToWa:
; File C:\Programming\pt2-clone\src\pt2_modplayer.c

; 97   : 	oldBPM = modEntry->currBPM;

  00107	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR modEntry
  0010e	0f b7 41 1a	 movzx	 eax, WORD PTR [rcx+26]
  00112	66 89 05 00 00
	00 00		 mov	 WORD PTR oldBPM, ax

; 98   : 	oldRow = modEntry->currRow;

  00119	0f b6 41 10	 movzx	 eax, BYTE PTR [rcx+16]
  0011d	88 05 00 00 00
	00		 mov	 BYTE PTR oldRow, al

; 99   : 	oldOrder = modEntry->currOrder;

  00123	0f b7 41 16	 movzx	 eax, WORD PTR [rcx+22]
  00127	66 89 05 00 00
	00 00		 mov	 WORD PTR oldOrder, ax

; 100  : 	oldSpeed = modEntry->currSpeed;

  0012e	0f b6 41 13	 movzx	 eax, BYTE PTR [rcx+19]
  00132	88 05 00 00 00
	00		 mov	 BYTE PTR oldSpeed, al

; 101  : 	oldPattern = modEntry->currPattern;

  00138	0f b7 41 18	 movzx	 eax, WORD PTR [rcx+24]
  0013c	66 89 05 00 00
	00 00		 mov	 WORD PTR oldPattern, ax
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 1099 : 	calcMod2WavTotalRows();

  00143	e8 00 00 00 00	 call	 calcMod2WavTotalRows

; 1100 : 	restartSong();

  00148	e8 00 00 00 00	 call	 restartSong
; File C:\Programming\pt2-clone\src\pt2_mouse.c

; 106  : 		case POINTER_MODE_MSG2:   pointerSetColor(POINTER_GREEN);  break;

  0014d	b1 04		 mov	 cl, 4
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 1102 : 	editor.blockMarkFlag = false;

  0014f	c6 05 1d 01 00
	00 00		 mov	 BYTE PTR editor+285, 0
; File C:\Programming\pt2-clone\src\pt2_mouse.c

; 95   : 	editor.ui.pointerMode = pointerMode;

  00156	c6 05 f9 37 00
	00 05		 mov	 BYTE PTR editor+14329, 5

; 106  : 		case POINTER_MODE_MSG2:   pointerSetColor(POINTER_GREEN);  break;

  0015d	e8 00 00 00 00	 call	 pointerSetColor
; File C:\Programming\pt2-clone\src\pt2_modplayer.c

; 97   : 	oldBPM = modEntry->currBPM;

  00162	33 db		 xor	 ebx, ebx
  00164	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:__ImageBase
  0016b	8b cb		 mov	 ecx, ebx
  0016d	0f 1f 00	 npad	 3
$LL56@renderToWa:
; File C:\Programming\pt2-clone\src\pt2_textout.c

; 615  : 	strcpy(editor.ui.statusMessage, msg);

  00170	0f b6 84 39 00
	00 00 00	 movzx	 eax, BYTE PTR ??_C@_0BB@JCAIEAIK@RENDERING?5MOD?4?4?4@[rcx+rdi]
  00178	88 84 39 90 37
	00 00		 mov	 BYTE PTR editor[rcx+rdi+14224], al
  0017f	48 8d 49 01	 lea	 rcx, QWORD PTR [rcx+1]
  00183	84 c0		 test	 al, al
  00185	75 e9		 jne	 SHORT $LL56@renderToWa

; 616  : 	editor.ui.updateStatusText = true;

  00187	c6 05 03 38 00
	00 01		 mov	 BYTE PTR editor+14339, 1
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 1107 : 	editor.ui.disableVisualizer = true;

  0018e	c6 05 36 38 00
	00 01		 mov	 BYTE PTR editor+14390, 1

; 1108 : 	editor.isWAVRendering = true;

  00195	c6 05 3e 00 00
	00 01		 mov	 BYTE PTR editor+62, 1

; 1109 : 	renderMOD2WAVDialog();

  0019c	e8 00 00 00 00	 call	 renderMOD2WAVDialog

; 1110 : 
; 1111 : 	editor.abortMod2Wav = false;
; 1112 : 
; 1113 : 	editor.mod2WavThread = SDL_CreateThread(mod2WavThreadFunc, NULL, fOut);

  001a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_endthreadex
  001a8	88 1d 21 01 00
	00		 mov	 BYTE PTR editor+289, bl
  001ae	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_beginthreadex
  001b5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ba	4c 8b c6	 mov	 r8, rsi
  001bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mod2WavThreadFunc
  001c4	33 d2		 xor	 edx, edx
  001c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SDL_CreateThread
  001cc	48 89 05 f8 34
	00 00		 mov	 QWORD PTR editor+13560, rax

; 1114 : 	if (editor.mod2WavThread != NULL)

  001d3	48 85 c0	 test	 rax, rax
  001d6	74 1b		 je	 SHORT $LN6@renderToWa

; 1115 : 	{
; 1116 : 		SDL_DetachThread(editor.mod2WavThread);

  001d8	48 8b c8	 mov	 rcx, rax
  001db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SDL_DetachThread
  001e1	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]

; 1129 : 	}
; 1130 : 
; 1131 : 	return true;

  001e6	b0 01		 mov	 al, 1

; 1132 : }

  001e8	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  001ed	48 83 c4 60	 add	 rsp, 96			; 00000060H
  001f1	5f		 pop	 rdi
  001f2	c3		 ret	 0
$LN6@renderToWa:

; 1117 : 	}
; 1118 : 	else
; 1119 : 	{
; 1120 : 		editor.ui.disableVisualizer = false;

  001f3	88 1d 36 38 00
	00		 mov	 BYTE PTR editor+14390, bl

; 1121 : 		editor.isWAVRendering = false;

  001f9	88 1d 3e 00 00
	00		 mov	 BYTE PTR editor+62, bl
; File C:\Programming\pt2-clone\src\pt2_textout.c

; 635  : 	editor.errorMsgActive = true;

  001ff	66 c7 05 08 01
	00 00 01 01	 mov	 WORD PTR editor+264, 257 ; 00000101H

; 636  : 	editor.errorMsgBlock = true;
; 637  : 	editor.errorMsgCounter = 0;

  00208	88 1d 82 22 00
	00		 mov	 BYTE PTR editor+8834, bl
  0020e	66 90		 npad	 2
$LL64@renderToWa:

; 615  : 	strcpy(editor.ui.statusMessage, msg);

  00210	0f b6 84 3b 00
	00 00 00	 movzx	 eax, BYTE PTR ??_C@_0N@HDBMFKCM@THREAD?5ERROR@[rbx+rdi]
  00218	88 84 3b 90 37
	00 00		 mov	 BYTE PTR editor[rbx+rdi+14224], al
  0021f	48 8d 5b 01	 lea	 rbx, QWORD PTR [rbx+1]
  00223	84 c0		 test	 al, al
  00225	75 e9		 jne	 SHORT $LL64@renderToWa
; File C:\Programming\pt2-clone\src\pt2_mouse.c

; 126  : 	pointerSetColor(POINTER_RED);

  00227	b1 05		 mov	 cl, 5
; File C:\Programming\pt2-clone\src\pt2_textout.c

; 616  : 	editor.ui.updateStatusText = true;

  00229	c6 05 03 38 00
	00 01		 mov	 BYTE PTR editor+14339, 1
; File C:\Programming\pt2-clone\src\pt2_mouse.c

; 126  : 	pointerSetColor(POINTER_RED);

  00230	e8 00 00 00 00	 call	 pointerSetColor

; 101  : 		case POINTER_MODE_IDLE:   pointerSetColor(POINTER_GRAY);   break;

  00235	33 c9		 xor	 ecx, ecx
  00237	c6 05 f9 37 00
	00 00		 mov	 BYTE PTR editor+14329, 0
  0023e	c6 05 fe 37 00
	00 00		 mov	 BYTE PTR editor+14334, 0
  00245	e8 00 00 00 00	 call	 pointerSetColor
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 1126 : 		statusAllRight();

  0024a	e8 00 00 00 00	 call	 statusAllRight
  0024f	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]

; 1128 : 		return false;

  00254	32 c0		 xor	 al, al

; 1132 : }

  00256	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  0025b	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0025f	5f		 pop	 rdi
  00260	c3		 ret	 0
renderToWav ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT calcMod2WavTotalRows
_TEXT	SEGMENT
n_loopcount$ = 96
n_pattpos$ = 104
calcMod2WavTotalRows PROC				; COMDAT

; 1136 : {

$LN55:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1137 : 	bool pBreakFlag, posJumpAssert, calcingRows;
; 1138 : 	int8_t n_pattpos[AMIGA_VOICES], n_loopcount[AMIGA_VOICES];
; 1139 : 	uint8_t modRow, pBreakPosition, ch, pos;
; 1140 : 	int16_t modOrder;
; 1141 : 	uint16_t modPattern;
; 1142 : 	note_t *note;
; 1143 : 
; 1144 : 	// for pattern loop
; 1145 : 	memset(n_pattpos, 0, sizeof (n_pattpos));
; 1146 : 	memset(n_loopcount, 0, sizeof (n_loopcount));
; 1147 : 
; 1148 : 	modEntry->rowsCounter = 0;

  00014	4c 8b 3d 00 00
	00 00		 mov	 r15, QWORD PTR modEntry

; 1149 : 	modEntry->rowsInTotal = 0;
; 1150 : 
; 1151 : 	modRow = 0;
; 1152 : 	modOrder = 0;
; 1153 : 	modPattern = modEntry->head.order[0];
; 1154 : 	pBreakPosition = 0;
; 1155 : 	posJumpAssert = false;
; 1156 : 	pBreakFlag = false;
; 1157 : 	calcingRows = true;
; 1158 : 
; 1159 : 	memset(editor.rowVisitTable, 0, MOD_ORDERS * MOD_ROWS);

  0001b	48 8d 0d 23 01
	00 00		 lea	 rcx, OFFSET FLAT:editor+291
  00022	33 c0		 xor	 eax, eax
  00024	32 db		 xor	 bl, bl
  00026	40 32 ff	 xor	 dil, dil
  00029	89 44 24 68	 mov	 DWORD PTR n_pattpos$[rsp], eax
  0002d	45 32 f6	 xor	 r14b, r14b
  00030	89 44 24 60	 mov	 DWORD PTR n_loopcount$[rsp], eax
  00034	45 0f b7 67 3c	 movzx	 r12d, WORD PTR [r15+60]
  00039	40 32 ed	 xor	 bpl, bpl
  0003c	33 d2		 xor	 edx, edx
  0003e	49 89 47 1c	 mov	 QWORD PTR [r15+28], rax
  00042	41 b8 00 20 00
	00		 mov	 r8d, 8192		; 00002000H
  00048	0f b7 f0	 movzx	 esi, ax
  0004b	41 b5 01	 mov	 r13b, 1
  0004e	e8 00 00 00 00	 call	 memset
  00053	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:editor
  0005a	66 0f 1f 44 00
	00		 npad	 6
$LL2@calcMod2Wa:

; 1161 : 	{
; 1162 : 		editor.rowVisitTable[(modOrder * MOD_ROWS) + modRow] = true;

  00060	0f bf c6	 movsx	 eax, si
  00063	c1 e0 06	 shl	 eax, 6
  00066	0f b6 cb	 movzx	 ecx, bl
  00069	03 c1		 add	 eax, ecx
  0006b	48 98		 cdqe

; 1163 : 
; 1164 : 		for (ch = 0; ch < AMIGA_VOICES; ch++)

  0006d	45 32 c9	 xor	 r9b, r9b
  00070	44 8d 14 8d 00
	00 00 00	 lea	 r10d, DWORD PTR [rcx*4]
  00078	42 c6 84 00 23
	01 00 00 01	 mov	 BYTE PTR [rax+r8+291], 1
  00081	41 0f b7 c4	 movzx	 eax, r12w
  00085	4d 8d 1c c7	 lea	 r11, QWORD PTR [r15+rax*8]
  00089	0f 1f 80 00 00
	00 00		 npad	 7
$LL6@calcMod2Wa:

; 1165 : 		{
; 1166 : 			note = &modEntry->patterns[modPattern][(modRow * AMIGA_VOICES) + ch];

  00090	41 0f b6 c1	 movzx	 eax, r9b
  00094	41 03 c2	 add	 eax, r10d
  00097	48 8d 0c 40	 lea	 rcx, QWORD PTR [rax+rax*2]
  0009b	49 8b 83 00 0c
	00 00		 mov	 rax, QWORD PTR [r11+3072]
  000a2	48 8d 14 48	 lea	 rdx, QWORD PTR [rax+rcx*2]

; 1167 : 			if (note->command == 0x0B) // Bxx - Position Jump

  000a6	0f b6 44 48 02	 movzx	 eax, BYTE PTR [rax+rcx*2+2]
  000ab	3c 0b		 cmp	 al, 11
  000ad	75 11		 jne	 SHORT $LN13@calcMod2Wa

; 1168 : 			{
; 1169 : 				modOrder = note->param - 1;

  000af	0f b6 32	 movzx	 esi, BYTE PTR [rdx]

; 1170 : 				pBreakPosition = 0;
; 1171 : 				posJumpAssert = true;

  000b2	41 b6 01	 mov	 r14b, 1
  000b5	66 ff ce	 dec	 si
  000b8	40 32 ff	 xor	 dil, dil

; 1172 : 			}

  000bb	e9 9f 01 00 00	 jmp	 $LN4@calcMod2Wa
$LN13@calcMod2Wa:

; 1173 : 			else if (note->command == 0x0D) // Dxx - Pattern Break

  000c0	3c 0d		 cmp	 al, 13
  000c2	75 2a		 jne	 SHORT $LN15@calcMod2Wa

; 1174 : 			{
; 1175 : 				pBreakPosition = (((note->param >> 4) * 10) + (note->param & 0x0F));

  000c4	0f b6 0a	 movzx	 ecx, BYTE PTR [rdx]

; 1176 : 				if (pBreakPosition > 63)
; 1177 : 					pBreakPosition = 0;
; 1178 : 
; 1179 : 				posJumpAssert = true;

  000c7	33 ff		 xor	 edi, edi
  000c9	0f b6 d1	 movzx	 edx, cl
  000cc	41 b6 01	 mov	 r14b, 1
  000cf	c0 ea 04	 shr	 dl, 4
  000d2	80 e1 0f	 and	 cl, 15
  000d5	0f b6 c2	 movzx	 eax, dl
  000d8	c0 e0 02	 shl	 al, 2
  000db	02 d0		 add	 dl, al
  000dd	02 d2		 add	 dl, dl
  000df	02 d1		 add	 dl, cl
  000e1	0f b6 c2	 movzx	 eax, dl
  000e4	3c 3f		 cmp	 al, 63			; 0000003fH
  000e6	0f 46 f8	 cmovbe	 edi, eax

; 1180 : 			}

  000e9	e9 71 01 00 00	 jmp	 $LN4@calcMod2Wa
$LN15@calcMod2Wa:

; 1181 : 			else if (note->command == 0x0F && note->param == 0) // F00 - Set Speed 0 (stop)

  000ee	3c 0f		 cmp	 al, 15
  000f0	0f 85 a6 00 00
	00		 jne	 $LN47@calcMod2Wa
  000f6	80 3a 00	 cmp	 BYTE PTR [rdx], 0
  000f9	0f 85 60 01 00
	00		 jne	 $LN4@calcMod2Wa

; 1182 : 			{
; 1183 : 				calcingRows = false;

  000ff	45 32 ed	 xor	 r13b, r13b
$LN52@calcMod2Wa:

; 1215 : 						}
; 1216 : 					}
; 1217 : 				}
; 1218 : 			}
; 1219 : 		}
; 1220 : 
; 1221 : 		modRow++;
; 1222 : 		modEntry->rowsInTotal++;

  00102	41 ff 47 20	 inc	 DWORD PTR [r15+32]

; 1223 : 
; 1224 : 		if (pBreakFlag)
; 1225 : 		{
; 1226 : 			modRow = pBreakPosition;
; 1227 : 			pBreakPosition = 0;
; 1228 : 			pBreakFlag = false;
; 1229 : 		}
; 1230 : 
; 1231 : 		if (modRow >= MOD_ROWS || posJumpAssert)

  00106	33 c9		 xor	 ecx, ecx
  00108	40 84 ed	 test	 bpl, bpl
  0010b	40 0f b6 c7	 movzx	 eax, dil
  0010f	0f 44 c8	 cmove	 ecx, eax
  00112	8d 43 01	 lea	 eax, DWORD PTR [rbx+1]
  00115	0f b6 c0	 movzx	 eax, al
  00118	40 0f b6 df	 movzx	 ebx, dil
  0011c	0f 44 d8	 cmove	 ebx, eax
  0011f	80 fb 40	 cmp	 bl, 64			; 00000040H
  00122	73 08		 jae	 SHORT $LN28@calcMod2Wa
  00124	0f b6 f9	 movzx	 edi, cl
  00127	45 84 f6	 test	 r14b, r14b
  0012a	74 30		 je	 SHORT $LN30@calcMod2Wa
$LN28@calcMod2Wa:

; 1232 : 		{
; 1233 : 			modRow = pBreakPosition;
; 1234 : 			pBreakPosition = 0;
; 1235 : 			posJumpAssert = false;
; 1236 : 
; 1237 : 			modOrder = (modOrder + 1) & 0x7F;

  0012c	66 ff c6	 inc	 si
  0012f	40 32 ff	 xor	 dil, dil
  00132	66 83 e6 7f	 and	 si, 127			; 0000007fH
  00136	45 32 f6	 xor	 r14b, r14b
  00139	0f b6 d9	 movzx	 ebx, cl
  0013c	0f b7 c6	 movzx	 eax, si

; 1238 : 			if (modOrder >= modEntry->head.orderCount)

  0013f	66 41 3b b7 3c
	01 00 00	 cmp	 si, WORD PTR [r15+316]
  00147	73 3e		 jae	 SHORT $LN38@calcMod2Wa

; 1239 : 			{
; 1240 : 				modOrder = 0;
; 1241 : 				calcingRows = false;
; 1242 : 				break;
; 1243 : 			}
; 1244 : 
; 1245 : 			modPattern = modEntry->head.order[modOrder];

  00149	45 0f b7 64 47
	3c		 movzx	 r12d, WORD PTR [r15+rax*2+60]

; 1246 : 			if (modPattern > MAX_PATTERNS-1)

  0014f	66 41 83 fc 63	 cmp	 r12w, 99		; 00000063H
  00154	76 06		 jbe	 SHORT $LN30@calcMod2Wa

; 1247 : 				modPattern = MAX_PATTERNS-1;

  00156	41 bc 63 00 00
	00		 mov	 r12d, 99		; 00000063H
$LN30@calcMod2Wa:

; 1248 : 		}
; 1249 : 
; 1250 : 		if (editor.rowVisitTable[(modOrder * MOD_ROWS) + modRow])

  0015c	0f b6 c3	 movzx	 eax, bl
  0015f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:editor
  00166	0f bf ce	 movsx	 ecx, si
  00169	c1 e1 06	 shl	 ecx, 6
  0016c	03 c1		 add	 eax, ecx
  0016e	48 98		 cdqe
  00170	42 80 bc 00 23
	01 00 00 00	 cmp	 BYTE PTR [rax+r8+291], 0
  00179	75 0c		 jne	 SHORT $LN38@calcMod2Wa

; 1160 : 	while (calcingRows)

  0017b	40 32 ed	 xor	 bpl, bpl
  0017e	45 84 ed	 test	 r13b, r13b
  00181	0f 85 d9 fe ff
	ff		 jne	 $LL2@calcMod2Wa
$LN38@calcMod2Wa:

; 1251 : 		{
; 1252 : 			// row has been visited before, we're now done!
; 1253 : 			calcingRows = false;
; 1254 : 			break;
; 1255 : 		}
; 1256 : 	}
; 1257 : }

  00187	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0018c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00190	41 5f		 pop	 r15
  00192	41 5e		 pop	 r14
  00194	41 5d		 pop	 r13
  00196	41 5c		 pop	 r12
  00198	5f		 pop	 rdi
  00199	5e		 pop	 rsi
  0019a	5d		 pop	 rbp
  0019b	c3		 ret	 0
$LN47@calcMod2Wa:

; 1184 : 				break;
; 1185 : 			}
; 1186 : 			else if (note->command == 0x0E && (note->param >> 4) == 0x06) // E6x - Pattern Loop

  0019c	3c 0e		 cmp	 al, 14
  0019e	0f 85 bb 00 00
	00		 jne	 $LN4@calcMod2Wa
  001a4	0f b6 0a	 movzx	 ecx, BYTE PTR [rdx]
  001a7	0f b6 c1	 movzx	 eax, cl
  001aa	24 f0		 and	 al, 240			; 000000f0H
  001ac	3c 60		 cmp	 al, 96			; 00000060H
  001ae	0f 85 ab 00 00
	00		 jne	 $LN4@calcMod2Wa

; 1187 : 			{
; 1188 : 				pos = note->param & 0x0F;

  001b4	41 0f b6 c1	 movzx	 eax, r9b
  001b8	80 e1 0f	 and	 cl, 15

; 1189 : 				if (pos == 0)

  001bb	75 09		 jne	 SHORT $LN21@calcMod2Wa

; 1190 : 				{
; 1191 : 					n_pattpos[ch] = modRow;

  001bd	88 5c 04 68	 mov	 BYTE PTR n_pattpos$[rsp+rax], bl

; 1192 : 				}

  001c1	e9 99 00 00 00	 jmp	 $LN4@calcMod2Wa
$LN21@calcMod2Wa:

; 1193 : 				else
; 1194 : 				{
; 1195 : 					// this is so ugly
; 1196 : 					if (n_loopcount[ch] == 0)

  001c6	0f b6 54 04 60	 movzx	 edx, BYTE PTR n_loopcount$[rsp+rax]
  001cb	84 d2		 test	 dl, dl
  001cd	75 3e		 jne	 SHORT $LN23@calcMod2Wa

; 1197 : 					{
; 1198 : 						n_loopcount[ch] = pos;
; 1199 : 
; 1200 : 						pBreakPosition = n_pattpos[ch];

  001cf	0f b6 7c 04 68	 movzx	 edi, BYTE PTR n_pattpos$[rsp+rax]

; 1201 : 						pBreakFlag = true;

  001d4	40 b5 01	 mov	 bpl, 1
  001d7	88 4c 04 60	 mov	 BYTE PTR n_loopcount$[rsp+rax], cl

; 1202 : 
; 1203 : 						for (pos = pBreakPosition; pos <= modRow; pos++)

  001db	40 0f b6 d7	 movzx	 edx, dil
  001df	40 3a fb	 cmp	 dil, bl
  001e2	77 7b		 ja	 SHORT $LN4@calcMod2Wa
  001e4	44 0f bf c6	 movsx	 r8d, si
  001e8	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:editor
  001ef	41 c1 e0 06	 shl	 r8d, 6
$LL9@calcMod2Wa:

; 1204 : 							editor.rowVisitTable[(modOrder * MOD_ROWS) + pos] = false;

  001f3	0f b6 c2	 movzx	 eax, dl
  001f6	fe c2		 inc	 dl
  001f8	41 03 c0	 add	 eax, r8d
  001fb	48 63 c8	 movsxd	 rcx, eax
  001fe	42 c6 84 39 23
	01 00 00 00	 mov	 BYTE PTR [rcx+r15+291], 0
  00207	3a d3		 cmp	 dl, bl
  00209	76 e8		 jbe	 SHORT $LL9@calcMod2Wa

; 1205 : 					}

  0020b	eb 4b		 jmp	 SHORT $LN53@calcMod2Wa
$LN23@calcMod2Wa:

; 1206 : 					else
; 1207 : 					{
; 1208 : 						if (--n_loopcount[ch])

  0020d	80 ea 01	 sub	 dl, 1
  00210	88 54 04 60	 mov	 BYTE PTR n_loopcount$[rsp+rax], dl
  00214	74 49		 je	 SHORT $LN4@calcMod2Wa

; 1209 : 						{
; 1210 : 							pBreakPosition = n_pattpos[ch];

  00216	0f b6 7c 04 68	 movzx	 edi, BYTE PTR n_pattpos$[rsp+rax]

; 1211 : 							pBreakFlag = true;

  0021b	40 b5 01	 mov	 bpl, 1

; 1212 : 
; 1213 : 							for (pos = pBreakPosition; pos <= modRow; pos++)

  0021e	40 0f b6 c7	 movzx	 eax, dil
  00222	40 3a fb	 cmp	 dil, bl
  00225	77 38		 ja	 SHORT $LN4@calcMod2Wa
  00227	44 0f bf c6	 movsx	 r8d, si
  0022b	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:editor
  00232	41 c1 e0 06	 shl	 r8d, 6
  00236	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL12@calcMod2Wa:

; 1214 : 								editor.rowVisitTable[(modOrder * MOD_ROWS) + pos] = false;

  00240	0f b6 c8	 movzx	 ecx, al
  00243	fe c0		 inc	 al
  00245	41 03 c8	 add	 ecx, r8d
  00248	48 63 d1	 movsxd	 rdx, ecx
  0024b	42 c6 84 3a 23
	01 00 00 00	 mov	 BYTE PTR [rdx+r15+291], 0
  00254	3a c3		 cmp	 al, bl
  00256	76 e8		 jbe	 SHORT $LL12@calcMod2Wa
$LN53@calcMod2Wa:

; 1163 : 
; 1164 : 		for (ch = 0; ch < AMIGA_VOICES; ch++)

  00258	4c 8b 3d 00 00
	00 00		 mov	 r15, QWORD PTR modEntry
$LN4@calcMod2Wa:
  0025f	41 fe c1	 inc	 r9b
  00262	41 80 f9 04	 cmp	 r9b, 4
  00266	0f 82 24 fe ff
	ff		 jb	 $LL6@calcMod2Wa
  0026c	e9 91 fe ff ff	 jmp	 $LN52@calcMod2Wa
calcMod2WavTotalRows ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT normalize32bitSigned
_TEXT	SEGMENT
sampleData$ = 8
sampleLength$ = 16
normalize32bitSigned PROC				; COMDAT

; 1260 : {

$LN47:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 1261 : 	int32_t sample, sampleVolPeak;
; 1262 : 	uint32_t i;
; 1263 : 	double dGain;
; 1264 : 
; 1265 : 	sampleVolPeak = 0;

  00005	45 33 db	 xor	 r11d, r11d
  00008	44 8b d2	 mov	 r10d, edx
  0000b	48 8b d9	 mov	 rbx, rcx
  0000e	45 8b c3	 mov	 r8d, r11d
  00011	45 8b cb	 mov	 r9d, r11d

; 1266 : 	for (i = 0; i < sampleLength; i++)

  00014	85 d2		 test	 edx, edx
  00016	0f 84 be 00 00
	00		 je	 $LN44@normalize3
  0001c	83 fa 08	 cmp	 edx, 8
  0001f	72 73		 jb	 SHORT $LN22@normalize3

; 1261 : 	int32_t sample, sampleVolPeak;
; 1262 : 	uint32_t i;
; 1263 : 	double dGain;
; 1264 : 
; 1265 : 	sampleVolPeak = 0;

  00021	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR __isa_available, 2
  00028	7c 6a		 jl	 SHORT $LN22@normalize3
  0002a	83 e2 f8	 and	 edx, -8			; fffffff8H
  0002d	0f 57 d2	 xorps	 xmm2, xmm2
  00030	0f 57 db	 xorps	 xmm3, xmm3
  00033	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL4@normalize3:

; 1267 : 	{
; 1268 : 		sample = ABS(sampleData[i]);

  00040	41 8b c1	 mov	 eax, r9d
  00043	f3 0f 6f 04 81	 movdqu	 xmm0, XMMWORD PTR [rcx+rax*4]
  00048	41 8d 41 04	 lea	 eax, DWORD PTR [r9+4]
  0004c	41 83 c1 08	 add	 r9d, 8
  00050	66 0f 38 1e c8	 pabsd	 xmm1, xmm0

; 1269 : 		if (sampleVolPeak < sample)

  00055	66 0f 38 3d d1	 pmaxsd	 xmm2, xmm1
  0005a	f3 0f 6f 04 81	 movdqu	 xmm0, XMMWORD PTR [rcx+rax*4]
  0005f	66 0f 38 1e c8	 pabsd	 xmm1, xmm0
  00064	66 0f 38 3d d9	 pmaxsd	 xmm3, xmm1
  00069	44 3b ca	 cmp	 r9d, edx
  0006c	72 d2		 jb	 SHORT $LL4@normalize3

; 1261 : 	int32_t sample, sampleVolPeak;
; 1262 : 	uint32_t i;
; 1263 : 	double dGain;
; 1264 : 
; 1265 : 	sampleVolPeak = 0;

  0006e	66 0f 38 3d d3	 pmaxsd	 xmm2, xmm3
  00073	66 0f 6f c2	 movdqa	 xmm0, xmm2
  00077	66 0f 73 d8 08	 psrldq	 xmm0, 8
  0007c	66 0f 38 3d d0	 pmaxsd	 xmm2, xmm0
  00081	66 0f 6f c2	 movdqa	 xmm0, xmm2
  00085	66 0f 73 d8 04	 psrldq	 xmm0, 4
  0008a	66 0f 38 3d d0	 pmaxsd	 xmm2, xmm0
  0008f	66 41 0f 7e d0	 movd	 r8d, xmm2
$LN22@normalize3:

; 1266 : 	for (i = 0; i < sampleLength; i++)

  00094	45 3b ca	 cmp	 r9d, r10d
  00097	73 2f		 jae	 SHORT $LN3@normalize3
  00099	41 8b c1	 mov	 eax, r9d
  0009c	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  000a0	41 8b c2	 mov	 eax, r10d
  000a3	41 2b c1	 sub	 eax, r9d
  000a6	44 8b c8	 mov	 r9d, eax
  000a9	0f 1f 80 00 00
	00 00		 npad	 7
$LL18@normalize3:

; 1269 : 		if (sampleVolPeak < sample)

  000b0	8b 01		 mov	 eax, DWORD PTR [rcx]
  000b2	48 8d 49 04	 lea	 rcx, QWORD PTR [rcx+4]
  000b6	99		 cdq
  000b7	33 c2		 xor	 eax, edx
  000b9	2b c2		 sub	 eax, edx
  000bb	44 3b c0	 cmp	 r8d, eax
  000be	44 0f 4c c0	 cmovl	 r8d, eax
  000c2	49 83 e9 01	 sub	 r9, 1
  000c6	75 e8		 jne	 SHORT $LL18@normalize3
$LN3@normalize3:

; 1270 : 			sampleVolPeak = sample;
; 1271 : 	}
; 1272 : 
; 1273 : 	if (sampleVolPeak >= INT32_MAX)

  000c8	41 81 f8 ff ff
	ff 7f		 cmp	 r8d, 2147483647		; 7fffffffH
  000cf	0f 8d 80 01 00
	00		 jge	 $LN33@normalize3

; 1274 : 		return; // sample is already normalized
; 1275 : 
; 1276 : 	// prevent division by zero!
; 1277 : 	if (sampleVolPeak <= 0)

  000d5	45 85 c0	 test	 r8d, r8d
  000d8	7f 06		 jg	 SHORT $LN10@normalize3
$LN44@normalize3:

; 1278 : 		sampleVolPeak = 1;

  000da	41 b8 01 00 00
	00		 mov	 r8d, 1
$LN10@normalize3:

; 1279 : 
; 1280 : 	dGain = (double)INT32_MAX / sampleVolPeak;

  000e0	f2 0f 10 15 00
	00 00 00	 movsd	 xmm2, QWORD PTR __real@41dfffffffc00000
  000e8	66 41 0f 6e c0	 movd	 xmm0, r8d
  000ed	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000f1	f2 0f 5e d0	 divsd	 xmm2, xmm0
  000f5	0f 28 da	 movaps	 xmm3, xmm2
  000f8	66 0f 14 db	 unpcklpd xmm3, xmm3

; 1281 : 	for (i = 0; i < sampleLength; i++)

  000fc	45 85 d2	 test	 r10d, r10d
  000ff	0f 84 50 01 00
	00		 je	 $LN33@normalize3
  00105	41 83 fa 08	 cmp	 r10d, 8
  00109	0f 82 83 00 00
	00		 jb	 $LN24@normalize3

; 1279 : 
; 1280 : 	dGain = (double)INT32_MAX / sampleVolPeak;

  0010f	41 8b d2	 mov	 edx, r10d
  00112	41 b8 04 00 00
	00		 mov	 r8d, 4
  00118	83 e2 f8	 and	 edx, -8			; fffffff8H
  0011b	0f 1f 44 00 00	 npad	 5
$LL7@normalize3:

; 1282 : 	{
; 1283 : 		sample = (int32_t)(sampleData[i] * dGain);

  00120	f3 42 0f 7e 04
	9b		 movq	 xmm0, QWORD PTR [rbx+r11*4]
  00126	41 8d 40 fe	 lea	 eax, DWORD PTR [r8-2]
  0012a	f3 0f e6 c8	 cvtdq2pd xmm1, xmm0
  0012e	66 0f 59 cb	 mulpd	 xmm1, xmm3
  00132	66 0f e6 c1	 cvttpd2dq xmm0, xmm1

; 1284 : 		sampleData[i] = (int32_t)sample;

  00136	66 42 0f d6 04
	9b		 movq	 QWORD PTR [rbx+r11*4], xmm0
  0013c	41 83 c3 08	 add	 r11d, 8
  00140	f3 0f 7e 04 83	 movq	 xmm0, QWORD PTR [rbx+rax*4]
  00145	f3 0f e6 c8	 cvtdq2pd xmm1, xmm0
  00149	66 0f 59 cb	 mulpd	 xmm1, xmm3
  0014d	66 0f e6 c1	 cvttpd2dq xmm0, xmm1
  00151	66 0f d6 04 83	 movq	 QWORD PTR [rbx+rax*4], xmm0
  00156	41 8b c0	 mov	 eax, r8d
  00159	f3 0f 7e 04 83	 movq	 xmm0, QWORD PTR [rbx+rax*4]
  0015e	f3 0f e6 c8	 cvtdq2pd xmm1, xmm0
  00162	66 0f 59 cb	 mulpd	 xmm1, xmm3
  00166	66 0f e6 c1	 cvttpd2dq xmm0, xmm1
  0016a	66 0f d6 04 83	 movq	 QWORD PTR [rbx+rax*4], xmm0
  0016f	41 8d 40 02	 lea	 eax, DWORD PTR [r8+2]
  00173	f3 0f 7e 04 83	 movq	 xmm0, QWORD PTR [rbx+rax*4]
  00178	41 83 c0 08	 add	 r8d, 8
  0017c	f3 0f e6 c8	 cvtdq2pd xmm1, xmm0
  00180	66 0f 59 cb	 mulpd	 xmm1, xmm3
  00184	66 0f e6 c1	 cvttpd2dq xmm0, xmm1
  00188	66 0f d6 04 83	 movq	 QWORD PTR [rbx+rax*4], xmm0
  0018d	44 3b da	 cmp	 r11d, edx
  00190	72 8e		 jb	 SHORT $LL7@normalize3
$LN24@normalize3:

; 1281 : 	for (i = 0; i < sampleLength; i++)

  00192	45 3b da	 cmp	 r11d, r10d
  00195	0f 83 ba 00 00
	00		 jae	 $LN33@normalize3
  0019b	41 8b c2	 mov	 eax, r10d
  0019e	45 8b c3	 mov	 r8d, r11d
  001a1	41 2b c3	 sub	 eax, r11d
  001a4	83 f8 04	 cmp	 eax, 4
  001a7	0f 82 81 00 00
	00		 jb	 $LC34@normalize3
  001ad	41 8b c2	 mov	 eax, r10d
  001b0	48 8d 4b 08	 lea	 rcx, QWORD PTR [rbx+8]
  001b4	41 2b c3	 sub	 eax, r11d
  001b7	4a 8d 0c 99	 lea	 rcx, QWORD PTR [rcx+r11*4]
  001bb	83 e8 04	 sub	 eax, 4
  001be	c1 e8 02	 shr	 eax, 2
  001c1	ff c0		 inc	 eax
  001c3	8b d0		 mov	 edx, eax
  001c5	45 8d 1c 83	 lea	 r11d, DWORD PTR [r11+rax*4]
  001c9	4d 8d 04 80	 lea	 r8, QWORD PTR [r8+rax*4]
  001cd	0f 1f 00	 npad	 3
$LL35@normalize3:
  001d0	66 0f 6e 41 f8	 movd	 xmm0, DWORD PTR [rcx-8]
  001d5	66 0f 6e 09	 movd	 xmm1, DWORD PTR [rcx]

; 1284 : 		sampleData[i] = (int32_t)sample;

  001d9	48 8d 49 10	 lea	 rcx, QWORD PTR [rcx+16]
  001dd	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  001e1	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  001e5	f2 0f 59 c2	 mulsd	 xmm0, xmm2
  001e9	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  001ed	f2 0f 2c c0	 cvttsd2si eax, xmm0
  001f1	66 0f 6e 41 ec	 movd	 xmm0, DWORD PTR [rcx-20]
  001f6	89 41 e8	 mov	 DWORD PTR [rcx-24], eax
  001f9	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  001fd	f2 0f 59 c2	 mulsd	 xmm0, xmm2
  00201	f2 0f 2c c0	 cvttsd2si eax, xmm0
  00205	66 0f 6e 41 f4	 movd	 xmm0, DWORD PTR [rcx-12]
  0020a	89 41 ec	 mov	 DWORD PTR [rcx-20], eax
  0020d	f2 0f 2c c1	 cvttsd2si eax, xmm1
  00211	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00215	89 41 f0	 mov	 DWORD PTR [rcx-16], eax
  00218	f2 0f 59 c2	 mulsd	 xmm0, xmm2
  0021c	f2 0f 2c c0	 cvttsd2si eax, xmm0
  00220	89 41 f4	 mov	 DWORD PTR [rcx-12], eax
  00223	48 83 ea 01	 sub	 rdx, 1
  00227	75 a7		 jne	 SHORT $LL35@normalize3

; 1281 : 	for (i = 0; i < sampleLength; i++)

  00229	45 3b da	 cmp	 r11d, r10d
  0022c	73 27		 jae	 SHORT $LN33@normalize3
$LC34@normalize3:
  0022e	45 2b d3	 sub	 r10d, r11d
  00231	4a 8d 0c 83	 lea	 rcx, QWORD PTR [rbx+r8*4]
  00235	41 8b d2	 mov	 edx, r10d
$LC42@normalize3:
  00238	66 0f 6e 01	 movd	 xmm0, DWORD PTR [rcx]
  0023c	48 8d 49 04	 lea	 rcx, QWORD PTR [rcx+4]

; 1282 : 	{
; 1283 : 		sample = (int32_t)(sampleData[i] * dGain);

  00240	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00244	f2 0f 59 c2	 mulsd	 xmm0, xmm2
  00248	f2 0f 2c c0	 cvttsd2si eax, xmm0

; 1284 : 		sampleData[i] = (int32_t)sample;

  0024c	89 41 fc	 mov	 DWORD PTR [rcx-4], eax
  0024f	48 83 ea 01	 sub	 rdx, 1
  00253	75 e3		 jne	 SHORT $LC42@normalize3
$LN33@normalize3:

; 1285 : 	}
; 1286 : }

  00255	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0025a	c3		 ret	 0
normalize32bitSigned ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT normalize16bitSigned
_TEXT	SEGMENT
sampleData$ = 8
sampleLength$ = 16
normalize16bitSigned PROC				; COMDAT

; 1289 : {

$LN37:

; 1294 : 	for (i = 0; i < sampleLength; i++)

  00000	85 d2		 test	 edx, edx
  00002	0f 84 8a 01 00
	00		 je	 $LN35@normalize1
  00008	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  0000d	48 89 7c 24 10	 mov	 QWORD PTR [rsp+16], rdi

; 1289 : {

  00012	44 8b da	 mov	 r11d, edx

; 1290 : 	uint32_t i;
; 1291 : 	int32_t sample, sampleVolPeak, gain;
; 1292 : 
; 1293 : 	sampleVolPeak = 0;

  00015	33 db		 xor	 ebx, ebx
  00017	44 8b cb	 mov	 r9d, ebx
  0001a	41 8b d3	 mov	 edx, r11d
  0001d	48 8b f9	 mov	 rdi, rcx
  00020	4c 8b d1	 mov	 r10, rcx
  00023	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL18@normalize1:

; 1295 : 	{
; 1296 : 		sample = ABS(sampleData[i]);

  00030	41 0f bf 02	 movsx	 eax, WORD PTR [r10]
  00034	4d 8d 52 02	 lea	 r10, QWORD PTR [r10+2]
  00038	8b c8		 mov	 ecx, eax
  0003a	f7 d9		 neg	 ecx
  0003c	66 85 c0	 test	 ax, ax
  0003f	0f 49 c8	 cmovns	 ecx, eax
  00042	44 3b c9	 cmp	 r9d, ecx
  00045	41 0f 4d c9	 cmovge	 ecx, r9d
  00049	44 8b c9	 mov	 r9d, ecx
  0004c	48 83 ea 01	 sub	 rdx, 1
  00050	75 de		 jne	 SHORT $LL18@normalize1

; 1297 : 		if (sampleVolPeak < sample)
; 1298 : 			sampleVolPeak = sample;
; 1299 : 	}
; 1300 : 
; 1301 : 	if (sampleVolPeak >= INT16_MAX)

  00052	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]
  00055	3d fd 7f 00 00	 cmp	 eax, 32765		; 00007ffdH
  0005a	0f 87 28 01 00
	00		 ja	 $LN6@normalize1

; 1302 : 		return; // sample is already normalized
; 1303 : 
; 1304 : 	if (sampleVolPeak < 1)
; 1305 : 		return;
; 1306 : 
; 1307 : 	gain = (INT16_MAX * 65536) / sampleVolPeak;

  00060	b8 00 00 ff 7f	 mov	 eax, 2147418112		; 7fff0000H
  00065	99		 cdq
  00066	41 f7 f9	 idiv	 r9d
  00069	44 8b c0	 mov	 r8d, eax
  0006c	66 0f 6e d8	 movd	 xmm3, eax
  00070	66 0f 70 db 00	 pshufd	 xmm3, xmm3, 0

; 1308 : 	for (i = 0; i < sampleLength; i++)

  00075	41 83 fb 10	 cmp	 r11d, 16
  00079	0f 82 d7 00 00
	00		 jb	 $LN24@normalize1

; 1302 : 		return; // sample is already normalized
; 1303 : 
; 1304 : 	if (sampleVolPeak < 1)
; 1305 : 		return;
; 1306 : 
; 1307 : 	gain = (INT16_MAX * 65536) / sampleVolPeak;

  0007f	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR __isa_available, 2
  00086	0f 8c ca 00 00
	00		 jl	 $LN24@normalize1
  0008c	b8 10 00 00 00	 mov	 eax, 16
  00091	41 8b d3	 mov	 edx, r11d
  00094	83 e2 f0	 and	 edx, -16		; fffffff0H
  00097	66 0f 6e e0	 movd	 xmm4, eax
  0009b	44 8d 48 f8	 lea	 r9d, QWORD PTR [rax-8]
  0009f	90		 npad	 1
$LL7@normalize1:

; 1309 : 		sampleData[i] = (int16_t)((sampleData[i] * gain) >> 16);

  000a0	f3 0f 7e 04 5f	 movq	 xmm0, QWORD PTR [rdi+rbx*2]
  000a5	41 8d 41 fc	 lea	 eax, DWORD PTR [r9-4]
  000a9	66 0f 38 23 c8	 pmovsxwd xmm1, xmm0
  000ae	66 0f 38 40 cb	 pmulld	 xmm1, xmm3
  000b3	66 0f e2 cc	 psrad	 xmm1, xmm4
  000b7	f2 0f 70 c1 d8	 pshuflw xmm0, xmm1, 216		; 000000d8H
  000bc	f3 0f 70 c8 d8	 pshufhw xmm1, xmm0, 216		; 000000d8H
  000c1	66 0f 70 d1 d8	 pshufd	 xmm2, xmm1, 216		; 000000d8H
  000c6	66 0f d6 14 5f	 movq	 QWORD PTR [rdi+rbx*2], xmm2
  000cb	83 c3 10	 add	 ebx, 16
  000ce	f3 0f 7e 04 47	 movq	 xmm0, QWORD PTR [rdi+rax*2]
  000d3	66 0f 38 23 c8	 pmovsxwd xmm1, xmm0
  000d8	66 0f 38 40 cb	 pmulld	 xmm1, xmm3
  000dd	66 0f e2 cc	 psrad	 xmm1, xmm4
  000e1	f2 0f 70 c1 d8	 pshuflw xmm0, xmm1, 216		; 000000d8H
  000e6	f3 0f 70 c8 d8	 pshufhw xmm1, xmm0, 216		; 000000d8H
  000eb	66 0f 70 d1 d8	 pshufd	 xmm2, xmm1, 216		; 000000d8H
  000f0	66 0f d6 14 47	 movq	 QWORD PTR [rdi+rax*2], xmm2
  000f5	41 8b c1	 mov	 eax, r9d
  000f8	f3 0f 7e 04 47	 movq	 xmm0, QWORD PTR [rdi+rax*2]
  000fd	66 0f 38 23 c8	 pmovsxwd xmm1, xmm0
  00102	66 0f 38 40 cb	 pmulld	 xmm1, xmm3
  00107	66 0f e2 cc	 psrad	 xmm1, xmm4
  0010b	f2 0f 70 c1 d8	 pshuflw xmm0, xmm1, 216		; 000000d8H
  00110	f3 0f 70 c8 d8	 pshufhw xmm1, xmm0, 216		; 000000d8H
  00115	66 0f 70 d1 d8	 pshufd	 xmm2, xmm1, 216		; 000000d8H
  0011a	66 0f d6 14 47	 movq	 QWORD PTR [rdi+rax*2], xmm2
  0011f	41 8d 41 04	 lea	 eax, DWORD PTR [r9+4]
  00123	f3 0f 7e 04 47	 movq	 xmm0, QWORD PTR [rdi+rax*2]
  00128	41 83 c1 10	 add	 r9d, 16
  0012c	66 0f 38 23 c8	 pmovsxwd xmm1, xmm0
  00131	66 0f 38 40 cb	 pmulld	 xmm1, xmm3
  00136	66 0f e2 cc	 psrad	 xmm1, xmm4
  0013a	f2 0f 70 c1 d8	 pshuflw xmm0, xmm1, 216		; 000000d8H
  0013f	f3 0f 70 c8 d8	 pshufhw xmm1, xmm0, 216		; 000000d8H
  00144	66 0f 70 d1 d8	 pshufd	 xmm2, xmm1, 216		; 000000d8H
  00149	66 0f d6 14 47	 movq	 QWORD PTR [rdi+rax*2], xmm2
  0014e	3b da		 cmp	 ebx, edx
  00150	0f 82 4a ff ff
	ff		 jb	 $LL7@normalize1
$LN24@normalize1:

; 1308 : 	for (i = 0; i < sampleLength; i++)

  00156	41 3b db	 cmp	 ebx, r11d
  00159	73 2d		 jae	 SHORT $LN6@normalize1
  0015b	44 2b db	 sub	 r11d, ebx
  0015e	48 8d 04 5f	 lea	 rax, QWORD PTR [rdi+rbx*2]
  00162	41 8b d3	 mov	 edx, r11d
  00165	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL23@normalize1:

; 1309 : 		sampleData[i] = (int16_t)((sampleData[i] * gain) >> 16);

  00170	0f bf 08	 movsx	 ecx, WORD PTR [rax]
  00173	48 8d 40 02	 lea	 rax, QWORD PTR [rax+2]
  00177	41 0f af c8	 imul	 ecx, r8d
  0017b	c1 f9 10	 sar	 ecx, 16
  0017e	66 89 48 fe	 mov	 WORD PTR [rax-2], cx
  00182	48 83 ea 01	 sub	 rdx, 1
  00186	75 e8		 jne	 SHORT $LL23@normalize1
$LN6@normalize1:

; 1310 : }

  00188	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0018d	48 8b 7c 24 10	 mov	 rdi, QWORD PTR [rsp+16]
$LN35@normalize1:
  00192	c3		 ret	 0
normalize16bitSigned ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\Programming\pt2-clone\src\pt2_audio.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT normalize8bitFloatSigned
_TEXT	SEGMENT
fSampleData$ = 16
sampleLength$ = 24
normalize8bitFloatSigned PROC				; COMDAT

; 1313 : {

$LN55:
  00000	48 83 ec 08	 sub	 rsp, 8

; 1314 : 	uint32_t i;
; 1315 : 	float fSample, fSampleVolPeak, fGain;
; 1316 : 
; 1317 : 	fSampleVolPeak = 0.0f;

  00004	45 33 c9	 xor	 r9d, r9d
  00007	4c 8b d1	 mov	 r10, rcx
  0000a	0f 57 e4	 xorps	 xmm4, xmm4
  0000d	0f 57 c9	 xorps	 xmm1, xmm1
  00010	45 8b c1	 mov	 r8d, r9d

; 1318 : 	for (i = 0; i < sampleLength; i++)

  00013	85 d2		 test	 edx, edx
  00015	0f 84 28 02 00
	00		 je	 $LN32@normalize8
  0001b	83 fa 08	 cmp	 edx, 8
  0001e	72 4c		 jb	 SHORT $LN18@normalize8

; 1314 : 	uint32_t i;
; 1315 : 	float fSample, fSampleVolPeak, fGain;
; 1316 : 
; 1317 : 	fSampleVolPeak = 0.0f;

  00020	0f 28 1d 00 00
	00 00		 movaps	 xmm3, XMMWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
  00027	44 8b da	 mov	 r11d, edx
  0002a	41 83 e3 f8	 and	 r11d, -8		; fffffff8H
  0002e	0f 57 d2	 xorps	 xmm2, xmm2
$LL4@normalize8:

; 1320 : 		fSample = fabsf(fSampleData[i]);

  00031	41 8b c0	 mov	 eax, r8d
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  00034	0f 10 04 81	 movups	 xmm0, XMMWORD PTR [rcx+rax*4]
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 1320 : 		fSample = fabsf(fSampleData[i]);

  00038	41 8d 40 04	 lea	 eax, DWORD PTR [r8+4]
  0003c	41 83 c0 08	 add	 r8d, 8
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  00040	0f 54 c3	 andps	 xmm0, xmm3
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 1321 : 		if (fSampleVolPeak < fSample)

  00043	0f 5f d0	 maxps	 xmm2, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  00046	0f 10 04 81	 movups	 xmm0, XMMWORD PTR [rcx+rax*4]
  0004a	0f 54 c3	 andps	 xmm0, xmm3
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 1321 : 		if (fSampleVolPeak < fSample)

  0004d	0f 5f c8	 maxps	 xmm1, xmm0
  00050	45 3b c3	 cmp	 r8d, r11d
  00053	72 dc		 jb	 SHORT $LL4@normalize8

; 1314 : 	uint32_t i;
; 1315 : 	float fSample, fSampleVolPeak, fGain;
; 1316 : 
; 1317 : 	fSampleVolPeak = 0.0f;

  00055	0f 5f d1	 maxps	 xmm2, xmm1
  00058	0f 28 ca	 movaps	 xmm1, xmm2
  0005b	0f 12 ca	 movhlps xmm1, xmm2
  0005e	0f 5f ca	 maxps	 xmm1, xmm2
  00061	0f 28 c1	 movaps	 xmm0, xmm1
  00064	0f c6 c1 f5	 shufps	 xmm0, xmm1, 245		; 000000f5H
  00068	f3 0f 5f c8	 maxss	 xmm1, xmm0
$LN18@normalize8:

; 1318 : 	for (i = 0; i < sampleLength; i++)

  0006c	44 3b c2	 cmp	 r8d, edx
  0006f	0f 83 a4 00 00
	00		 jae	 $LN29@normalize8
  00075	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
  0007d	8b c2		 mov	 eax, edx
  0007f	41 2b c0	 sub	 eax, r8d
  00082	48 89 1c 24	 mov	 QWORD PTR [rsp], rbx
  00086	41 8b d8	 mov	 ebx, r8d
  00089	83 f8 04	 cmp	 eax, 4
  0008c	72 63		 jb	 SHORT $LC30@normalize8
  0008e	8b c2		 mov	 eax, edx
  00090	48 83 c1 08	 add	 rcx, 8
  00094	41 2b c0	 sub	 eax, r8d
  00097	83 e8 04	 sub	 eax, 4
  0009a	c1 e8 02	 shr	 eax, 2
  0009d	ff c0		 inc	 eax
  0009f	48 8d 0c 99	 lea	 rcx, QWORD PTR [rcx+rbx*4]
  000a3	44 8b d8	 mov	 r11d, eax
  000a6	45 8d 04 80	 lea	 r8d, DWORD PTR [r8+rax*4]
  000aa	48 8d 1c 83	 lea	 rbx, QWORD PTR [rbx+rax*4]
  000ae	66 90		 npad	 2
$LL31@normalize8:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  000b0	f3 0f 10 41 f8	 movss	 xmm0, DWORD PTR [rcx-8]
  000b5	f3 0f 10 11	 movss	 xmm2, DWORD PTR [rcx]
  000b9	0f 54 c3	 andps	 xmm0, xmm3
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 1321 : 		if (fSampleVolPeak < fSample)

  000bc	f3 0f 5f c1	 maxss	 xmm0, xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  000c0	f3 0f 10 49 fc	 movss	 xmm1, DWORD PTR [rcx-4]
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 1322 : 			fSampleVolPeak = fSample;

  000c5	48 8d 49 10	 lea	 rcx, QWORD PTR [rcx+16]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  000c9	0f 54 cb	 andps	 xmm1, xmm3
  000cc	0f 54 d3	 andps	 xmm2, xmm3
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 1321 : 		if (fSampleVolPeak < fSample)

  000cf	f3 0f 5f c8	 maxss	 xmm1, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  000d3	f3 0f 10 41 f4	 movss	 xmm0, DWORD PTR [rcx-12]
  000d8	0f 54 c3	 andps	 xmm0, xmm3
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 1321 : 		if (fSampleVolPeak < fSample)

  000db	f3 0f 5f d1	 maxss	 xmm2, xmm1
  000df	f3 0f 5f c2	 maxss	 xmm0, xmm2

; 1322 : 			fSampleVolPeak = fSample;

  000e3	0f 28 c8	 movaps	 xmm1, xmm0
  000e6	49 83 eb 01	 sub	 r11, 1
  000ea	75 c4		 jne	 SHORT $LL31@normalize8

; 1318 : 	for (i = 0; i < sampleLength; i++)

  000ec	44 3b c2	 cmp	 r8d, edx
  000ef	73 24		 jae	 SHORT $LN53@normalize8
$LC30@normalize8:
  000f1	8b c2		 mov	 eax, edx
  000f3	49 8d 0c 9a	 lea	 rcx, QWORD PTR [r10+rbx*4]
  000f7	41 2b c0	 sub	 eax, r8d
  000fa	44 8b c0	 mov	 r8d, eax
$LC45@normalize8:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  000fd	f3 0f 10 01	 movss	 xmm0, DWORD PTR [rcx]
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 1318 : 	for (i = 0; i < sampleLength; i++)

  00101	48 8d 49 04	 lea	 rcx, QWORD PTR [rcx+4]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  00105	0f 54 c3	 andps	 xmm0, xmm3
; File C:\Programming\pt2-clone\src\pt2_audio.c

; 1321 : 		if (fSampleVolPeak < fSample)

  00108	f3 0f 5f c1	 maxss	 xmm0, xmm1

; 1322 : 			fSampleVolPeak = fSample;

  0010c	0f 28 c8	 movaps	 xmm1, xmm0
  0010f	49 83 e8 01	 sub	 r8, 1
  00113	75 e8		 jne	 SHORT $LC45@normalize8
$LN53@normalize8:
  00115	48 8b 1c 24	 mov	 rbx, QWORD PTR [rsp]
$LN29@normalize8:

; 1323 : 	}
; 1324 : 
; 1325 : 	if (fSampleVolPeak <= 0.0f)

  00119	0f 2f cc	 comiss	 xmm1, xmm4
  0011c	0f 86 21 01 00
	00		 jbe	 $LN32@normalize8

; 1326 : 		return;
; 1327 : 
; 1328 : 	fGain = INT8_MAX / fSampleVolPeak;

  00122	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@42fe0000
  0012a	f3 0f 5e d1	 divss	 xmm2, xmm1
  0012e	0f 28 da	 movaps	 xmm3, xmm2
  00131	0f c6 db 00	 shufps	 xmm3, xmm3, 0

; 1329 : 	for (i = 0; i < sampleLength; i++)

  00135	83 fa 10	 cmp	 edx, 16
  00138	72 65		 jb	 SHORT $LN20@normalize8

; 1326 : 		return;
; 1327 : 
; 1328 : 	fGain = INT8_MAX / fSampleVolPeak;

  0013a	44 8b c2	 mov	 r8d, edx
  0013d	41 bb 08 00 00
	00		 mov	 r11d, 8
  00143	41 83 e0 f0	 and	 r8d, -16		; fffffff0H
  00147	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL7@normalize8:

; 1330 : 		fSampleData[i] *= fGain;

  00150	43 0f 10 04 8a	 movups	 xmm0, XMMWORD PTR [r10+r9*4]
  00155	41 8d 43 fc	 lea	 eax, DWORD PTR [r11-4]
  00159	0f 28 cb	 movaps	 xmm1, xmm3
  0015c	0f 59 c3	 mulps	 xmm0, xmm3
  0015f	43 0f 11 04 8a	 movups	 XMMWORD PTR [r10+r9*4], xmm0
  00164	41 83 c1 10	 add	 r9d, 16
  00168	41 0f 10 04 82	 movups	 xmm0, XMMWORD PTR [r10+rax*4]
  0016d	0f 59 c8	 mulps	 xmm1, xmm0
  00170	41 0f 11 0c 82	 movups	 XMMWORD PTR [r10+rax*4], xmm1
  00175	41 8b c3	 mov	 eax, r11d
  00178	41 0f 10 04 82	 movups	 xmm0, XMMWORD PTR [r10+rax*4]
  0017d	0f 59 c3	 mulps	 xmm0, xmm3
  00180	41 0f 11 04 82	 movups	 XMMWORD PTR [r10+rax*4], xmm0
  00185	41 8d 43 04	 lea	 eax, DWORD PTR [r11+4]
  00189	41 83 c3 10	 add	 r11d, 16
  0018d	41 0f 10 04 82	 movups	 xmm0, XMMWORD PTR [r10+rax*4]
  00192	0f 59 c3	 mulps	 xmm0, xmm3
  00195	41 0f 11 04 82	 movups	 XMMWORD PTR [r10+rax*4], xmm0
  0019a	45 3b c8	 cmp	 r9d, r8d
  0019d	72 b1		 jb	 SHORT $LL7@normalize8
$LN20@normalize8:

; 1329 : 	for (i = 0; i < sampleLength; i++)

  0019f	44 3b ca	 cmp	 r9d, edx
  001a2	0f 83 9b 00 00
	00		 jae	 $LN32@normalize8
  001a8	8b c2		 mov	 eax, edx
  001aa	45 8b d9	 mov	 r11d, r9d
  001ad	41 2b c1	 sub	 eax, r9d
  001b0	83 f8 04	 cmp	 eax, 4
  001b3	72 6e		 jb	 SHORT $LC33@normalize8
  001b5	8b c2		 mov	 eax, edx
  001b7	49 8d 4a 08	 lea	 rcx, QWORD PTR [r10+8]
  001bb	41 2b c1	 sub	 eax, r9d
  001be	4a 8d 0c 89	 lea	 rcx, QWORD PTR [rcx+r9*4]
  001c2	83 e8 04	 sub	 eax, 4
  001c5	c1 e8 02	 shr	 eax, 2
  001c8	ff c0		 inc	 eax
  001ca	44 8b c0	 mov	 r8d, eax
  001cd	45 8d 0c 81	 lea	 r9d, DWORD PTR [r9+rax*4]
  001d1	4d 8d 1c 83	 lea	 r11, QWORD PTR [r11+rax*4]
  001d5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL34@normalize8:

; 1330 : 		fSampleData[i] *= fGain;

  001e0	48 8d 49 10	 lea	 rcx, QWORD PTR [rcx+16]
  001e4	0f 28 c2	 movaps	 xmm0, xmm2
  001e7	f3 0f 59 41 e8	 mulss	 xmm0, DWORD PTR [rcx-24]
  001ec	0f 28 ca	 movaps	 xmm1, xmm2
  001ef	f3 0f 59 49 ec	 mulss	 xmm1, DWORD PTR [rcx-20]
  001f4	f3 0f 11 41 e8	 movss	 DWORD PTR [rcx-24], xmm0
  001f9	0f 28 c2	 movaps	 xmm0, xmm2
  001fc	f3 0f 59 41 f0	 mulss	 xmm0, DWORD PTR [rcx-16]
  00201	f3 0f 11 49 ec	 movss	 DWORD PTR [rcx-20], xmm1
  00206	0f 28 ca	 movaps	 xmm1, xmm2
  00209	f3 0f 59 49 f4	 mulss	 xmm1, DWORD PTR [rcx-12]
  0020e	f3 0f 11 41 f0	 movss	 DWORD PTR [rcx-16], xmm0
  00213	f3 0f 11 49 f4	 movss	 DWORD PTR [rcx-12], xmm1
  00218	49 83 e8 01	 sub	 r8, 1
  0021c	75 c2		 jne	 SHORT $LL34@normalize8

; 1329 : 	for (i = 0; i < sampleLength; i++)

  0021e	44 3b ca	 cmp	 r9d, edx
  00221	73 20		 jae	 SHORT $LN32@normalize8
$LC33@normalize8:
  00223	41 2b d1	 sub	 edx, r9d
  00226	4b 8d 04 9a	 lea	 rax, QWORD PTR [r10+r11*4]
  0022a	8b ca		 mov	 ecx, edx
$LC48@normalize8:
  0022c	48 8d 40 04	 lea	 rax, QWORD PTR [rax+4]

; 1330 : 		fSampleData[i] *= fGain;

  00230	0f 28 c2	 movaps	 xmm0, xmm2
  00233	f3 0f 59 40 fc	 mulss	 xmm0, DWORD PTR [rax-4]
  00238	f3 0f 11 40 fc	 movss	 DWORD PTR [rax-4], xmm0
  0023d	48 83 e9 01	 sub	 rcx, 1
  00241	75 e9		 jne	 SHORT $LC48@normalize8
$LN32@normalize8:

; 1331 : }

  00243	48 83 c4 08	 add	 rsp, 8
  00247	c3		 ret	 0
normalize8bitFloatSigned ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\pt2-clone\src\pt2_audio.c
;	COMDAT normalize8bitDoubleSigned
_TEXT	SEGMENT
dSampleData$ = 16
sampleLength$ = 24
normalize8bitDoubleSigned PROC				; COMDAT

; 1334 : {

$LN53:
  00000	48 83 ec 08	 sub	 rsp, 8

; 1335 : 	uint32_t i;
; 1336 : 	double dSample, dSampleVolPeak, dGain;
; 1337 : 
; 1338 : 	dSampleVolPeak = 0.0;

  00004	45 33 c9	 xor	 r9d, r9d
  00007	4c 8b d1	 mov	 r10, rcx
  0000a	0f 57 e4	 xorps	 xmm4, xmm4
  0000d	0f 57 c9	 xorps	 xmm1, xmm1
  00010	45 8b c1	 mov	 r8d, r9d

; 1339 : 	for (i = 0; i < sampleLength; i++)

  00013	85 d2		 test	 edx, edx
  00015	0f 84 18 02 00
	00		 je	 $LN30@normalize8
  0001b	0f 28 1d 00 00
	00 00		 movaps	 xmm3, XMMWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00022	83 fa 04	 cmp	 edx, 4
  00025	72 3f		 jb	 SHORT $LN16@normalize8

; 1335 : 	uint32_t i;
; 1336 : 	double dSample, dSampleVolPeak, dGain;
; 1337 : 
; 1338 : 	dSampleVolPeak = 0.0;

  00027	44 8b da	 mov	 r11d, edx
  0002a	0f 57 d2	 xorps	 xmm2, xmm2
  0002d	41 83 e3 fc	 and	 r11d, -4		; fffffffcH
$LL4@normalize8:

; 1340 : 	{
; 1341 : 		dSample = fabs(dSampleData[i]);

  00031	41 8b c0	 mov	 eax, r8d
  00034	0f 10 04 c1	 movups	 xmm0, XMMWORD PTR [rcx+rax*8]
  00038	41 8d 40 02	 lea	 eax, DWORD PTR [r8+2]
  0003c	41 83 c0 04	 add	 r8d, 4
  00040	0f 54 c3	 andps	 xmm0, xmm3

; 1342 : 		if (dSampleVolPeak < dSample)

  00043	66 0f 5f c8	 maxpd	 xmm1, xmm0
  00047	0f 10 04 c1	 movups	 xmm0, XMMWORD PTR [rcx+rax*8]
  0004b	0f 54 c3	 andps	 xmm0, xmm3
  0004e	66 0f 5f d0	 maxpd	 xmm2, xmm0
  00052	45 3b c3	 cmp	 r8d, r11d
  00055	72 da		 jb	 SHORT $LL4@normalize8

; 1335 : 	uint32_t i;
; 1336 : 	double dSample, dSampleVolPeak, dGain;
; 1337 : 
; 1338 : 	dSampleVolPeak = 0.0;

  00057	66 0f 5f ca	 maxpd	 xmm1, xmm2
  0005b	0f 28 c1	 movaps	 xmm0, xmm1
  0005e	66 0f 15 c1	 unpckhpd xmm0, xmm1
  00062	f2 0f 5f c8	 maxsd	 xmm1, xmm0
$LN16@normalize8:

; 1339 : 	for (i = 0; i < sampleLength; i++)

  00066	44 3b c2	 cmp	 r8d, edx
  00069	0f 83 97 00 00
	00		 jae	 $LN27@normalize8
  0006f	8b c2		 mov	 eax, edx
  00071	48 89 1c 24	 mov	 QWORD PTR [rsp], rbx
  00075	41 2b c0	 sub	 eax, r8d
  00078	41 8b d8	 mov	 ebx, r8d
  0007b	83 f8 04	 cmp	 eax, 4
  0007e	72 5e		 jb	 SHORT $LC28@normalize8
  00080	8b c2		 mov	 eax, edx
  00082	48 83 c1 10	 add	 rcx, 16
  00086	41 2b c0	 sub	 eax, r8d
  00089	83 e8 04	 sub	 eax, 4
  0008c	c1 e8 02	 shr	 eax, 2
  0008f	ff c0		 inc	 eax
  00091	48 8d 0c d9	 lea	 rcx, QWORD PTR [rcx+rbx*8]
  00095	44 8b d8	 mov	 r11d, eax
  00098	45 8d 04 80	 lea	 r8d, DWORD PTR [r8+rax*4]
  0009c	48 8d 1c 83	 lea	 rbx, QWORD PTR [rbx+rax*4]
$LL29@normalize8:

; 1340 : 	{
; 1341 : 		dSample = fabs(dSampleData[i]);

  000a0	f2 0f 10 41 f0	 movsd	 xmm0, QWORD PTR [rcx-16]
  000a5	f2 0f 10 11	 movsd	 xmm2, QWORD PTR [rcx]
  000a9	0f 54 c3	 andps	 xmm0, xmm3

; 1342 : 		if (dSampleVolPeak < dSample)

  000ac	f2 0f 5f c1	 maxsd	 xmm0, xmm1
  000b0	f2 0f 10 49 f8	 movsd	 xmm1, QWORD PTR [rcx-8]

; 1343 : 			dSampleVolPeak = dSample;

  000b5	48 8d 49 20	 lea	 rcx, QWORD PTR [rcx+32]
  000b9	0f 54 cb	 andps	 xmm1, xmm3
  000bc	0f 54 d3	 andps	 xmm2, xmm3
  000bf	f2 0f 5f c8	 maxsd	 xmm1, xmm0
  000c3	f2 0f 5f d1	 maxsd	 xmm2, xmm1
  000c7	f2 0f 10 49 e8	 movsd	 xmm1, QWORD PTR [rcx-24]
  000cc	0f 54 cb	 andps	 xmm1, xmm3
  000cf	f2 0f 5f ca	 maxsd	 xmm1, xmm2
  000d3	49 83 eb 01	 sub	 r11, 1
  000d7	75 c7		 jne	 SHORT $LL29@normalize8

; 1339 : 	for (i = 0; i < sampleLength; i++)

  000d9	44 3b c2	 cmp	 r8d, edx
  000dc	73 24		 jae	 SHORT $LN51@normalize8
$LC28@normalize8:
  000de	8b c2		 mov	 eax, edx
  000e0	49 8d 0c da	 lea	 rcx, QWORD PTR [r10+rbx*8]
  000e4	41 2b c0	 sub	 eax, r8d
  000e7	44 8b c0	 mov	 r8d, eax
$LC43@normalize8:

; 1340 : 	{
; 1341 : 		dSample = fabs(dSampleData[i]);

  000ea	f2 0f 10 01	 movsd	 xmm0, QWORD PTR [rcx]
  000ee	48 8d 49 08	 lea	 rcx, QWORD PTR [rcx+8]
  000f2	0f 54 c3	 andps	 xmm0, xmm3

; 1342 : 		if (dSampleVolPeak < dSample)

  000f5	f2 0f 5f c1	 maxsd	 xmm0, xmm1

; 1343 : 			dSampleVolPeak = dSample;

  000f9	0f 28 c8	 movaps	 xmm1, xmm0
  000fc	49 83 e8 01	 sub	 r8, 1
  00100	75 e8		 jne	 SHORT $LC43@normalize8
$LN51@normalize8:
  00102	48 8b 1c 24	 mov	 rbx, QWORD PTR [rsp]
$LN27@normalize8:

; 1344 : 	}
; 1345 : 
; 1346 : 	if (dSampleVolPeak <= 0.0)

  00106	66 0f 2f cc	 comisd	 xmm1, xmm4
  0010a	0f 86 23 01 00
	00		 jbe	 $LN30@normalize8

; 1347 : 		return;
; 1348 : 
; 1349 : 	dGain = INT8_MAX / dSampleVolPeak;

  00110	f2 0f 10 15 00
	00 00 00	 movsd	 xmm2, QWORD PTR __real@405fc00000000000
  00118	f2 0f 5e d1	 divsd	 xmm2, xmm1
  0011c	0f 28 da	 movaps	 xmm3, xmm2
  0011f	66 0f 14 db	 unpcklpd xmm3, xmm3

; 1350 : 	for (i = 0; i < sampleLength; i++)

  00123	83 fa 08	 cmp	 edx, 8
  00126	72 6b		 jb	 SHORT $LN18@normalize8

; 1347 : 		return;
; 1348 : 
; 1349 : 	dGain = INT8_MAX / dSampleVolPeak;

  00128	44 8b c2	 mov	 r8d, edx
  0012b	41 bb 04 00 00
	00		 mov	 r11d, 4
  00131	41 83 e0 f8	 and	 r8d, -8			; fffffff8H
  00135	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL7@normalize8:

; 1351 : 		dSampleData[i] *= dGain;

  00140	43 0f 10 04 ca	 movups	 xmm0, XMMWORD PTR [r10+r9*8]
  00145	41 8d 43 fe	 lea	 eax, DWORD PTR [r11-2]
  00149	0f 28 cb	 movaps	 xmm1, xmm3
  0014c	66 0f 59 c3	 mulpd	 xmm0, xmm3
  00150	43 0f 11 04 ca	 movups	 XMMWORD PTR [r10+r9*8], xmm0
  00155	41 83 c1 08	 add	 r9d, 8
  00159	41 0f 10 04 c2	 movups	 xmm0, XMMWORD PTR [r10+rax*8]
  0015e	66 0f 59 c3	 mulpd	 xmm0, xmm3
  00162	41 0f 11 04 c2	 movups	 XMMWORD PTR [r10+rax*8], xmm0
  00167	41 8b c3	 mov	 eax, r11d
  0016a	41 0f 10 04 c2	 movups	 xmm0, XMMWORD PTR [r10+rax*8]
  0016f	66 0f 59 c8	 mulpd	 xmm1, xmm0
  00173	41 0f 11 0c c2	 movups	 XMMWORD PTR [r10+rax*8], xmm1
  00178	41 8d 43 02	 lea	 eax, DWORD PTR [r11+2]
  0017c	41 83 c3 08	 add	 r11d, 8
  00180	41 0f 10 04 c2	 movups	 xmm0, XMMWORD PTR [r10+rax*8]
  00185	66 0f 59 c3	 mulpd	 xmm0, xmm3
  00189	41 0f 11 04 c2	 movups	 XMMWORD PTR [r10+rax*8], xmm0
  0018e	45 3b c8	 cmp	 r9d, r8d
  00191	72 ad		 jb	 SHORT $LL7@normalize8
$LN18@normalize8:

; 1350 : 	for (i = 0; i < sampleLength; i++)

  00193	44 3b ca	 cmp	 r9d, edx
  00196	0f 83 97 00 00
	00		 jae	 $LN30@normalize8
  0019c	8b c2		 mov	 eax, edx
  0019e	45 8b d9	 mov	 r11d, r9d
  001a1	41 2b c1	 sub	 eax, r9d
  001a4	83 f8 04	 cmp	 eax, 4
  001a7	72 6a		 jb	 SHORT $LC31@normalize8
  001a9	8b c2		 mov	 eax, edx
  001ab	49 8d 4a 10	 lea	 rcx, QWORD PTR [r10+16]
  001af	41 2b c1	 sub	 eax, r9d
  001b2	4a 8d 0c c9	 lea	 rcx, QWORD PTR [rcx+r9*8]
  001b6	83 e8 04	 sub	 eax, 4
  001b9	c1 e8 02	 shr	 eax, 2
  001bc	ff c0		 inc	 eax
  001be	44 8b c0	 mov	 r8d, eax
  001c1	45 8d 0c 81	 lea	 r9d, DWORD PTR [r9+rax*4]
  001c5	4d 8d 1c 83	 lea	 r11, QWORD PTR [r11+rax*4]
  001c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL32@normalize8:

; 1351 : 		dSampleData[i] *= dGain;

  001d0	48 8d 49 20	 lea	 rcx, QWORD PTR [rcx+32]
  001d4	0f 28 c2	 movaps	 xmm0, xmm2
  001d7	f2 0f 59 41 d0	 mulsd	 xmm0, QWORD PTR [rcx-48]
  001dc	0f 28 ca	 movaps	 xmm1, xmm2
  001df	f2 0f 59 49 d8	 mulsd	 xmm1, QWORD PTR [rcx-40]
  001e4	f2 0f 11 41 d0	 movsd	 QWORD PTR [rcx-48], xmm0
  001e9	0f 28 c2	 movaps	 xmm0, xmm2
  001ec	f2 0f 59 41 e0	 mulsd	 xmm0, QWORD PTR [rcx-32]
  001f1	f2 0f 11 49 d8	 movsd	 QWORD PTR [rcx-40], xmm1
  001f6	0f 28 ca	 movaps	 xmm1, xmm2
  001f9	f2 0f 59 49 e8	 mulsd	 xmm1, QWORD PTR [rcx-24]
  001fe	f2 0f 11 41 e0	 movsd	 QWORD PTR [rcx-32], xmm0
  00203	f2 0f 11 49 e8	 movsd	 QWORD PTR [rcx-24], xmm1
  00208	49 83 e8 01	 sub	 r8, 1
  0020c	75 c2		 jne	 SHORT $LL32@normalize8

; 1350 : 	for (i = 0; i < sampleLength; i++)

  0020e	44 3b ca	 cmp	 r9d, edx
  00211	73 20		 jae	 SHORT $LN30@normalize8
$LC31@normalize8:
  00213	41 2b d1	 sub	 edx, r9d
  00216	4b 8d 04 da	 lea	 rax, QWORD PTR [r10+r11*8]
  0021a	8b ca		 mov	 ecx, edx
$LC46@normalize8:
  0021c	48 8d 40 08	 lea	 rax, QWORD PTR [rax+8]

; 1351 : 		dSampleData[i] *= dGain;

  00220	0f 28 c2	 movaps	 xmm0, xmm2
  00223	f2 0f 59 40 f8	 mulsd	 xmm0, QWORD PTR [rax-8]
  00228	f2 0f 11 40 f8	 movsd	 QWORD PTR [rax-8], xmm0
  0022d	48 83 e9 01	 sub	 rcx, 1
  00231	75 e9		 jne	 SHORT $LC46@normalize8
$LN30@normalize8:

; 1352 : }

  00233	48 83 c4 08	 add	 rsp, 8
  00237	c3		 ret	 0
normalize8bitDoubleSigned ENDP
_TEXT	ENDS
END
